<!--
CURRENT BUG LIST (address later)
[ ] When reverting back to Base64 encoded thumbnails from dynamic loading,
      thumbnails do not properly generate (all patterns show "No Thumbnail").
[ ] The 'create set' button should be disabled when selected patterns are from multiple creators.
[ ] The vertical/horizontal grids are flipped IMO. 3x1 should mean 3 columns, 1 row and right now
      it means the opposite!
[ ] Fix selected "Select" button CSS
[ ] Hover transitions on selected pattern cards vs unselected:
      selected cards clonk down while unselected cards ease down. how do that on selected cards?!
[ ] Rename the farts css class
[ ] Make Tags and Creators sections of the sidebar collapsable & start with Creators collapsed
[ ] Add sort by # of patterns and sort alphabetical options to the Creators tab
[ ] Fix the CSS on the selected tags section
[ ] Fix the CSS on the creators' tab
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <link
      rel="preload"
      href="FOT-Seurat-Pro-B.woff"
      as="font"
      type="font/woff"
      crossorigin
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animal Crossing Pattern Collection Manager</title>
    <style>
      :root {
        --primary-color: #56acda;
        --secondary-color: #f4f4f4;
        --border-color: #e0e0e0;
        --text-color: #333;
        --accent-color: #f0c030;
        --error-color: #e74c3c;
        --success-color: #2ecc71;
      }

      @font-face {
        font-family: "Seurat Pro B";
        src: url("fonts/FOT-SeuratProDB.woff2") format("woff2");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: "Seurat Pro B";
        src: url("fonts/nintendoP_Seurat-B_003.woff2") format("woff2");
        font-weight: bold;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: "Rodin NTLG EB";
        src: url("fonts/FOT-RodinNTLGProMRegular.woff2") format("woff2");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: "Rodin NTLG EB";
        src: url("fonts/FOT-RodinNTLGProB.woff2") format("woff2");
        font-weight: bold;
        font-style: normal;
        font-display: swap;
      }

      /* @font-face {
        font-family: "Humming";
        src: url("nintendoP_Humming-E_002prRegular-FontForge.woff2")
          format("woff2");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: "Farts";
        src: url("nintendoP_Humming-E_002pr-Regular-Glyphr.otf")
          format("opentype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: "Farts";
        src: url("./fontworks/FOT-Seurat-Pro-EB.otf") format("opentype");
        font-weight: bold;
        font-style: normal;
        font-display: swap;
      } */

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Seurat Pro B", "Segoe UI", Tahoma, Geneva, Verdana,
          sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: #d3efff;
      }

      .farts {
        background: white;
        padding-top: 20px;
      }

      .container {
        /* max-width: 1175px; */
        margin: 0 auto;
        padding: 20px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 15px;
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 10px;
        padding-left: 20px;
      }

      .logo img {
        height: 40px;
      }

      .logo h1 {
        font-size: 1.8rem;
        color: var(--primary-color);
      }

      .header-actions {
        padding-right: 20px;
      }

      nav {
        background-color: var(--secondary-color);
        border-bottom: 2px solid var(--primary-color);
      }

      .nav-tabs {
        display: flex;
        list-style: none;
        margin: 0 20px;
      }

      .nav-tabs li {
        padding: 5px 10px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: color 0.2s, background-color 0.2s;
      }

      .nav-tabs li:hover {
        background-color: var(--primary-color);
        color: white;
      }

      .nav-tabs li.active {
        border-bottom: 2px solid var(--primary-color);
        font-weight: bold;
        background: var(--primary-color);
        color: white;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .action-bar {
        display: flex;
        justify-content: space-between;
        align-items: center; /* Center align all items */
        margin-bottom: 20px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        gap: 10px;
      }

      /* Properly align the control buttons group */
      .action-bar > div:last-child:not(.search-bar) {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 0 0 auto; /* Don't grow or shrink */
      }

      .action-bar input,
      .action-bar button {
        height: 34px; /* Consistent height for all elements */
      }

      .action-bar input {
        padding: 8px 12px;
      }

      .search-bar {
        display: flex;
        gap: 10px;
        flex: 0 1 500px; /* Flex basis instead of max-width, won't grow beyond 500px */
        min-width: 250px; /* Ensure minimum width on small screens */
      }

      .search-bar input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }

      .btn {
        padding: 7px 10px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: color 0.2s, background-color 0.2s;
        box-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.15);
        font-family: "Rodin NTLG EB", "Segoe UI", Tahoma, Geneva, Verdana,
          sans-serif;
        font-weight: bold;
      }

      #import-btn {
        font-weight: bold;
      }

      .btn:hover {
        background-color: #62c7fd;
      }

      .btn-secondary {
        background-color: var(--secondary-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }

      .btn-secondary:hover {
        background-color: #e8e8e8;
      }

      .pattern-gallery {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }

      .pattern-card {
        background-color: white;
        border-radius: 8px;
        overflow: hidden;
        border-bottom: 2px solid var(--primary-color);
        transition: transform 0.2s, box-shadow 0.2s;
        width: 200px;
        display: flex;
        flex-direction: column;
      }

      .pattern-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .pattern-card.selected:hover {
        transform: translateY(-5px);
      }

      .pattern-thumbnail {
        width: 100%;
        height: 200px;
        object-fit: contain;
        background-color: #f8f8f8;
        border-bottom: 1px solid var(--border-color);
        image-rendering: pixelated; /* Modern browsers */
        image-rendering: -moz-crisp-edges; /* Firefox */
        image-rendering: crisp-edges; /* Safari */
        -ms-interpolation-mode: nearest-neighbor; /* IE (deprecated) */
      }

      .pattern-info {
        padding: 12px;
      }

      .pattern-name {
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 1.1rem;
      }

      .pattern-creator {
        color: #666;
        font-size: 0.9rem;
        margin-bottom: 8px;
      }

      .tag-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 8px;
      }

      .tag {
        background-color: var(--secondary-color);
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .modal {
        background-color: white;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 20px;
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #999;
      }

      .modal-title {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
      }

      .pixel-art-image {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;
      }

      .sidebar {
        width: 250px;
        height: fit-content;
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-right: 20px;
        border-bottom: 2px solid var(--primary-color);
      }

      .sidebar > div:last-child {
        margin-bottom: 0;
      }

      .sidebar-section {
        margin-bottom: 15px;
      }

      .sidebar-title {
        /* font-family: "Rodin NTLG EB", "Segoe UI", Tahoma, Geneva, Verdana,
          sans-serif; */
        font-weight: bold;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid var(--border-color);
      }

      .sidebar-list {
        list-style: none;
      }

      .sidebar-list li {
        padding: 5px 0;
        cursor: pointer;
      }

      .sidebar-list li:hover {
        color: var(--primary-color);
      }

      .filter-count {
        background-color: var(--primary-color);
        color: white;
        border-radius: 10px;
        padding: 2px 6px;
        font-size: 0.7rem;
        margin-left: 5px;
      }

      .main-content {
        display: flex;
      }

      .content-area {
        flex: 1;
      }

      .error-message {
        color: var(--error-color);
        background-color: rgba(231, 76, 60, 0.1);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      .success-message {
        color: var(--success-color);
        background-color: rgba(46, 204, 113, 0.1);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .form-group label {
        display: block;
        margin-bottom: 5px;
      }

      .form-group input,
      .form-group textarea,
      .form-group select {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }

      .tag-input {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        padding: 5px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        min-height: 40px;
      }

      .tag-input input {
        flex: 1;
        min-width: 60px;
        border: none;
        outline: none;
        padding: 5px;
      }

      .tag-item {
        display: flex;
        align-items: center;
        background-color: var(--primary-color);
        color: white;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .tag-remove {
        margin-left: 5px;
        cursor: pointer;
      }

      .pattern-detail {
        display: flex;
        gap: 20px;
      }

      .pattern-image {
        flex: 0 0 250px;
      }

      .pattern-image img {
        width: 100%;
        height: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }

      .pattern-details {
        flex: 1;
      }

      .set-manager {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
      }

      .set-item {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        width: fit-content;
      }

      .set-patterns {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        overflow-x: auto;
        padding-bottom: 10px;
      }

      .set-pattern {
        width: 80px;
        height: 80px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: move;
        image-rendering: pixelated;
      }

      .creator-item {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .creator-info {
        flex: 1;
      }

      .creator-stats {
        display: flex;
        gap: 15px;
        color: #666;
      }

      .notification {
        position: fixed;
        top: 20px; /* Changed from bottom to top */
        right: 20px;
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transform: translateY(
          -100px
        ); /* Changed direction for slide-in from top */
        opacity: 0;
        transition: transform 0.3s, opacity 0.3s;
        z-index: 1001;
      }

      .notification.show {
        transform: translateY(0);
        opacity: 1;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(120, 200, 80, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      .sort-dropdown-container {
        position: relative;
        display: inline-block;
      }

      .sort-dropdown-button {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .dropdown-arrow {
        font-size: 0.7rem;
        margin-left: 5px;
      }

      .sort-dropdown-menu {
        position: absolute;
        right: 0;
        top: 100%;
        background-color: white;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        width: 220px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 100;
        display: none;
      }

      .sort-dropdown-menu.show {
        display: block;
      }

      .sort-option {
        padding: 8px 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
      }

      .sort-option:hover {
        background-color: var(--secondary-color);
      }

      .sort-option.active {
        background-color: #e8f4e8;
        font-weight: bold;
      }

      .sort-icon {
        display: inline-block;
        width: 16px;
        margin-right: 8px;
        text-align: center;
      }

      .sort-option-setting {
        padding: 8px 12px;
        font-size: 0.9rem;
        color: #666;
      }

      hr {
        margin: 5px 0;
        border: none;
        border-top: 1px solid var(--border-color);
      }

      .set-card {
        position: relative;
      }
      .set-thumbnail {
        position: relative;
        width: 100%;
        height: 200px;
        background-color: #f8f8f8;
        border-bottom: 1px solid var(--border-color);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .set-grid-preview {
        display: grid;
        width: 100%;
        height: 100%;
        gap: 2px;
      }
      /* Base styles for horizontal grids */
      .set-grid-preview.horizontal-grid {
        align-self: center;
        margin: 0 auto;
        display: grid;
        grid-template-rows: 1fr;
      }
      /* Specific styles for 2x1 grids */
      .set-grid-preview.horizontal-grid[style*="--cols: 2"] {
        height: 50%; /* Taller height for 2x1 grids */
        grid-template-columns: repeat(2, 1fr);
      }
      /* Specific styles for 3x1 grids */
      .set-grid-preview.horizontal-grid[style*="--cols: 3"] {
        height: 33%; /* Original height for 3x1 grids */
        grid-template-columns: repeat(3, 1fr);
      }
      /* Base styles for vertical grids */
      .set-grid-preview.vertical-grid {
        align-self: center;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr;
      }
      /* Specific styles for 1x2 grids */
      .set-grid-preview.vertical-grid[style*="--rows: 2"] {
        width: 50%; /* Wider width for 1x2 grids */
        grid-template-rows: repeat(2, 1fr);
      }
      /* Specific styles for 1x3 grids */
      .set-grid-preview.vertical-grid[style*="--rows: 3"] {
        width: 33%; /* Original width for 1x3 grids */
        grid-template-rows: repeat(3, 1fr);
      }
      /* Square grids (e.g., 2x2, 3x3) */
      .set-grid-preview.square-grid {
        width: 100%;
        height: 100%;
      }
      .set-grid-item {
        width: 100%;
        height: 100%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1/1;
      }
      .set-grid-item img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        image-rendering: pixelated;
      }
      .set-grid-item.empty {
        background-color: var(--secondary-color);
      }
      .set-collection-preview {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 2px;
        width: 100%;
        height: 100%;
      }
      .set-collection-item {
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .set-collection-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .set-collection-item.more {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--secondary-color);
      }
      .more-patterns {
        font-weight: bold;
        color: var(--primary-color);
      }
      .set-badge {
        display: inline-block;
        background-color: var(--primary-color);
        color: white;
        font-size: 0.7rem;
        padding: 1px 6px;
        border-radius: 10px;
        margin-left: 5px;
        vertical-align: middle;
        font-weight: normal;
      }
      .set-count {
        font-size: 0.85rem;
        color: #666;
        margin-top: 5px;
      }
      .set-grid-size {
        font-size: 0.85rem;
        color: #666;
      }

      .pattern-group-section {
        margin-bottom: 20px;
        width: 100%;
      }
      /* Group headers styling */
      .group-header {
        background-color: var(--secondary-color);
        padding: 10px 15px;
        margin: 15px 0 20px 0;
        border-radius: 4px;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid var(--primary-color);
        font-size: 1.5rem;
      }
      /* First group header should have smaller top margin */
      .group-header:first-of-type {
        margin-top: 0;
      }

      .group-header .group-count {
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
        padding: 2px 8px;
        font-size: 0.9rem;
        min-width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      #back-to-top-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        font-size: 24px;
        border: none;
        cursor: pointer;
        display: none;
        justify-content: center;
        align-items: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 99;
        transition: background-color 0.2s, transform 0.2s;
      }
      #back-to-top-btn:hover {
        background-color: #62c7fd;
        transform: translateY(-3px);
      }
      #back-to-top-btn.visible {
        display: flex;
      }

      .active-filters-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        margin: 0;
        padding: 0;
        background-color: var(--secondary-color);
        border-radius: 5px;
        flex: 2; /* Take available space */
        min-width: 200px; /* Ensure doesn't get too small */
        min-height: 40px;
      }

      .active-filters-title {
        font-weight: bold;
        margin: 0; /* Remove any margin */
        display: flex;
        align-items: center;
        height: 100%;
      }

      .active-filters-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        flex: 1;
        align-items: center;
      }

      .active-filter {
        background-color: white;
        border: 1px solid var(--border-color);
        border-radius: 15px;
        padding: 4px 10px;
        font-size: 0.9rem;
        margin: 2px 0; /* Add minimal vertical margin */
        height: 28px; /* Specific height for filter tags */
        display: flex;
        align-items: center;
      }

      .filter-remove {
        margin-left: 5px;
        color: #999;
        font-weight: bold;
        cursor: pointer;
        font-size: 1.2rem;
      }

      .filter-remove:hover {
        color: var(--error-color);
      }

      .tag-filter {
        background-color: #e8f4e8;
        border-color: var(--primary-color);
      }

      .creator-filter {
        background-color: #e8eaf4;
        border-color: #6495ed;
      }

      .set-filter {
        background-color: #f4eee8;
        border-color: var(--accent-color);
      }

      .search-filter {
        background-color: #f0f0f0;
      }

      .clear-all-filters {
        padding: 4px 10px !important;
        font-size: 0.9rem !important;
      }

      .sidebar-list li.active {
        background-color: var(--primary-color);
        color: white;
        border-radius: 4px;
        padding-left: 10px;
        position: relative;
      }

      .sidebar-list li.active .filter-count {
        background-color: white;
        color: var(--primary-color);
      }

      .sidebar-list li .filter-remove {
        position: absolute;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }

      .set-pattern-item {
        display: flex;
        align-items: center;
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        margin-bottom: 8px;
        padding: 5px;
        position: relative;
      }
      .set-pattern-item img {
        width: 64px;
        height: 64px;
        margin-right: 10px;
        border: 1px solid var(--border-color);
      }
      .pattern-order {
        position: absolute;
        top: 5px;
        left: 5px;
        background: var(--primary-color);
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .remove-pattern {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 24px;
        height: 24px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid var(--border-color);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 16px;
        line-height: 1;
      }
      .set-pattern-item.dragging {
        opacity: 0.5;
      }
      .set-patterns-container {
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 10px;
        background: var(--secondary-color);
        min-height: 100px;
      }
      .help-text {
        font-size: 0.8rem;
        color: #666;
        margin-top: 5px;
      }

      .creator-filter-info {
        background-color: var(--secondary-color);
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 15px;
        font-size: 0.9rem;
      }
      .pattern-selection {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 10px;
        max-height: 400px;
        overflow-y: auto;
        margin: 15px 0;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }
      .pattern-select-item {
        position: relative;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 4px;
        padding: 5px;
        transition: all 0.2s;
      }
      .pattern-select-item.selected {
        border-color: var(--primary-color);
        background-color: rgba(120, 200, 80, 0.1);
      }
      .pattern-select-item img {
        width: 100%;
        aspect-ratio: 1;
        object-fit: contain;
        border: 1px solid var(--border-color);
      }
      .pattern-select-item .pattern-name {
        font-size: 0.8rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
        margin-top: 5px;
      }
      .pattern-select-item .pattern-creator {
        font-size: 0.7rem;
        color: #666;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
      }
      .pattern-in-set {
        position: absolute;
        top: 0;
        right: 0;
        background: var(--primary-color);
        color: white;
        padding: 2px 4px;
        font-size: 0.6rem;
        border-bottom-left-radius: 4px;
      }

      .set-detail-info {
        margin-bottom: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
      }
      .set-detail-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
      }
      .set-notes {
        flex-basis: 100%;
        margin-top: 10px;
        padding: 10px;
        background-color: var(--secondary-color);
        border-radius: 4px;
        white-space: pre-line;
      }
      .set-patterns-container {
        margin-bottom: 20px;
        max-height: 60vh;
        overflow-y: auto;
      }
      .set-grid-layout {
        display: grid;
        gap: 10px;
        justify-content: center;
      }
      .set-collection-layout {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
      }
      .set-detail-pattern {
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow: hidden;
        background-color: white;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      .set-detail-pattern:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .set-detail-pattern img {
        width: 100%;
        aspect-ratio: 1;
        object-fit: contain;
        display: block;
      }
      .set-detail-pattern .pattern-name {
        padding: 5px;
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .empty-grid-item {
        background-color: var(--secondary-color);
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 80px;
      }

      .creator-edit-form {
        max-width: 100%;
      }
      .help-text {
        font-size: 0.8rem;
        color: #666;
        margin-top: 2px;
      }
      .creator-stats {
        margin-top: 20px;
        padding: 15px;
        background-color: var(--secondary-color);
        border-radius: 5px;
      }
      .stats-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-top: 10px;
      }
      .stat-item {
        flex: 1;
        min-width: 120px;
      }
      .stat-label {
        font-size: 0.9rem;
        color: #666;
      }
      .stat-value {
        font-size: 1.2rem;
        font-weight: bold;
        margin-top: 5px;
      }
      .settings-section {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }
      .storage-meter-container {
        margin: 15px 0;
      }
      .storage-meter {
        height: 20px;
        background-color: #f0f0f0;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 5px;
      }
      .storage-meter-fill {
        height: 100%;
        background-color: var(--primary-color);
        width: 0%;
        transition: width 0.3s;
      }
      .storage-meter-labels {
        display: flex;
        justify-content: flex-end;
        font-size: 0.9rem;
        color: #666;
      }
      .storage-breakdown {
        font-size: 0.9rem;
        color: #666;
      }
      .warning-message {
        background-color: rgba(243, 156, 18, 0.1);
        border-left: 3px solid #f39c12;
        padding: 10px;
        margin: 10px 0;
        font-size: 0.9rem;
      }

      .loader-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .loader-content {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        text-align: center;
      }
      .loader-message {
        margin-top: 10px;
        font-weight: bold;
      }
      .duplicate-sets-container {
        margin-top: 20px;
      }
      .duplicate-set {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        overflow: hidden;
      }
      .duplicate-set-header {
        padding: 15px;
        background: var(--secondary-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .duplicate-set-header h3 {
        margin: 0;
      }
      .similarity-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
        color: white;
      }
      .similarity-badge.high {
        background-color: var(--success-color);
      }
      .duplicate-patterns {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        padding: 15px;
      }
      .duplicate-pattern {
        flex: 1;
        min-width: 200px;
        max-width: 300px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow: hidden;
      }
      .pattern-preview {
        position: relative;
      }
      .pattern-preview img {
        width: 100%;
        height: auto;
        display: block;
      }
      .pattern-select {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 4px;
        border-radius: 2px;
        display: flex;
        justify-content: center;
      }
      .pattern-details {
        padding: 10px;
      }
      .pattern-name {
        font-weight: bold;
        margin-bottom: 2px;
      }
      .pattern-creator {
        color: #666;
        font-size: 0.9rem;
        margin-bottom: 5px;
      }
      .pattern-metadata {
        font-size: 0.8rem;
        color: #666;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .duplicate-actions {
        padding: 15px;
        border-top: 1px solid var(--border-color);
        display: flex;
        gap: 10px;
      }

      /* Selection mode button */
      #selection-mode-btn.active {
        background-color: var(--primary-color);
        color: white;
      }
      .selection-icon {
        margin-right: 5px;
      }

      /* Pattern card selection styles */
      .pattern-card {
        position: relative;
      }
      .pattern-card.selected {
        box-shadow: 0 0 0 3px var(--primary-color);
        border: none;
        transition: border 0.2s, box-shadow 0.2s;
      }
      .pattern-select {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
      }
      .pattern-select input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
      }

      /* Selection panel */
      .selection-panel {
        position: fixed;
        bottom: -60px;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        border-radius: 8px 8px 0 0;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
        padding: 15px 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        transition: bottom 0.3s ease;
        z-index: 100;
      }
      .selection-panel.active {
        bottom: 0;
      }
      .selection-count {
        font-weight: bold;
        margin-right: 10px;
      }
      .selection-actions {
        display: flex;
        gap: 10px;
      }
      .btn-small {
        padding: 6px 12px;
        font-size: 0.9rem;
      }

      .creator-rank {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 0.7rem;
        color: white;
        margin-left: 8px;
        vertical-align: middle;
      }
      .creator-rank.verified {
        background-color: #2ecc71; /* Green */
      }
      .creator-rank.unknown {
        background-color: #3498db; /* Blue */
      }
      .creator-rank.plagiarist {
        background-color: #e74c3c; /* Red */
      }
      .verified-badge,
      .plagiarist-badge {
        display: inline-flex;
        align-items: center;
        font-size: 0.8rem;
        width: 100%;
        padding: 2px 15px;
        font-weight: bold;
      }
      .verified-badge {
        /* border-top: 2px solid #2ecc71; */
        border-bottom: 2px solid #2ecc71;
      }
      .plagiarist-badge {
        /* border-top: 2px solid #e74c3c; */
        border-bottom: 2px solid #e74c3c;
      }
      .creator-code {
        font-family: monospace;
        background-color: var(--secondary-color);
        padding: 2px 4px;
        border-radius: 4px;
        margin-left: 5px;
      }
      .creator-card {
        display: flex;
        flex-direction: column;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 15px;
        margin-bottom: 15px;
      }
      .creator-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .creator-details {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }
      .creator-detail {
        display: flex;
        flex-direction: column;
        background-color: var(--secondary-color);
        padding: 8px 12px;
        border-radius: 5px;
        flex: 1;
        min-width: 150px;
      }
      .detail-label {
        font-size: 0.8rem;
        color: #666;
      }
      .detail-value {
        font-weight: bold;
        margin-top: 3px;
      }
      .creator-actions {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      .create-creator-btn {
        margin-left: auto;
      }

      .creator-card {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .creator-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .creator-rank {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 0.7rem;
        color: white;
        margin-left: 8px;
        vertical-align: middle;
      }

      .creator-rank.verified {
        background-color: #2ecc71;
      }

      .creator-rank.unknown {
        background-color: #3498db;
      }

      .creator-rank.plagiarist {
        background-color: #e74c3c;
      }

      .creator-code {
        font-family: monospace;
        background-color: var(--secondary-color);
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
      }

      .creator-details {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }

      .creator-detail {
        background-color: var(--secondary-color);
        padding: 10px;
        border-radius: 5px;
        flex: 1;
        min-width: 100px;
      }

      .detail-label {
        font-size: 0.8rem;
        color: #666;
        margin-bottom: 5px;
      }

      .detail-value {
        font-weight: bold;
      }

      .creator-notes {
        background-color: var(--secondary-color);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
        font-style: italic;
        color: #555;
      }

      .creator-actions {
        display: flex;
        gap: 10px;
      }

      /* Style for pattern badges */
      .pattern-name .verified-badge,
      .pattern-name .plagiarist-badge {
        font-size: 1rem;
        vertical-align: middle;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 768px) {
        .main-content {
          flex-direction: column;
        }

        .sidebar {
          width: 100%;
          margin-right: 0;
          margin-bottom: 20px;
        }

        .pattern-detail {
          flex-direction: column;
        }

        .pattern-image {
          flex: none;
          max-width: 100%;
        }

        .action-bar {
          flex-direction: column;
          align-items: stretch;
        }

        .search-bar {
          flex: 1 1 100%; /* Take full width on mobile */
          max-width: none;
        }

        .active-filters-container {
          order: 2; /* Move filters below search */
          margin-top: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="farts">
      <header>
        <div class="logo">
          <img
            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMjYuMjQgMzExLjA3Ij48cGF0aCBmaWxsPSIjMWFhZTVlIiBkPSJNMjY2LjM4IDEuMjZjLS45MyA5LjEyLTcuNzEgNDcuMjEtMjcuMjggODMuNDRhMSAxIDAgMCAxLTEuNy0uMDZjLTQtOC4yNC0yNC44Ni00NC41OC03OS4yOS00NC45MUM5Ni43MSAzOS4zNSA2Ni42NyA4NyA2Ni42NyA4N3MtMjMuNDUgMzIuOTMtMzMuNDkgOTQuODktMjIuNjEgNzktMjIuNjEgNzlMLjM5IDI3N2EyLjU0IDIuNTQgMCAwIDAgMS4xMSAzLjY3YzEzIDUuODEgNzIuNjggMzAuMzggMTUxLjY4IDMwLjM4IDUzLjggMCA3MC03LjU4IDc0LjI1LTEwLjU1YS42MS42MSAwIDAgMC0uMzUtMS4xMmMtMTAuNTUgMS4xNi01MS4yLTUuMjYtNTEuMi00NCAwLTM0Ljc5IDI1LjMtNTEuNjIgNTEuODEtNTIuODMgMTIuNTYtLjU4IDM5LjM1IDQuNzQgNDcuNzIgMjkuMyA3IDIwLjY2LTIuMzEgMzkuMTUtNS40NSA0NC41YS42Mi42MiAwIDAgMCAuNzcuODljOS41Mi0zLjg0IDUzLjcxLTI1Ljc3IDU1LjQ3LTkzLjk1IDEuNTUtNTkuOTEtNDcuNjQtODUuNjItNzAuOC04Ni43MWExLjE4IDEuMTggMCAwIDEtMS0xLjYyYzYuMjMtMTUuOTQgNDUtNTcuMjcgNTEuODQtNjQuNDZhMS41NyAxLjU3IDAgMCAwIDAtMi4xN0ExNTkuMDUgMTU5LjA1IDAgMCAwIDI2OC40Ni4xN2ExLjQyIDEuNDIgMCAwIDAtMi4wOCAxLjA5WiIvPjwvc3ZnPg=="
            alt="Animal Crossing Leaf Logo"
          />
          <h1>ACNH Custom Pattern Manager</h1>
        </div>
        <div class="header-actions">
          <button id="import-btn" class="btn">Import Patterns</button>
        </div>
      </header>

      <nav>
        <ul class="nav-tabs">
          <li class="active" data-tab="patterns">Patterns</li>
          <li data-tab="sets">Sets</li>
          <li data-tab="creators">Creators</li>
          <li data-tab="duplicates">Duplicates</li>
        </ul>
      </nav>
    </div>
    <div class="container">
      <div id="patterns" class="tab-content active">
        <div class="action-bar">
          <div class="search-bar">
            <input
              type="text"
              id="pattern-search"
              placeholder="Search patterns..."
            />
            <button class="btn">Search</button>
          </div>
          <div class="sort-dropdown-container">
            <button
              id="sort-dropdown-button"
              class="btn btn-secondary sort-dropdown-button"
            >
              Sort: Alphabetical <span class="dropdown-arrow">▼</span>
            </button>
            <div class="sort-dropdown-menu">
              <div
                class="sort-option active"
                data-sort="alphabetical"
                data-direction="asc"
              >
                <span class="sort-icon">↓</span> Alphabetical
              </div>
              <div class="sort-option" data-sort="creator" data-direction="asc">
                <span class="sort-icon">↓</span> Group by Creator
              </div>
              <div class="sort-option" data-sort="tag" data-direction="asc">
                <span class="sort-icon">↓</span> Group by Tag
              </div>
              <hr />
              <div class="sort-option-setting">
                <label>
                  <input type="checkbox" id="show-all-tags" disabled />
                  Show patterns under all tags (coming soon)
                </label>
              </div>
            </div>
          </div>
        </div>

        <div class="main-content">
          <div class="sidebar">
            <div class="sidebar-section">
              <h3 class="sidebar-title">Tags</h3>
              <ul class="sidebar-list" id="tag-filters">
                <li>Clothing <span class="filter-count">24</span></li>
                <li>Designs <span class="filter-count">16</span></li>
                <li>Blue <span class="filter-count">8</span></li>
                <li>Path <span class="filter-count">12</span></li>
              </ul>
            </div>
            <div class="sidebar-section">
              <h3 class="sidebar-title">Creators</h3>
              <ul class="sidebar-list" id="creator-filters">
                <li>Creator1 <span class="filter-count">10</span></li>
                <li>Creator2 <span class="filter-count">5</span></li>
              </ul>
            </div>
            <!-- <div class="sidebar-section">
              <h3 class="sidebar-title">Sets</h3>
              <ul class="sidebar-list" id="set-filters">
                <li>Star Collection <span class="filter-count">3</span></li>
                <li>Path Set <span class="filter-count">6</span></li>
              </ul>
            </div> -->
          </div>

          <div class="content-area">
            <div class="pattern-gallery" id="pattern-gallery">
              <!-- Pattern cards will be inserted here -->
            </div>
          </div>
        </div>
      </div>

      <div id="sets" class="tab-content">
        <div class="action-bar">
          <div class="search-bar">
            <input type="text" id="set-search" placeholder="Search sets..." />
            <button class="btn">Search</button>
          </div>
          <div>
            <button id="create-set-btn" class="btn">Create New Set</button>
          </div>
        </div>

        <div class="set-manager" id="set-manager">
          <!-- Set items will be inserted here -->
        </div>
      </div>

      <div id="creators" class="tab-content">
        <div class="action-bar">
          <div class="search-bar">
            <input
              type="text"
              id="creator-search"
              placeholder="Search creators..."
            />
            <button class="btn">Search</button>
          </div>
        </div>

        <div id="creator-list">
          <!-- Creator items will be inserted here -->
        </div>
      </div>

      <div id="duplicates" class="tab-content">
        <div class="action-bar">
          <button id="scan-duplicates-btn" class="btn">
            Scan for Duplicates
          </button>
        </div>

        <div id="duplicates-container">
          <p>No duplicate patterns detected.</p>
        </div>
      </div>
    </div>

    <!-- Pattern Details Modal -->
    <div class="modal-backdrop" id="pattern-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Pattern Details</h2>
        <div class="pattern-detail">
          <div class="pattern-image">
            <img id="modal-pattern-img" src="" alt="Pattern" />
          </div>
          <div class="pattern-details">
            <div class="form-group">
              <label for="pattern-name">Pattern Name</label>
              <input type="text" id="pattern-name" readonly />
            </div>
            <div class="form-group">
              <label for="creator-name">Creator</label>
              <input type="text" id="creator-name" readonly />
            </div>
            <div class="form-group">
              <label for="town-name">Town</label>
              <input type="text" id="town-name" readonly />
            </div>
            <div class="form-group">
              <label for="pattern-tags">Tags</label>
              <div class="tag-input" id="tag-input">
                <!-- Tags will be inserted here -->
                <input type="text" placeholder="Add a tag..." />
              </div>
            </div>
            <div class="form-group">
              <label for="pattern-set">Set</label>
              <select id="pattern-set">
                <option value="">None</option>
                <!-- Set options will be inserted here -->
              </select>
            </div>
            <div class="form-group">
              <label for="set-order">Set Order</label>
              <input type="number" id="set-order" min="1" />
            </div>
            <div class="form-group">
              <label for="pattern-notes">Notes</label>
              <textarea id="pattern-notes" rows="3"></textarea>
            </div>
            <button class="btn" id="save-pattern-btn">Save Changes</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Create Set Modal -->
    <div class="modal-backdrop" id="set-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Create New Set</h2>
        <div class="form-group">
          <label for="set-name">Set Name</label>
          <input type="text" id="set-name" />
        </div>
        <div class="form-group">
          <label for="set-grid-size">Grid Size (Optional)</label>
          <select id="set-grid-size">
            <option value="">No Grid (Collection of Patterns)</option>
            <option value="2x2">2 × 2 Grid</option>
            <option value="3x3">3 × 3 Grid</option>
            <option value="4x4">4 × 4 Grid</option>
            <option value="2x1">2 × 1 Grid (Vertical)</option>
            <option value="1x2">1 × 2 Grid (Horizontal)</option>
            <option value="3x1">3 × 1 Grid (Vertical)</option>
            <option value="1x3">1 × 3 Grid (Horizontal)</option>
          </select>
          <p class="help-text">
            Select a grid size if this set forms a larger image when combined,
            or leave as "No Grid" if it's just a collection.
          </p>
        </div>
        <div class="form-group">
          <label for="set-notes">Notes</label>
          <textarea id="set-notes" rows="3"></textarea>
        </div>
        <button class="btn" id="save-set-btn">Create Set</button>
      </div>
    </div>

    <!-- Import Patterns Modal -->
    <div class="modal-backdrop" id="import-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Import Patterns</h2>
        <div class="form-group">
          <label for="pattern-folder">Select Pattern Folder</label>
          <input
            type="file"
            id="pattern-folder"
            webkitdirectory
            directory
            multiple
          />
        </div>
        <div id="import-status"></div>
        <button class="btn" id="start-import-btn">Import Patterns</button>
      </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
      Operation completed successfully.
    </div>

    <script>
      // Main app data store
      const appData = {
        patterns: {},
        creators: {},
        sets: {},
        processedFiles: new Set(),
        activeFilters: {
          tags: new Set(),
          creators: new Set(),
          sets: new Set(),
          search: "",
          untagged: false,
        },
        selectionMode: false,
        selectedPatterns: new Set(),
      };

      // Global settings object
      const appSettings = {
        storeThumbnailsAsBase64: true,
        lastImportDirectory: "",
      };

      // DOM Elements
      const elements = {
        tabs: document.querySelectorAll(".nav-tabs li"),
        tabContents: document.querySelectorAll(".tab-content"),
        patternGallery: document.getElementById("pattern-gallery"),
        patternModal: document.getElementById("pattern-modal"),
        setModal: document.getElementById("set-modal"),
        importModal: document.getElementById("import-modal"),
        notification: document.getElementById("notification"),
        modalCloseButtons: document.querySelectorAll(".modal-close"),
        importBtn: document.getElementById("import-btn"),
        exportBtn: document.getElementById("export-btn"),
        createSetBtn: document.getElementById("create-set-btn"),
        savePatternBtn: document.getElementById("save-pattern-btn"),
        saveSetBtn: document.getElementById("save-set-btn"),
        startImportBtn: document.getElementById("start-import-btn"),
        scanDuplicatesBtn: document.getElementById("scan-duplicates-btn"),
        patternSearch: document.getElementById("pattern-search"),
        setManager: document.getElementById("set-manager"),
        creatorList: document.getElementById("creator-list"),
        duplicatesContainer: document.getElementById("duplicates-container"),
        tagFilters: document.getElementById("tag-filters"),
        creatorFilters: document.getElementById("creator-filters"),
        setFilters: document.getElementById("set-filters"),
      };

      // Initialize the application
      function initApp() {
        loadDataFromLocalStorage();
        loadAppSettings();
        setupEventListeners();
        setupMetadataImport();
        setupAppSettings();
        renderPatternGallery();
        setupMultiSelectUI();
        renderSidebarFilters();
        enhanceFiltering();
        addBackToTopButton();
        addCreateCreatorButton();
        initSorting();
      }

      // Load data from localStorage
      function loadDataFromLocalStorage() {
        try {
          const storedPatterns = localStorage.getItem("acPatterns");
          const storedCreators = localStorage.getItem("acCreators");
          const storedSets = localStorage.getItem("acSets");
          const storedProcessedFiles = localStorage.getItem("acProcessedFiles");

          if (storedPatterns) appData.patterns = JSON.parse(storedPatterns);
          if (storedCreators) appData.creators = JSON.parse(storedCreators);
          if (storedSets) appData.sets = JSON.parse(storedSets);
          if (storedProcessedFiles) {
            appData.processedFiles = new Set(JSON.parse(storedProcessedFiles));
          }
        } catch (error) {
          console.error("Error loading data from localStorage:", error);
          showNotification(
            "Error loading saved data. Starting fresh.",
            "error"
          );
        }
      }

      // Save data to localStorage
      function saveDataToLocalStorage() {
        try {
          // If not storing base64 thumbnails, create a copy of patterns without the base64 data
          if (!appSettings.storeThumbnailsAsBase64) {
            const patternsForStorage = {};

            for (const id in appData.patterns) {
              const pattern = { ...appData.patterns[id] };

              // Clear base64 data before storing
              if (
                pattern.thumbnailPath &&
                pattern.thumbnailPath.startsWith("data:")
              ) {
                pattern.thumbnailPath = null;
              }

              patternsForStorage[id] = pattern;
            }

            localStorage.setItem(
              "acPatterns",
              JSON.stringify(patternsForStorage)
            );
          } else {
            // Store as is with base64 data
            localStorage.setItem(
              "acPatterns",
              JSON.stringify(appData.patterns)
            );
          }

          // Save other data as before
          localStorage.setItem("acCreators", JSON.stringify(appData.creators));
          localStorage.setItem("acSets", JSON.stringify(appData.sets));
          localStorage.setItem(
            "acProcessedFiles",
            JSON.stringify([...appData.processedFiles])
          );
        } catch (error) {
          console.error("Error saving data to localStorage:", error);
          showNotification(
            "Error saving data. Please export your metadata as backup.",
            "error"
          );
        }
      }

      // Setup event listeners
      function setupEventListeners() {
        // Tab navigation
        elements.tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            const tabId = tab.getAttribute("data-tab");
            elements.tabs.forEach((t) => t.classList.remove("active"));
            elements.tabContents.forEach((tc) => tc.classList.remove("active"));
            tab.classList.add("active");
            document.getElementById(tabId).classList.add("active");

            // Render tab-specific content
            if (tabId === "sets") {
              renderSets();
            } else if (tabId === "creators") {
              renderCreators();
            }
          });
        });

        // Modal close buttons
        elements.modalCloseButtons.forEach((button) => {
          button.addEventListener("click", () => {
            elements.patternModal.style.display = "none";
            elements.setModal.style.display = "none";
            elements.importModal.style.display = "none";
          });
        });

        // Button event listeners
        elements.importBtn.addEventListener("click", () => {
          elements.importModal.style.display = "flex";
        });

        elements.createSetBtn.addEventListener("click", () => {
          elements.setModal.style.display = "flex";
        });

        elements.savePatternBtn.addEventListener("click", savePatternChanges);
        elements.saveSetBtn.addEventListener("click", createNewSet);
        elements.startImportBtn.addEventListener("click", importPatterns);
        elements.scanDuplicatesBtn.addEventListener("click", scanForDuplicates);

        // Search input
        elements.patternSearch.addEventListener(
          "input",
          debounce(function () {
            appData.activeFilters.search = this.value.trim().toLowerCase();
            renderPatternGallery();
            updateActiveFilterDisplay();
          }, 300)
        );
      }

      function addBackToTopButton() {
        // Create the button
        const backToTopBtn = document.createElement("button");
        backToTopBtn.id = "back-to-top-btn";
        backToTopBtn.innerHTML = "↑";
        backToTopBtn.title = "Back to Top";
        backToTopBtn.setAttribute("aria-label", "Back to Top");
        document.body.appendChild(backToTopBtn);

        // Add scroll event listener to show/hide button
        window.addEventListener("scroll", () => {
          if (window.scrollY > 300) {
            backToTopBtn.classList.add("visible");
          } else {
            backToTopBtn.classList.remove("visible");
          }
        });

        // Add click event to scroll to top
        backToTopBtn.addEventListener("click", () => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        });
      }

      function enhanceFiltering() {
        // Add initialization for active filters display
        updateActiveFilterDisplay();

        // Update the Setup event listeners function to include the pattern search input
        const originalPatternSearchListener = elements.patternSearch.onInput;
        elements.patternSearch.addEventListener(
          "input",
          debounce(function () {
            appData.activeFilters.search = this.value.trim().toLowerCase();
            renderPatternGallery();
            updateActiveFilterDisplay();
          }, 300)
        );
      }

      // Render pattern gallery
      function renderPatternGallery() {
        const gallery = elements.patternGallery;
        gallery.innerHTML = "";

        // Track which patterns are in sets to avoid duplicates
        const patternsInRenderedSets = new Set();

        // Get current sort settings
        const sort = appData.activeSort || {
          type: "alphabetical",
          direction: "asc",
        };

        // Get all patterns
        const allPatterns = Object.values(appData.patterns);
        const filteredPatterns = filterPatterns(allPatterns);

        // Check if we have any patterns at all
        const hasAnyPatterns = Object.keys(appData.patterns).length > 0;

        // Check if any filters are active
        const hasActiveFilters =
          appData.activeFilters.tags.size > 0 ||
          appData.activeFilters.creators.size > 0 ||
          appData.activeFilters.sets.size > 0 ||
          appData.activeFilters.search;

        // Filter visible sets
        const visibleSets = Object.values(appData.sets).filter((set) => {
          // Skip empty sets
          if (!set.patterns || set.patterns.length === 0) return false;

          // For sets with a creator filter, check if any pattern in the set matches
          if (appData.activeFilters.creators.size > 0) {
            // Get the first pattern to check its creator
            const firstPatternId = set.patterns[0];
            const pattern = appData.patterns[firstPatternId];
            if (!pattern) return false;

            if (
              !appData.activeFilters.creators.has(
                pattern.creatorName.toLowerCase()
              )
            ) {
              return false;
            }
          }

          // For sets with a set filter, check if this set matches
          if (appData.activeFilters.sets.size > 0) {
            if (!appData.activeFilters.sets.has(set.name.toLowerCase())) {
              return false;
            }
          }

          // For tag filters, check if any pattern in the set has the tag
          if (appData.activeFilters.tags.size > 0) {
            // Check if any pattern in the set has all the required tags
            const hasAllTags = set.patterns.some((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return false;

              return Array.from(appData.activeFilters.tags).every((tag) =>
                pattern.tags.some(
                  (patternTag) => patternTag.toLowerCase() === tag
                )
              );
            });

            if (!hasAllTags) return false;
          }

          // For search filter, check if set name or any pattern in the set matches
          if (appData.activeFilters.search) {
            const searchTerm = appData.activeFilters.search.toLowerCase();

            // Check set name
            if (set.name.toLowerCase().includes(searchTerm)) return true;

            // Check pattern names
            const hasMatchingPattern = set.patterns.some((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return false;

              return (
                pattern.patternName.toLowerCase().includes(searchTerm) ||
                pattern.creatorName.toLowerCase().includes(searchTerm)
              );
            });

            if (!hasMatchingPattern) return false;
          }

          return true;
        });

        // Handle empty results
        if (filteredPatterns.length === 0 && visibleSets.length === 0) {
          // Different message based on whether there are any patterns or active filters
          if (!hasAnyPatterns) {
            gallery.innerHTML =
              "<p>No patterns found. Import patterns to get started.</p>";
          } else if (hasActiveFilters) {
            // We have patterns, but none match the current filters
            let message =
              "<p>No patterns match the current filter combination.</p>";

            // Build more specific message based on active filters
            let filterDetails = [];

            if (appData.activeFilters.tags.size > 0) {
              const tags = Array.from(appData.activeFilters.tags).join(", ");
              filterDetails.push(`tags: ${tags}`);
            }

            if (appData.activeFilters.creators.size > 0) {
              const creators = Array.from(appData.activeFilters.creators).join(
                ", "
              );
              filterDetails.push(`creators: ${creators}`);
            }

            if (appData.activeFilters.sets.size > 0) {
              const sets = Array.from(appData.activeFilters.sets).join(", ");
              filterDetails.push(`sets: ${sets}`);
            }

            if (appData.activeFilters.search) {
              filterDetails.push(`search: "${appData.activeFilters.search}"`);
            }

            if (filterDetails.length > 0) {
              message += `<p>Try adjusting or clearing your filters (${filterDetails.join(
                "; "
              )}).</p>`;
            }

            gallery.innerHTML = message;
          } else {
            // We have patterns, but none are being displayed for some other reason
            gallery.innerHTML = "<p>No patterns available to display.</p>";
          }
          return;
        }

        // HANDLE SORTING AND RENDERING BASED ON SORT TYPE
        if (sort.type === "alphabetical") {
          // Create a unified array of both sets and patterns
          const allItems = [];

          // Add sets as items
          visibleSets.forEach((set) => {
            allItems.push({
              isSet: true,
              set: set,
              name: set.name, // For sorting
            });

            // Track patterns in sets
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Add individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (!patternsInRenderedSets.has(pattern.id)) {
              allItems.push({
                isSet: false,
                pattern: pattern,
                name: pattern.patternName, // For sorting
              });
            }
          });

          // Sort all items alphabetically
          const sortedItems = allItems.sort((a, b) => {
            return sort.direction === "asc"
              ? a.name.toLowerCase().localeCompare(b.name.toLowerCase())
              : b.name.toLowerCase().localeCompare(a.name.toLowerCase());
          });

          // Render each item based on its type
          sortedItems.forEach((item) => {
            if (item.isSet) {
              const setCard = createSetCard(item.set);
              if (setCard) gallery.appendChild(setCard);
            } else {
              const patternCard = createPatternCard(item.pattern);
              gallery.appendChild(patternCard);
            }
          });
        } else if (sort.type === "creator") {
          // Group both sets and patterns by creator
          const creatorGroups = {};

          // First group visible sets by creator
          visibleSets.forEach((set) => {
            if (set.patterns.length === 0) return;

            // Get creator from first pattern in set
            const firstPatternId = set.patterns[0];
            const pattern = appData.patterns[firstPatternId];
            if (!pattern) return;

            const creatorName = pattern.creatorName;

            if (!creatorGroups[creatorName]) {
              creatorGroups[creatorName] = [];
            }

            // Add set as an item
            creatorGroups[creatorName].push({
              isSet: true,
              set: set,
              name: set.name, // For sorting within creator group
            });

            // Track patterns in this set
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Then group individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (patternsInRenderedSets.has(pattern.id)) return;

            const creatorName = pattern.creatorName;

            if (!creatorGroups[creatorName]) {
              creatorGroups[creatorName] = [];
            }

            creatorGroups[creatorName].push({
              isSet: false,
              pattern: pattern,
              name: pattern.patternName, // For sorting within creator group
            });
          });

          // Sort the creator names
          const sortedCreatorNames = Object.keys(creatorGroups).sort((a, b) => {
            return sort.direction === "asc"
              ? a.toLowerCase().localeCompare(b.toLowerCase())
              : b.toLowerCase().localeCompare(a.toLowerCase());
          });

          // Render each creator section
          sortedCreatorNames.forEach((creatorName) => {
            const creatorItems = creatorGroups[creatorName];

            // Create a section for this creator
            const creatorSection = document.createElement("div");
            creatorSection.className = "pattern-group-section";

            // Create creator header with count
            const creatorHeader = document.createElement("div");
            creatorHeader.className = "group-header";
            creatorHeader.innerHTML = `
              ${creatorName} <span class="group-count">${creatorItems.length}</span>
            `;
            creatorSection.appendChild(creatorHeader);

            // Create grid for this creator's patterns
            const patternsGrid = document.createElement("div");
            patternsGrid.className = "pattern-gallery";

            // Sort items within the group alphabetically
            creatorItems.sort((a, b) => {
              return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });

            // Create cards for this creator
            creatorItems.forEach((item) => {
              if (item.isSet) {
                const setCard = createSetCard(item.set);
                if (setCard) {
                  patternsGrid.appendChild(setCard);
                }
              } else {
                const card = createPatternCard(item.pattern);
                patternsGrid.appendChild(card);
              }
            });

            creatorSection.appendChild(patternsGrid);
            gallery.appendChild(creatorSection);
          });
        } else if (sort.type === "tag") {
          // Group by tag
          const tagGroups = {};

          // Process sets
          visibleSets.forEach((set) => {
            if (!set.patterns || set.patterns.length === 0) return;

            // Determine primary tag for the set
            const tagCounts = new Map();

            // Count occurrences of each tag across patterns in the set
            set.patterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern || !pattern.tags.length) return;

              pattern.tags.forEach((tag) => {
                tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
              });
            });

            // Find the most frequent tag
            let primaryTag = "Untagged";
            let maxCount = 0;

            tagCounts.forEach((count, tag) => {
              if (count > maxCount) {
                maxCount = count;
                primaryTag = tag;
              }
            });

            // Add set to the corresponding tag group
            if (!tagGroups[primaryTag]) {
              tagGroups[primaryTag] = [];
            }

            tagGroups[primaryTag].push({
              isSet: true,
              set: set,
              name: set.name, // For sorting within tag group
            });

            // Track patterns in this set
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Process individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (patternsInRenderedSets.has(pattern.id)) return;

            const tag = pattern.tags.length > 0 ? pattern.tags[0] : "Untagged";

            if (!tagGroups[tag]) {
              tagGroups[tag] = [];
            }

            tagGroups[tag].push({
              isSet: false,
              pattern: pattern,
              name: pattern.patternName, // For sorting within tag group
            });
          });

          // Sort the tag names
          const sortedTagNames = Object.keys(tagGroups).sort((a, b) => {
            return sort.direction === "asc"
              ? a.toLowerCase().localeCompare(b.toLowerCase())
              : b.toLowerCase().localeCompare(a.toLowerCase());
          });

          // Render each tag section
          sortedTagNames.forEach((tagName) => {
            const tagItems = tagGroups[tagName];

            // Create a section for this tag
            const tagSection = document.createElement("div");
            tagSection.className = "pattern-group-section";

            // Create tag header with count
            const tagHeader = document.createElement("div");
            tagHeader.className = "group-header";
            tagHeader.innerHTML = `
              ${tagName} <span class="group-count">${tagItems.length}</span>
            `;
            tagSection.appendChild(tagHeader);

            // Create grid for this tag's patterns
            const patternsGrid = document.createElement("div");
            patternsGrid.className = "pattern-gallery";

            // Sort items alphabetically within the tag group
            tagItems.sort((a, b) => {
              return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });

            // Create items for this tag
            tagItems.forEach((item) => {
              if (item.isSet) {
                const setCard = createSetCard(item.set);
                if (setCard) {
                  patternsGrid.appendChild(setCard);
                }
              } else {
                const card = createPatternCard(item.pattern);
                patternsGrid.appendChild(card);
              }
            });

            tagSection.appendChild(patternsGrid);
            gallery.appendChild(tagSection);
          });
        }
      }

      // Filter patterns based on active filters
      function filterPatterns(patterns) {
        return patterns.filter((pattern) => {
          // Search filter
          if (
            appData.activeFilters.search &&
            !pattern.patternName
              .toLowerCase()
              .includes(appData.activeFilters.search) &&
            !pattern.creatorName
              .toLowerCase()
              .includes(appData.activeFilters.search)
          ) {
            return false;
          }

          // Untagged filter - only apply if untagged filter is active
          if (appData.activeFilters.untagged) {
            return pattern.tags.length === 0;
          }

          // Tag filters - only apply if tags filter is active
          if (appData.activeFilters.tags.size > 0) {
            const hasMatchingTag = pattern.tags.some((tag) =>
              appData.activeFilters.tags.has(tag.toLowerCase())
            );
            if (!hasMatchingTag) return false;
          }

          // Creator filters - only apply if creators filter is active
          if (appData.activeFilters.creators.size > 0) {
            if (
              !appData.activeFilters.creators.has(
                pattern.creatorName.toLowerCase()
              )
            ) {
              return false;
            }
          }

          // Set filters - only apply if sets filter is active
          if (appData.activeFilters.sets.size > 0) {
            if (
              !pattern.setName ||
              !appData.activeFilters.sets.has(pattern.setName.toLowerCase())
            ) {
              return false;
            }
          }

          return true;
        });
      }

      // Add the sort by dropdown menu
      function setupSortByDropdown() {
        // Find dropdown elements that are in the HTML template
        const sortButton = document.querySelector(".sort-dropdown-button");
        const dropdownMenu = document.querySelector(".sort-dropdown-menu");

        if (!sortButton || !dropdownMenu) return;

        // Toggle dropdown on button click
        sortButton.addEventListener("click", function (e) {
          e.stopPropagation();
          dropdownMenu.classList.toggle("show");
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener("click", function () {
          dropdownMenu.classList.remove("show");
        });

        // Handle sort option selection
        dropdownMenu.querySelectorAll(".sort-option").forEach((option) => {
          option.addEventListener("click", function (e) {
            e.stopPropagation();

            const sortType = this.getAttribute("data-sort");
            let direction = this.getAttribute("data-direction");

            // Toggle direction if the same option is clicked again
            if (this.classList.contains("active")) {
              direction = direction === "asc" ? "desc" : "asc";
              this.setAttribute("data-direction", direction);
              this.querySelector(".sort-icon").textContent =
                direction === "asc" ? "↓" : "↑";
            } else {
              // Reset all options
              dropdownMenu.querySelectorAll(".sort-option").forEach((opt) => {
                opt.classList.remove("active");
              });

              // Mark current option as active
              this.classList.add("active");
            }

            // Update app state with the selected sort
            appData.activeSort = {
              type: sortType,
              direction: direction,
            };

            // Update button text to show current sort
            const sortText = this.textContent.trim();
            sortButton.innerHTML = `Sort: ${sortText} <span class="dropdown-arrow">▼</span>`;

            // Hide the dropdown
            dropdownMenu.classList.remove("show");

            // Re-render the gallery
            renderPatternGallery();
          });
        });

        // Set initial sort state if not already set
        if (!appData.activeSort) {
          appData.activeSort = {
            type: "alphabetical",
            direction: "asc",
          };
        }
      }

      // Initialize the sorting
      function initSorting() {
        appData.activeSort = {
          type: "alphabetical",
          direction: "asc",
        };

        setupSortByDropdown();
      }

      // Add to setupEventListeners function - new button for selection mode
      function setupMultiSelectUI() {
        // Create selection mode toggle button
        const actionBar = document.querySelector(".action-bar");
        const selectionBtn = document.createElement("button");
        selectionBtn.id = "selection-mode-btn";
        selectionBtn.className = "btn btn-secondary";
        selectionBtn.innerHTML = '<span class="selection-icon">☐</span> Select';

        // Insert before the Sort By button
        const sortByBtn = actionBar.querySelector("div:last-child button");
        sortByBtn.parentNode.insertBefore(selectionBtn, sortByBtn);

        // Add event listener
        selectionBtn.addEventListener("click", toggleSelectionMode);

        // Add selection action panel (hidden initially)
        const selectionPanel = document.createElement("div");
        selectionPanel.id = "selection-panel";
        selectionPanel.className = "selection-panel";
        selectionPanel.innerHTML = `
          <div class="selection-count">0 patterns selected</div>
          <div class="selection-actions">
            <button id="add-tags-btn" class="btn btn-small">Add Tags</button>
            <button id="add-to-set-btn" class="btn btn-small">Add to Set</button>
            <button id="create-set-btn" class="btn btn-small">Create Set</button>
          </div>
          <button id="clear-selection-btn" class="btn btn-small btn-secondary">Clear</button>
        `;

        // Add to document
        document.querySelector(".container").appendChild(selectionPanel);

        // Add event listeners for selection panel buttons
        document
          .getElementById("add-tags-btn")
          .addEventListener("click", () => batchAddTags());
        document
          .getElementById("add-to-set-btn")
          .addEventListener("click", () => batchAddToSet());
        document
          .getElementById("selection-panel")
          .querySelector("#create-set-btn")
          .addEventListener("click", () => batchCreateSet());
        document
          .getElementById("clear-selection-btn")
          .addEventListener("click", clearSelection);
      }

      // Toggle selection mode
      function toggleSelectionMode() {
        appData.selectionMode = !appData.selectionMode;

        // Update button appearance
        const selectionBtn = document.getElementById("selection-mode-btn");
        if (appData.selectionMode) {
          selectionBtn.classList.add("active");
          selectionBtn.innerHTML =
            '<span class="selection-icon">☑</span> Cancel';
        } else {
          selectionBtn.classList.remove("active");
          selectionBtn.innerHTML =
            '<span class="selection-icon">☐</span> Select';
          clearSelection();
        }

        // Re-render pattern gallery to show/hide checkboxes
        renderPatternGallery();
      }

      // Create a pattern card element
      function createPatternCard(pattern) {
        const card = document.createElement("div");
        card.className = "pattern-card";
        card.setAttribute("data-id", pattern.id);

        // Add selected class if pattern is selected
        if (appData.selectedPatterns.has(pattern.id)) {
          card.classList.add("selected");
        }

        // Determine thumbnail source
        let thumbnailSrc;

        if (appSettings.storeThumbnailsAsBase64) {
          // Use base64 thumbnail if available
          thumbnailSrc = pattern.thumbnailPath;
        } else {
          // Try to use original file path
          thumbnailSrc = pattern.originalFilePath;
        }

        // Default thumbnail if none available
        if (!thumbnailSrc) {
          thumbnailSrc =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+";
        }

        // Get creator info to determine if we need to add rank badges
        let creatorBadge = "";
        const creatorId = Object.keys(appData.creators).find((id) => {
          return (
            appData.creators[id].name === pattern.creatorName &&
            appData.creators[id].townName === pattern.townName
          );
        });

        if (creatorId) {
          const creator = appData.creators[creatorId];
          if (creator.rank === "verified") {
            creatorBadge =
              '<div class="verified-badge" title="Verified Creator">🌟 Verified</div>';
          } else if (creator.rank === "plagiarist") {
            creatorBadge =
              '<span class="plagiarist-badge" title="Plagiarized Pattern">⚠️ Plagiarized</span>';
          }
        }

        // Selection checkbox (only visible in selection mode)
        const selectionCheckbox = appData.selectionMode
          ? `<div class="pattern-select">
              <input type="checkbox" id="select-${pattern.id}" ${
              appData.selectedPatterns.has(pattern.id) ? "checked" : ""
            }>
              <label for="select-${pattern.id}"></label>
            </div>`
          : "";

        const html = `
          ${selectionCheckbox}
          <img class="pattern-thumbnail" src="${thumbnailSrc}" alt="${
          pattern.patternName
        }" 
              onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+'">
            ${creatorBadge}
              <div class="pattern-info">
            <div class="pattern-name">${
              pattern.patternName
            }</div>
            <div class="pattern-creator">by ${pattern.creatorName} of ${
          pattern.townName
        }</div>
            <div class="tag-list">
              ${pattern.tags
                .map((tag) => `<span class="tag">${tag}</span>`)
                .join("")}
            </div>
          </div>
        `;

        card.innerHTML = html;

        // Modified click event handling
        card.addEventListener("click", (e) => {
          // Check if clicking on checkbox
          if (e.target.type === "checkbox" || e.target.tagName === "LABEL") {
            e.stopPropagation();
            return;
          }

          // For normal clicks when not in selection mode, open pattern detail
          if (!appData.selectionMode && !e.ctrlKey && !e.metaKey) {
            openPatternDetail(pattern.id);
            return;
          }

          // For Ctrl/Cmd+click or in selection mode, toggle selection
          togglePatternSelection(pattern.id);
          e.preventDefault();
        });

        // Add specific handler for the checkbox
        const checkbox = card.querySelector(`#select-${pattern.id}`);
        if (checkbox) {
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            togglePatternSelection(pattern.id);
          });
        }

        return card;
      }

      // Toggle pattern selection
      function togglePatternSelection(patternId) {
        // Check if this is a set
        const item = document.querySelector(
          `.pattern-card[data-id="${patternId}"]`
        );
        if (item && item.getAttribute("data-type") === "set") {
          // If it's a set, don't allow selection
          showNotification(
            "Sets cannot be selected individually. Please select patterns instead.",
            "error"
          );
          return;
        }

        if (appData.selectedPatterns.has(patternId)) {
          appData.selectedPatterns.delete(patternId);
        } else {
          appData.selectedPatterns.add(patternId);
        }

        // Update UI
        updateSelectionUI();

        // If not in selection mode but patterns are selected, enter selection mode
        if (!appData.selectionMode && appData.selectedPatterns.size > 0) {
          toggleSelectionMode();
        }
      }

      // Update selection UI elements
      function updateSelectionUI() {
        // Update card styling
        document.querySelectorAll(".pattern-card").forEach((card) => {
          const patternId = card.getAttribute("data-id");
          const isSet = card.getAttribute("data-type") === "set";

          // Don't show sets as selected even if they're in the selectedPatterns set
          if (appData.selectedPatterns.has(patternId) && !isSet) {
            card.classList.add("selected");
            const checkbox = card.querySelector(`#select-${patternId}`);
            if (checkbox) checkbox.checked = true;
          } else {
            card.classList.remove("selected");
            const checkbox = card.querySelector(`#select-${patternId}`);
            if (checkbox) checkbox.checked = false;
          }
        });

        // Update selection panel
        const panel = document.getElementById("selection-panel");
        const count = appData.selectedPatterns.size;

        if (count > 0) {
          panel.classList.add("active");
          panel.querySelector(
            ".selection-count"
          ).textContent = `${count} pattern${count !== 1 ? "s" : ""} selected`;
        } else {
          panel.classList.remove("active");
        }
      }

      // Clear pattern selection
      function clearSelection() {
        appData.selectedPatterns.clear();
        updateSelectionUI();
      }

      // Add tags to multiple patterns
      function batchAddTags() {
        if (appData.selectedPatterns.size === 0) return;

        // Create modal for tag input
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Add Tags to ${appData.selectedPatterns.size} Patterns</h2>
            
            <div class="form-group">
              <label>Enter Tags</label>
              <div class="tag-input" id="batch-tag-input">
                <input type="text" placeholder="Add a tag...">
              </div>
              <p class="help-text">Enter each tag and press Enter or comma to add</p>
            </div>
            
            <div class="form-group">
              <label>
                <input type="checkbox" id="batch-tag-merge" checked>
                Merge with existing tags (uncheck to replace all tags)
              </label>
            </div>
            
            <button class="btn" id="apply-batch-tags-btn">Apply Tags</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Setup tag input
        const tagInput = modal.querySelector("#batch-tag-input");
        setupBatchTagInput(tagInput);

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Apply button
        modal
          .querySelector("#apply-batch-tags-btn")
          .addEventListener("click", () => {
            const mergeTags =
              document.getElementById("batch-tag-merge").checked;
            const tagElements = tagInput.querySelectorAll(".tag-item");

            if (tagElements.length === 0) {
              showNotification("Please add at least one tag", "error");
              return;
            }

            // Get tags from UI
            const tags = Array.from(tagElements).map((el) =>
              el.textContent.trim().replace(/\s*×\s*$/, "")
            );

            // Apply tags to all selected patterns
            appData.selectedPatterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return;

              if (mergeTags) {
                // Merge with existing tags (avoid duplicates)
                const newTags = [...new Set([...pattern.tags, ...tags])];
                pattern.tags = newTags;
              } else {
                // Replace all tags
                pattern.tags = [...tags];
              }

              // Update modification date
              pattern.lastModified = new Date().toISOString().split("T")[0];
            });

            // Save changes
            saveDataToLocalStorage();

            // Store the count before clearing
            const patternCount = appData.selectedPatterns.size;

            // Close modal
            document.body.removeChild(modal);

            // Clear selection
            clearSelection();

            // Refresh UI
            renderPatternGallery();
            renderSidebarFilters();

            showNotification(`Tags applied to ${patternCount} patterns`);
          });
      }

      // Setup tag input for batch operations
      function setupBatchTagInput(tagInput) {
        const input = tagInput.querySelector("input");

        // Add event listeners for tag input
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const tag = input.value.trim();
            if (tag) {
              addBatchTag(tag, tagInput);
              input.value = "";
            }
          } else if (e.key === "Backspace" && input.value === "") {
            // Remove the last tag when backspace is pressed in an empty input
            const tagElements = tagInput.querySelectorAll(".tag-item");
            if (tagElements.length > 0) {
              tagInput.removeChild(tagElements[tagElements.length - 1]);
            }
          }
        });

        // Focus the input field
        input.focus();
      }

      // Add tag to batch tag input
      function addBatchTag(tag, tagInput) {
        // Check if tag already exists
        const existingTags = Array.from(
          tagInput.querySelectorAll(".tag-item")
        ).map((el) =>
          el.textContent
            .trim()
            .replace(/\s*×\s*$/, "")
            .toLowerCase()
        );

        if (existingTags.includes(tag.toLowerCase())) return;

        const tagElement = document.createElement("div");
        tagElement.className = "tag-item";
        tagElement.innerHTML = `${tag} <span class="tag-remove">×</span>`;

        // Add click event to remove tag
        tagElement
          .querySelector(".tag-remove")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            tagInput.removeChild(tagElement);
          });

        tagInput.insertBefore(tagElement, tagInput.querySelector("input"));
      }

      // Add selected patterns to an existing set
      function batchAddToSet() {
        if (appData.selectedPatterns.size === 0) return;

        // Create modal for set selection
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        // Get available sets
        const sets = Object.values(appData.sets);

        modal.innerHTML = `
    <div class="modal">
      <button class="modal-close">&times;</button>
      <h2 class="modal-title">Add ${
        appData.selectedPatterns.size
      } Patterns to Set</h2>
      
      <div class="form-group">
        <label for="batch-set-select">Select Set</label>
        <select id="batch-set-select">
          <option value="">-- Select a Set --</option>
          ${sets
            .map((set) => `<option value="${set.id}">${set.name}</option>`)
            .join("")}
        </select>
      </div>
      
      ${
        sets.length === 0 ? "<p>No sets available. Create a set first.</p>" : ""
      }
      
      <button class="btn" id="apply-batch-set-btn" ${
        sets.length === 0 ? "disabled" : ""
      }>Add to Set</button>
    </div>
  `;

        document.body.appendChild(modal);

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Apply button
        const applyBtn = modal.querySelector("#apply-batch-set-btn");
        if (applyBtn && !applyBtn.disabled) {
          applyBtn.addEventListener("click", () => {
            const setId = document.getElementById("batch-set-select").value;

            if (!setId) {
              showNotification("Please select a set", "error");
              return;
            }

            const set = appData.sets[setId];
            if (!set) {
              showNotification("Selected set not found", "error");
              return;
            }

            // Get current max order in set
            let maxOrder = 0;
            set.patterns.forEach((patternId) => {
              if (
                appData.patterns[patternId] &&
                appData.patterns[patternId].setOrder > maxOrder
              ) {
                maxOrder = appData.patterns[patternId].setOrder;
              }
            });

            // Add patterns to set
            appData.selectedPatterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return;

              // Skip if already in this set
              if (pattern.setId === setId) return;

              // Remove from previous set if any
              if (pattern.setId && appData.sets[pattern.setId]) {
                appData.sets[pattern.setId].patterns = appData.sets[
                  pattern.setId
                ].patterns.filter((id) => id !== patternId);
              }

              // Add to new set
              if (!set.patterns.includes(patternId)) {
                set.patterns.push(patternId);

                // Update pattern
                pattern.setId = setId;
                pattern.setName = set.name;
                pattern.setOrder = ++maxOrder;
                pattern.lastModified = new Date().toISOString().split("T")[0];
              }
            });

            // Save changes
            saveDataToLocalStorage();

            // Close modal
            document.body.removeChild(modal);

            // Clear selection
            clearSelection();

            // Refresh UI
            renderPatternGallery();
            renderSidebarFilters();

            showNotification(`Patterns added to set "${set.name}"`);
          });
        }
      }

      // Create a new set with selected patterns
      function batchCreateSet() {
        if (appData.selectedPatterns.size === 0) return;

        // Create modal for new set
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Create New Set with ${appData.selectedPatterns.size} Patterns</h2>
            
            <div class="form-group">
              <label for="new-set-name">Set Name</label>
              <input type="text" id="new-set-name" placeholder="Enter set name">
            </div>
            
            <div class="form-group">
              <label for="new-set-grid-size">Grid Size (Optional)</label>
              <select id="new-set-grid-size">
                <option value="">No Grid (Collection of Patterns)</option>
                <option value="2x2">2 × 2 Grid</option>
                <option value="3x3">3 × 3 Grid</option>
                <option value="4x4">4 × 4 Grid</option>
                <option value="2x1">2 × 1 Grid (Vertical)</option>
                <option value="1x2">1 × 2 Grid (Horizontal)</option>
                <option value="3x1">3 × 1 Grid (Vertical)</option>
                <option value="1x3">1 × 3 Grid (Horizontal)</option>
              </select>
              <p class="help-text">Select a grid size if this set forms a larger image when combined.</p>
            </div>
            
            <div class="form-group">
              <label for="new-set-notes">Notes (Optional)</label>
              <textarea id="new-set-notes" rows="3" placeholder="Enter notes about this set"></textarea>
            </div>
            
            <div id="set-creator-warning" class="warning-message" style="display: none;">
              Warning: The selected patterns are from different creators. Sets must contain patterns from the same creator.
            </div>
            
            <button class="btn" id="create-new-set-btn">Create Set</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Validate creators
        const selectedPatternIds = Array.from(appData.selectedPatterns);
        const isSameCreator = validateSetCreator(selectedPatternIds);

        // Show warning if patterns are from different creators
        if (!isSameCreator) {
          const warningElem = modal.querySelector("#set-creator-warning");
          warningElem.style.display = "block";
          modal.querySelector("#create-new-set-btn").disabled = true;
        }

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Create button
        modal
          .querySelector("#create-new-set-btn")
          .addEventListener("click", () => {
            const setName = document
              .getElementById("new-set-name")
              .value.trim();

            if (!setName) {
              showNotification("Please enter a set name", "error");
              return;
            }

            // Check creator validation again
            if (!isSameCreator) {
              showNotification(
                "Cannot create a set with patterns from different creators",
                "error"
              );
              return;
            }

            const setNotes = document
              .getElementById("new-set-notes")
              .value.trim();
            const gridSize = document.getElementById("new-set-grid-size").value;

            // Generate ID
            const setId = "set-" + Date.now();

            // Get selected pattern IDs
            const patternIds = Array.from(appData.selectedPatterns);

            // Create set
            appData.sets[setId] = {
              id: setId,
              name: setName,
              patterns: patternIds,
              notes: setNotes,
              gridSize: gridSize || null, // Store null if no grid size selected
            };

            // Update patterns
            patternIds.forEach((patternId, index) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return;

              // Remove from previous set if any
              if (pattern.setId && appData.sets[pattern.setId]) {
                appData.sets[pattern.setId].patterns = appData.sets[
                  pattern.setId
                ].patterns.filter((id) => id !== patternId);
              }

              // Update pattern
              pattern.setId = setId;
              pattern.setName = setName;
              pattern.setOrder = index + 1;
              pattern.lastModified = new Date().toISOString().split("T")[0];
            });

            // Save data
            saveDataToLocalStorage();

            // Close modal
            document.body.removeChild(modal);

            // Clear selection
            clearSelection();

            // Refresh UI
            renderPatternGallery();
            renderSidebarFilters();

            showNotification(
              `Created new set "${setName}" with ${patternIds.length} patterns`
            );
          });
      }

      // Render sidebar filters
      function renderSidebarFilters() {
        // Render tag filters
        const allTags = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          pattern.tags.forEach((tag) => {
            const tagLower = tag.toLowerCase();
            allTags.set(tagLower, (allTags.get(tagLower) || 0) + 1);
          });
        });

        // Count untagged patterns
        const untaggedCount = Object.values(appData.patterns).filter(
          (pattern) => pattern.tags.length === 0
        ).length;

        // Create the untagged filter HTML
        const untaggedFilterHTML = `
          <li class="${
            appData.activeFilters.untagged ? "active" : ""
          }" data-filter="untagged">
            Untagged 
            <span class="filter-count">${untaggedCount}</span>
            ${
              appData.activeFilters.untagged
                ? '<span class="filter-remove">×</span>'
                : ""
            }
          </li>`;

        // Create tag filters HTML with untagged option first
        const tagFiltersHTML =
          untaggedFilterHTML +
          Array.from(allTags.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([tag, count]) => {
              const isActive = appData.activeFilters.tags.has(tag);
              return `
              <li class="${isActive ? "active" : ""}" data-tag="${tag}">
                ${tag} 
                <span class="filter-count">${count}</span>
                ${isActive ? '<span class="filter-remove">×</span>' : ""}
              </li>`;
            })
            .join("");

        elements.tagFilters.innerHTML =
          tagFiltersHTML || "<li>No tags available</li>";

        // Setup tag filter click events
        elements.tagFilters.querySelectorAll("li[data-tag]").forEach((li) => {
          li.addEventListener("click", (e) => {
            const tag = li.getAttribute("data-tag");
            if (!tag) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.tags.delete(tag);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.tags.has(tag)) {
                  appData.activeFilters.tags.delete(tag);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.tags.add(tag);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.tags.has(tag) &&
                  appData.activeFilters.tags.size === 1
                ) {
                  // If this is the only active tag, clicking it should deselect it
                  appData.activeFilters.tags.delete(tag);
                  li.classList.remove("active");
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.tags.clear();
                  elements.tagFilters.querySelectorAll("li").forEach((item) => {
                    item.classList.remove("active");
                  });

                  appData.activeFilters.tags.add(tag);
                  li.classList.add("active");
                }
              }

              // Turn off untagged filter when selecting a tag
              appData.activeFilters.untagged = false;
              elements.tagFilters
                .querySelector("li[data-filter='untagged']")
                ?.classList.remove("active");
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });

        // Setup untagged filter click event
        const untaggedFilter = elements.tagFilters.querySelector(
          "li[data-filter='untagged']"
        );
        if (untaggedFilter) {
          untaggedFilter.addEventListener("click", (e) => {
            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.untagged = false;
              untaggedFilter.classList.remove("active");
            } else {
              // Toggle the untagged filter
              appData.activeFilters.untagged = !appData.activeFilters.untagged;

              if (appData.activeFilters.untagged) {
                untaggedFilter.classList.add("active");
                // Clear tag filters when untagged is selected
                appData.activeFilters.tags.clear();
                elements.tagFilters
                  .querySelectorAll("li[data-tag]")
                  .forEach((item) => {
                    item.classList.remove("active");
                  });
              } else {
                untaggedFilter.classList.remove("active");
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        }

        // Similar implementation for creators and sets filters with the same pattern
        renderCreatorFilters();
        // renderSetFilters();

        // Update the active filter display after rendering all filters
        updateActiveFilterDisplay();
      }

      // Render creator filters
      function renderCreatorFilters() {
        const creatorCounts = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          const creatorName = pattern.creatorName.toLowerCase();
          creatorCounts.set(
            creatorName,
            (creatorCounts.get(creatorName) || 0) + 1
          );
        });

        const creatorFiltersHTML = Array.from(creatorCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([creator, count]) => {
            const isActive = appData.activeFilters.creators.has(creator);
            return `
        <li class="${isActive ? "active" : ""}" data-creator="${creator}">
          ${creator} 
          <span class="filter-count">${count}</span>
          ${isActive ? '<span class="filter-remove">×</span>' : ""}
        </li>`;
          })
          .join("");

        elements.creatorFilters.innerHTML =
          creatorFiltersHTML || "<li>No creators available</li>";

        // Setup creator filter click events
        elements.creatorFilters.querySelectorAll("li").forEach((li) => {
          li.addEventListener("click", (e) => {
            const creator = li.getAttribute("data-creator");
            if (!creator) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.creators.delete(creator);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.creators.has(creator)) {
                  appData.activeFilters.creators.delete(creator);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.creators.add(creator);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.creators.has(creator) &&
                  appData.activeFilters.creators.size === 1
                ) {
                  // If this is the only active creator, clicking it should deselect it
                  appData.activeFilters.creators.delete(creator);
                  li.classList.remove("active");
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.creators.clear();
                  elements.creatorFilters
                    .querySelectorAll("li")
                    .forEach((item) => {
                      item.classList.remove("active");
                    });

                  appData.activeFilters.creators.add(creator);
                  li.classList.add("active");
                }
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });
      }

      // Render set filters
      function renderSetFilters() {
        const setCounts = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          if (!pattern.setName) return;

          const setNameLower = pattern.setName.toLowerCase();
          setCounts.set(setNameLower, (setCounts.get(setNameLower) || 0) + 1);
        });

        const setFiltersHTML = Array.from(setCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([setName, count]) => {
            const isActive = appData.activeFilters.sets.has(setName);
            return `
        <li class="${isActive ? "active" : ""}" data-set="${setName}">
          ${setName} 
          <span class="filter-count">${count}</span>
          ${isActive ? '<span class="filter-remove">×</span>' : ""}
        </li>`;
          })
          .join("");

        elements.setFilters.innerHTML =
          setFiltersHTML || "<li>No sets available</li>";

        // Setup set filter click events
        elements.setFilters.querySelectorAll("li").forEach((li) => {
          li.addEventListener("click", (e) => {
            const setName = li.getAttribute("data-set");
            if (!setName) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.sets.delete(setName);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.sets.has(setName)) {
                  appData.activeFilters.sets.delete(setName);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.sets.add(setName);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.sets.has(setName) &&
                  appData.activeFilters.sets.size === 1
                ) {
                  // If this is the only active set, clicking it should deselect it
                  appData.activeFilters.sets.delete(setName);
                  li.classList.remove("active");
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.sets.clear();
                  elements.setFilters.querySelectorAll("li").forEach((item) => {
                    item.classList.remove("active");
                  });

                  appData.activeFilters.sets.add(setName);
                  li.classList.add("active");
                }
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });
      }

      // Add a new function to show active filters
      function updateActiveFilterDisplay() {
        // Create or get the active filters container
        let activeFiltersContainer = document.getElementById(
          "active-filters-container"
        );
        if (!activeFiltersContainer) {
          // Create the container if it doesn't exist
          activeFiltersContainer = document.createElement("div");
          activeFiltersContainer.id = "active-filters-container";
          activeFiltersContainer.className = "active-filters-container";

          // Insert it after the search bar
          const actionBar = document.querySelector(".action-bar");
          const searchBarDiv =
            actionBar.querySelector(".search-bar").parentNode;

          // Create a wrapper div to contain filters and maintain layout
          const filterWrapperDiv = document.createElement("div");
          filterWrapperDiv.className = "filter-wrapper";
          filterWrapperDiv.appendChild(activeFiltersContainer);

          // Insert in the middle of the action bar (after search, before controls)
          actionBar.insertBefore(
            filterWrapperDiv,
            actionBar.querySelector("div:last-child")
          );
        }

        // Check if we have any active filters
        const hasActiveFilters =
          appData.activeFilters.tags.size > 0 ||
          appData.activeFilters.creators.size > 0 ||
          appData.activeFilters.sets.size > 0 ||
          appData.activeFilters.untagged ||
          appData.activeFilters.search;

        // Clear the container
        activeFiltersContainer.innerHTML = "";

        // If no active filters, hide the container
        if (!hasActiveFilters) {
          activeFiltersContainer.style.display = "none";
          return;
        }

        // Show the container
        activeFiltersContainer.style.display = "flex";

        // Add title
        const title = document.createElement("div");
        title.className = "active-filters-title";
        title.textContent = "Active Filters:";
        activeFiltersContainer.appendChild(title);

        // Add filters list
        const filtersList = document.createElement("div");
        filtersList.className = "active-filters-list";

        // Add search filter if active
        if (appData.activeFilters.search) {
          const searchFilter = document.createElement("span");
          searchFilter.className = "active-filter search-filter";
          searchFilter.innerHTML = `Search: "${appData.activeFilters.search}" <span class="filter-remove" data-type="search">×</span>`;
          filtersList.appendChild(searchFilter);
        }

        // Add untagged filter if active
        if (appData.activeFilters.untagged) {
          const untaggedFilter = document.createElement("span");
          untaggedFilter.className = "active-filter tag-filter";
          untaggedFilter.innerHTML = `Untagged <span class="filter-remove" data-type="untagged">×</span>`;
          filtersList.appendChild(untaggedFilter);
        }

        // Add tag filters
        appData.activeFilters.tags.forEach((tag) => {
          const tagFilter = document.createElement("span");
          tagFilter.className = "active-filter tag-filter";
          tagFilter.innerHTML = `Tag: ${tag} <span class="filter-remove" data-type="tag" data-value="${tag}">×</span>`;
          filtersList.appendChild(tagFilter);
        });

        // Add creator filters
        appData.activeFilters.creators.forEach((creator) => {
          const creatorFilter = document.createElement("span");
          creatorFilter.className = "active-filter creator-filter";
          creatorFilter.innerHTML = `Creator: ${creator} <span class="filter-remove" data-type="creator" data-value="${creator}">×</span>`;
          filtersList.appendChild(creatorFilter);
        });

        // Add set filters
        appData.activeFilters.sets.forEach((set) => {
          const setFilter = document.createElement("span");
          setFilter.className = "active-filter set-filter";
          setFilter.innerHTML = `Set: ${set} <span class="filter-remove" data-type="set" data-value="${set}">×</span>`;
          filtersList.appendChild(setFilter);
        });

        activeFiltersContainer.appendChild(filtersList);

        // Add clear all button
        const clearAll = document.createElement("button");
        clearAll.className = "btn btn-secondary clear-all-filters";
        clearAll.textContent = "Clear All";
        activeFiltersContainer.appendChild(clearAll);

        // Add event listeners for remove buttons
        activeFiltersContainer
          .querySelectorAll(".filter-remove")
          .forEach((removeBtn) => {
            removeBtn.addEventListener("click", (e) => {
              const type = e.target.getAttribute("data-type");
              const value = e.target.getAttribute("data-value");

              if (type === "search") {
                appData.activeFilters.search = "";
                document.getElementById("pattern-search").value = "";
              } else if (type === "tag") {
                appData.activeFilters.tags.delete(value);
              } else if (type === "creator") {
                appData.activeFilters.creators.delete(value);
              } else if (type === "set") {
                appData.activeFilters.sets.delete(value);
              } else if (type === "untagged") {
                appData.activeFilters.untagged = false;
              }

              renderPatternGallery();
              renderSidebarFilters(); // This will also call updateActiveFilterDisplay again
            });
          });

        // Add event listener for clear all button
        clearAll.addEventListener("click", () => {
          appData.activeFilters.tags.clear();
          appData.activeFilters.creators.clear();
          appData.activeFilters.sets.clear();
          appData.activeFilters.search = "";
          appData.activeFilters.untagged = false;
          document.getElementById("pattern-search").value = "";

          renderPatternGallery();
          renderSidebarFilters();
        });
      }

      // Open pattern detail modal
      function openPatternDetail(patternId) {
        const pattern = appData.patterns[patternId];
        if (!pattern) return;

        // Determine thumbnail source similar to createPatternCard
        let thumbnailSrc;

        if (appSettings.storeThumbnailsAsBase64) {
          thumbnailSrc = pattern.thumbnailPath;
        } else {
          thumbnailSrc = pattern.originalFilePath;
        }

        if (!thumbnailSrc) {
          thumbnailSrc =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+";
        }

        // Set pattern details in modal (using the determined thumbnail source)
        document.getElementById("modal-pattern-img").src = thumbnailSrc;
        document.getElementById("modal-pattern-img").onerror = function () {
          this.src =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+";
        };
        document
          .getElementById("modal-pattern-img")
          .classList.add("pixel-art-image");

        document.getElementById("pattern-name").value = pattern.patternName;
        document.getElementById("creator-name").value = pattern.creatorName;
        document.getElementById("town-name").value = pattern.townName;
        document.getElementById("pattern-notes").value = pattern.notes || "";

        // Set up tag input
        const tagInput = document.getElementById("tag-input");
        // Clear existing tags except the input
        Array.from(tagInput.children).forEach((child) => {
          if (child.tagName !== "INPUT") {
            tagInput.removeChild(child);
          }
        });

        // Add current tags
        pattern.tags.forEach((tag) => {
          const tagElement = document.createElement("div");
          tagElement.className = "tag-item";
          tagElement.innerHTML = `${tag} <span class="tag-remove">×</span>`;

          // Add click event to remove tag
          tagElement
            .querySelector(".tag-remove")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              tagInput.removeChild(tagElement);
            });

          tagInput.insertBefore(tagElement, tagInput.querySelector("input"));
        });

        // Set up enhanced tag input functionality
        setupTagInput();

        // Set up set selection
        const setSelect = document.getElementById("pattern-set");

        // Clear options except the "None" option
        while (setSelect.options.length > 1) {
          setSelect.remove(1);
        }

        // Add set options
        Object.values(appData.sets).forEach((set) => {
          const option = document.createElement("option");
          option.value = set.id;
          option.textContent = set.name;
          option.selected = pattern.setId === set.id;
          setSelect.appendChild(option);
        });

        // Set order
        document.getElementById("set-order").value = pattern.setOrder || 1;

        // Set data-id attribute for saving
        elements.savePatternBtn.setAttribute("data-id", patternId);

        // Show modal
        elements.patternModal.style.display = "flex";
      }

      // Enhanced tag input handling
      function setupTagInput() {
        const tagInput = document.getElementById("tag-input");
        const input = tagInput.querySelector("input");

        // Clear existing event listeners
        const newInput = input.cloneNode(true);
        input.parentNode.replaceChild(newInput, input);

        // Add event listeners for tag input
        newInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const tag = newInput.value.trim();
            if (tag) {
              addTag(tag);
              newInput.value = "";
            }
          } else if (e.key === "Backspace" && newInput.value === "") {
            // Remove the last tag when backspace is pressed in an empty input
            const tagElements = tagInput.querySelectorAll(".tag-item");
            if (tagElements.length > 0) {
              tagInput.removeChild(tagElements[tagElements.length - 1]);
            }
          }
        });

        // Add autocomplete for tags
        newInput.addEventListener("input", (e) => {
          const value = newInput.value.trim().toLowerCase();
          if (value.length < 2) return;

          // Get all existing tags from all patterns
          const allTags = new Set();
          Object.values(appData.patterns).forEach((pattern) => {
            pattern.tags.forEach((tag) => allTags.add(tag.toLowerCase()));
          });

          // Filter tags that match the input
          const matches = Array.from(allTags)
            .filter((tag) => tag.includes(value) && !tagExists(tag))
            .slice(0, 5); // Limit to 5 suggestions

          // Show autocomplete suggestions
          showTagSuggestions(matches);
        });

        // Focus the input field
        newInput.focus();

        // Function to add a new tag
        function addTag(tag) {
          // Check if tag already exists
          if (tagExists(tag)) return;

          const tagElement = document.createElement("div");
          tagElement.className = "tag-item";
          tagElement.innerHTML = `${tag} <span class="tag-remove">×</span>`;

          // Add click event to remove tag
          tagElement
            .querySelector(".tag-remove")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              tagInput.removeChild(tagElement);
            });

          tagInput.insertBefore(tagElement, newInput);
        }

        // Check if tag already exists in the input
        function tagExists(tag) {
          const tagElements = tagInput.querySelectorAll(".tag-item");
          const normalizedTag = tag.toLowerCase();

          return Array.from(tagElements).some((el) => {
            const existingTag = el.textContent
              .trim()
              .replace(/\s*×\s*$/, "")
              .toLowerCase();
            return existingTag === normalizedTag;
          });
        }

        // Show tag suggestions
        function showTagSuggestions(suggestions) {
          // Remove existing suggestions
          const existingSuggestions =
            document.getElementById("tag-suggestions");
          if (existingSuggestions) {
            existingSuggestions.remove();
          }

          if (suggestions.length === 0) return;

          // Create suggestions container
          const suggestionsContainer = document.createElement("div");
          suggestionsContainer.id = "tag-suggestions";
          suggestionsContainer.style.position = "absolute";
          suggestionsContainer.style.zIndex = "1000";
          suggestionsContainer.style.backgroundColor = "white";
          suggestionsContainer.style.border = "1px solid var(--border-color)";
          suggestionsContainer.style.borderRadius = "4px";
          suggestionsContainer.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
          suggestionsContainer.style.width = `${tagInput.offsetWidth}px`;
          suggestionsContainer.style.maxHeight = "150px";
          suggestionsContainer.style.overflowY = "auto";

          // Position below the tag input
          const rect = tagInput.getBoundingClientRect();
          suggestionsContainer.style.top = `${rect.bottom + window.scrollY}px`;
          suggestionsContainer.style.left = `${rect.left + window.scrollX}px`;

          // Add suggestions
          suggestions.forEach((suggestion) => {
            const suggestionElement = document.createElement("div");
            suggestionElement.textContent = suggestion;
            suggestionElement.style.padding = "8px 12px";
            suggestionElement.style.cursor = "pointer";
            suggestionElement.style.borderBottom =
              "1px solid var(--border-color)";

            suggestionElement.addEventListener("mouseover", () => {
              suggestionElement.style.backgroundColor =
                "var(--secondary-color)";
            });

            suggestionElement.addEventListener("mouseout", () => {
              suggestionElement.style.backgroundColor = "white";
            });

            suggestionElement.addEventListener("click", () => {
              addTag(suggestion);
              newInput.value = "";
              suggestionsContainer.remove();
              newInput.focus();
            });

            suggestionsContainer.appendChild(suggestionElement);
          });

          // Add click outside to close suggestions
          document.addEventListener("click", function closeHandler(e) {
            if (
              !suggestionsContainer.contains(e.target) &&
              e.target !== newInput
            ) {
              suggestionsContainer.remove();
              document.removeEventListener("click", closeHandler);
            }
          });

          // Add to document
          document.body.appendChild(suggestionsContainer);
        }
      }

      // Save pattern changes
      function savePatternChanges() {
        const patternId = elements.savePatternBtn.getAttribute("data-id");
        if (!patternId || !appData.patterns[patternId]) return;

        const pattern = appData.patterns[patternId];

        // Get current tags from tag elements
        const tagElements = document.querySelectorAll("#tag-input .tag-item");
        const tags = Array.from(tagElements).map((el) => {
          // Extract tag text without the "×" remove button
          return el.textContent.trim().replace(/\s*×\s*$/, "");
        });

        // Get set selection
        const setSelect = document.getElementById("pattern-set");
        const setId = setSelect.value;

        // Get previous setId to handle set removal
        const previousSetId = pattern.setId;

        // Get set name from selected option
        const setName = setId
          ? setSelect.options[setSelect.selectedIndex].text
          : "";

        // Get set order
        const setOrder =
          parseInt(document.getElementById("set-order").value) || 1;

        // Get notes
        const notes = document.getElementById("pattern-notes").value.trim();

        // Update pattern
        pattern.tags = tags;
        pattern.setId = setId;
        pattern.setName = setName;
        pattern.setOrder = setOrder;
        pattern.notes = notes;
        pattern.lastModified = new Date().toISOString().split("T")[0];

        // Handle set changes

        // If the pattern was removed from a set
        if (previousSetId && previousSetId !== setId) {
          // Remove pattern from previous set
          if (appData.sets[previousSetId]) {
            appData.sets[previousSetId].patterns = appData.sets[
              previousSetId
            ].patterns.filter((id) => id !== patternId);
          }
        }

        // If the pattern was added to a set or stayed in the same set
        if (setId) {
          const set = appData.sets[setId];
          if (set) {
            // Add pattern to set if not already there
            if (!set.patterns.includes(patternId)) {
              set.patterns.push(patternId);
            }

            // Re-sort the set patterns by their setOrder
            const patternsInSet = set.patterns
              .map((id) => appData.patterns[id])
              .filter((p) => p) // Filter out any null patterns
              .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

            // Update the setOrder values to be sequential
            patternsInSet.forEach((p, index) => {
              p.setOrder = index + 1;
            });

            // Update set patterns order
            set.patterns = patternsInSet.map((p) => p.id);
          }
        }

        // Save data
        saveDataToLocalStorage();

        // Close modal
        elements.patternModal.style.display = "none";

        // Refresh views
        renderPatternGallery();
        renderSidebarFilters();

        // If we're on the Sets tab, refresh the sets view
        const activeTab = document.querySelector(".nav-tabs li.active");
        if (activeTab && activeTab.getAttribute("data-tab") === "sets") {
          renderSets();
        }

        showNotification("Pattern updated successfully");
      }

      // Create new set
      function createNewSet() {
        const setName = document.getElementById("set-name").value.trim();
        if (!setName) {
          showNotification("Please enter a set name", "error");
          return;
        }

        const setNotes = document.getElementById("set-notes").value.trim();

        // Get grid size selection
        const gridSizeSelect = document.getElementById("set-grid-size");
        const gridSize = gridSizeSelect.value; // Will be empty string for collection sets

        // Generate ID
        const setId = "set-" + Date.now();

        // Create set
        appData.sets[setId] = {
          id: setId,
          name: setName,
          patterns: [],
          notes: setNotes,
          gridSize: gridSize || null, // Store null if no grid size selected
        };

        // Save data
        saveDataToLocalStorage();

        // Close modal and clear inputs
        document.getElementById("set-name").value = "";
        document.getElementById("set-notes").value = "";
        document.getElementById("set-grid-size").value = "";
        elements.setModal.style.display = "none";

        // Refresh views
        renderSets();
        renderSidebarFilters();

        showNotification("Set created successfully");
      }

      // Render sets view
      function renderSets() {
        const setManager = elements.setManager;
        setManager.innerHTML = "";

        const sets = Object.values(appData.sets);

        if (sets.length === 0) {
          setManager.innerHTML =
            "<p>No sets available. Create a new set to get started.</p>";
          return;
        }

        sets.forEach((set) => {
          const setItem = document.createElement("div");
          setItem.className = "set-item";

          // Get patterns in this set
          const setPatterns = set.patterns
            .map((id) => appData.patterns[id])
            .filter((pattern) => pattern) // Filter out any null/undefined patterns
            .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

          const html = `
                    <div class="set-header">
                        <h3>${set.name}</h3>
                        <p>${set.notes || ""}</p>
                    </div>
                    <div class="set-patterns">
                        ${setPatterns
                          .map(
                            (pattern, index) => `
                            <img class="set-pattern" src="${
                              pattern.thumbnailPath ||
                              "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
                            }" 
                                alt="${pattern.patternName}" 
                                title="${pattern.patternName}" 
                                data-id="${pattern.id}" 
                                data-order="${index + 1}">
                        `
                          )
                          .join("")}
                    </div>
                    <div class="set-actions">
                        <button class="btn btn-secondary" data-action="edit" data-id="${
                          set.id
                        }">Edit</button>
                        <button class="btn btn-secondary" data-action="delete" data-id="${
                          set.id
                        }">Delete</button>
                    </div>
                `;

          setItem.innerHTML = html;

          // Add drag and drop for ordering
          setupDragAndDrop(setItem.querySelector(".set-patterns"));

          // Add event listeners for buttons
          setItem
            .querySelector('[data-action="edit"]')
            .addEventListener("click", () => {
              editSet(set.id);
            });

          setItem
            .querySelector('[data-action="delete"]')
            .addEventListener("click", () => {
              deleteSet(set.id);
            });

          setManager.appendChild(setItem);
        });
      }

      // Setup drag and drop for pattern ordering
      function setupDragAndDrop(container) {
        if (!container) return;

        const patterns = container.querySelectorAll(".set-pattern");
        patterns.forEach((pattern) => {
          pattern.setAttribute("draggable", "true");

          pattern.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData(
              "text/plain",
              pattern.getAttribute("data-id")
            );
            e.dataTransfer.effectAllowed = "move";
            pattern.classList.add("dragging");
          });

          pattern.addEventListener("dragend", () => {
            pattern.classList.remove("dragging");
          });

          pattern.addEventListener("click", () => {
            const patternId = pattern.getAttribute("data-id");
            openPatternDetail(patternId);
          });
        });

        container.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";

          const dragging = container.querySelector(".dragging");
          if (!dragging) return;

          const afterElement = getDragAfterElement(container, e.clientX);
          if (afterElement) {
            container.insertBefore(dragging, afterElement);
          } else {
            container.appendChild(dragging);
          }
        });

        container.addEventListener("drop", (e) => {
          e.preventDefault();
          const patternId = e.dataTransfer.getData("text/plain");
          const setId = container
            .closest(".set-item")
            .querySelector('[data-action="edit"]')
            .getAttribute("data-id");

          // Update pattern orders
          const patterns = container.querySelectorAll(".set-pattern");
          patterns.forEach((pattern, index) => {
            const id = pattern.getAttribute("data-id");
            if (appData.patterns[id]) {
              appData.patterns[id].setOrder = index + 1;
            }
          });

          saveDataToLocalStorage();
        });
      }

      // Helper function for drag and drop
      function getDragAfterElement(container, x) {
        const draggableElements = [
          ...container.querySelectorAll(".set-pattern:not(.dragging)"),
        ];

        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = x - box.left - box.width / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      // Edit set
      function editSet(setId) {
        const set = appData.sets[setId];
        if (!set) return;

        // Clone the create set modal for editing
        const editModal = elements.setModal.cloneNode(true);
        document.body.appendChild(editModal);

        // Update modal title and button text
        editModal.querySelector(".modal-title").textContent = "Edit Set";
        editModal.querySelector("#save-set-btn").textContent = "Save Changes";

        // Create a new ID for the edit modal to avoid conflicts
        editModal.id = "edit-set-modal";

        // Set values
        editModal.querySelector("#set-name").value = set.name;
        editModal.querySelector("#set-notes").value = set.notes || "";

        // Find or create grid size select
        let gridSizeSelect = editModal.querySelector("#set-grid-size");
        if (!gridSizeSelect) {
          // If the set modal hasn't been updated yet, add the grid size field
          const notesFormGroup = editModal
            .querySelector('label[for="set-notes"]')
            .closest(".form-group");

          const gridSizeFormGroup = document.createElement("div");
          gridSizeFormGroup.className = "form-group";
          gridSizeFormGroup.innerHTML = `
            <label for="set-grid-size">Grid Size (Optional)</label>
            <select id="set-grid-size">
              <option value="">No Grid (Collection of Patterns)</option>
              <option value="2x2">2 × 2 Grid</option>
              <option value="3x3">3 × 3 Grid</option>
              <option value="4x4">4 × 4 Grid</option>
              <option value="2x1">2 × 1 Grid (Vertical)</option>
              <option value="1x2">1 × 2 Grid (Horizontal)</option>
              <option value="3x1">3 × 1 Grid (Vertical)</option>
              <option value="1x3">1 × 3 Grid (Horizontal)</option>
            </select>
            <p class="help-text">Select a grid size if this set forms a larger image when combined, or leave as "No Grid" if it's just a collection.</p>
          `;

          notesFormGroup.after(gridSizeFormGroup);
          gridSizeSelect = editModal.querySelector("#set-grid-size");
        }

        // Set grid size value
        if (set.gridSize) {
          gridSizeSelect.value = set.gridSize;
        } else {
          gridSizeSelect.value = "";
        }

        // Add pattern management section
        const formGroup = document.createElement("div");
        formGroup.className = "form-group";
        formGroup.innerHTML = `
    <label>Patterns</label>
    <div class="set-patterns-container">
      <div class="set-patterns" id="edit-set-patterns"></div>
    </div>
    <p class="help-text">Drag to reorder. Click to remove.</p>
  `;

        // Insert before save button
        const saveBtn = editModal.querySelector("#save-set-btn");
        saveBtn.parentNode.insertBefore(formGroup, saveBtn);

        // Get patterns in this set
        const setPatterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern) // Filter out any null/undefined patterns
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        // Populate patterns
        const patternsContainer = editModal.querySelector("#edit-set-patterns");

        setPatterns.forEach((pattern) => {
          const patternElement = document.createElement("div");
          patternElement.className = "set-pattern-item";
          patternElement.setAttribute("data-id", pattern.id);
          patternElement.setAttribute("draggable", "true");

          patternElement.innerHTML = `
            <img src="${
              pattern.thumbnailPath ||
              "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
            }" 
                class="set-pattern pixel-art-image" 
                title="${pattern.patternName}">
            <div class="pattern-order">${pattern.setOrder || 0}</div>
            <div class="pattern-name">${pattern.patternName}</div>
            <button class="remove-pattern" title="Remove from set">×</button>
        `;

          patternsContainer.appendChild(patternElement);
        });

        // Add button to add more patterns
        const addPatternsBtn = document.createElement("button");
        addPatternsBtn.className = "btn btn-secondary";
        addPatternsBtn.textContent = "Add Patterns";
        addPatternsBtn.style.marginTop = "10px";
        formGroup.appendChild(addPatternsBtn);

        // Setup drag and drop for pattern ordering
        setupSetDragAndDrop(patternsContainer);

        // Remove pattern event listeners
        patternsContainer.querySelectorAll(".remove-pattern").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const patternItem = btn.closest(".set-pattern-item");
            const patternId = patternItem.getAttribute("data-id");

            if (confirm("Remove this pattern from the set?")) {
              patternItem.remove();
              updatePatternOrders(patternsContainer);
            }
          });
        });

        // Add patterns button click
        addPatternsBtn.addEventListener("click", () => {
          showAddPatternsModal(setId, patternsContainer);
        });

        // Save changes
        const saveEditBtn = editModal.querySelector("#save-set-btn");
        saveEditBtn.addEventListener("click", () => {
          // Update set data
          set.name = editModal.querySelector("#set-name").value.trim();
          set.notes = editModal.querySelector("#set-notes").value.trim();

          // Update grid size
          const gridSizeSelect = editModal.querySelector("#set-grid-size");
          set.gridSize = gridSizeSelect.value || null;

          // Get pattern order from UI
          const patternItems =
            patternsContainer.querySelectorAll(".set-pattern-item");
          const patternIds = Array.from(patternItems).map((item) =>
            item.getAttribute("data-id")
          );

          // Validate that all patterns are from the same creator
          if (!validateSetCreator(patternIds)) {
            showNotification(
              "Cannot save set with patterns from different creators",
              "error"
            );
            return;
          }

          // Update set patterns
          set.patterns = patternIds;

          // Update pattern setOrder values
          patternIds.forEach((id, index) => {
            if (appData.patterns[id]) {
              appData.patterns[id].setOrder = index + 1;
            }
          });

          // Check for removed patterns and update them
          const removedPatternIds = set.patterns.filter(
            (id) => !patternIds.includes(id)
          );
          removedPatternIds.forEach((id) => {
            if (appData.patterns[id]) {
              appData.patterns[id].setId = "";
              appData.patterns[id].setName = "";
              appData.patterns[id].setOrder = 0;
            }
          });

          // Save data
          saveDataToLocalStorage();

          // Remove modal
          document.body.removeChild(editModal);

          // Refresh views
          renderSets();
          renderSidebarFilters();
          renderPatternGallery();

          showNotification("Set updated successfully");
        });

        // Close button
        const closeBtn = editModal.querySelector(".modal-close");
        closeBtn.addEventListener("click", () => {
          document.body.removeChild(editModal);
        });

        // Show the modal
        editModal.style.display = "flex";
      }

      // Setup drag and drop for set editing
      function setupSetDragAndDrop(container) {
        if (!container) return;

        const patternItems = container.querySelectorAll(".set-pattern-item");

        patternItems.forEach((item) => {
          item.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("text/plain", item.getAttribute("data-id"));
            item.classList.add("dragging");
          });

          item.addEventListener("dragend", () => {
            item.classList.remove("dragging");
            updatePatternOrders(container);
          });

          // Prevent opening pattern detail when clicking on a pattern in edit mode
          item.addEventListener("click", (e) => {
            e.stopPropagation();
          });
        });

        container.addEventListener("dragover", (e) => {
          e.preventDefault();
          const draggingItem = container.querySelector(".dragging");
          if (!draggingItem) return;

          const afterElement = getDragAfterElement(container, e.clientY);
          if (afterElement) {
            container.insertBefore(draggingItem, afterElement);
          } else {
            container.appendChild(draggingItem);
          }
        });

        container.addEventListener("drop", (e) => {
          e.preventDefault();
        });
      }

      // Get element to insert after when dragging
      function getDragAfterElement(container, y) {
        const draggableElements = [
          ...container.querySelectorAll(".set-pattern-item:not(.dragging)"),
        ];

        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      // Update pattern order numbers after drag or remove
      function updatePatternOrders(container) {
        const patternItems = container.querySelectorAll(".set-pattern-item");

        patternItems.forEach((item, index) => {
          const orderElement = item.querySelector(".pattern-order");
          if (orderElement) {
            orderElement.textContent = index + 1;
          }
        });
      }

      // Show modal to add patterns to a set
      function showAddPatternsModal(setId, patternsContainer) {
        const set = appData.sets[setId];
        if (!set) return;

        // Get creator info from existing patterns in the set
        let creatorName = null;
        let creatorTown = null;

        if (set.patterns.length > 0) {
          const firstPattern = appData.patterns[set.patterns[0]];
          if (firstPattern) {
            creatorName = firstPattern.creatorName;
            creatorTown = firstPattern.townName;
          }
        }

        // Create modal for pattern selection
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Add Patterns to "${set.name}"</h2>
            ${
              creatorName
                ? `<div class="creator-filter-info">Only showing patterns by ${creatorName} of ${creatorTown}</div>`
                : ""
            }
            <div class="form-group">
              <input type="text" id="pattern-search-input" placeholder="Search patterns...">
            </div>
            <div class="pattern-selection">
              <!-- Patterns will be loaded here -->
            </div>
            <button class="btn" id="add-selected-patterns">Add Selected Patterns</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
          document.body.removeChild(creatorInfoStyle);
          document.body.removeChild(style);
        });

        // Get all patterns
        let patterns = Object.values(appData.patterns);

        // Filter by creator if set already has patterns
        if (creatorName) {
          patterns = patterns.filter(
            (pattern) =>
              pattern.creatorName.toLowerCase() === creatorName.toLowerCase()
          );
        }

        // Already included pattern IDs
        const existingPatternIds = set.patterns;

        // Render patterns
        const patternSelection = modal.querySelector(".pattern-selection");
        renderSelectablePatterns(
          patterns,
          patternSelection,
          existingPatternIds
        );

        // Search input
        const searchInput = modal.querySelector("#pattern-search-input");
        searchInput.addEventListener(
          "input",
          debounce(() => {
            const searchTerm = searchInput.value.trim().toLowerCase();

            let filteredPatterns = patterns;
            if (searchTerm) {
              filteredPatterns = patterns.filter(
                (pattern) =>
                  pattern.patternName.toLowerCase().includes(searchTerm) ||
                  pattern.creatorName.toLowerCase().includes(searchTerm)
              );
            }

            renderSelectablePatterns(
              filteredPatterns,
              patternSelection,
              existingPatternIds
            );
          }, 300)
        );

        // Add selected patterns button
        const addSelectedBtn = modal.querySelector("#add-selected-patterns");
        addSelectedBtn.addEventListener("click", () => {
          const selectedItems = patternSelection.querySelectorAll(
            ".pattern-select-item.selected"
          );

          if (selectedItems.length === 0) {
            alert("Please select at least one pattern to add.");
            return;
          }

          // Get current patterns in the set
          const currentItems =
            patternsContainer.querySelectorAll(".set-pattern-item");
          const nextOrder = currentItems.length + 1;

          // Add each selected pattern to the set
          selectedItems.forEach((item, index) => {
            const patternId = item.getAttribute("data-id");
            const pattern = appData.patterns[patternId];

            // Skip if already in the container
            if (
              patternsContainer.querySelector(
                `.set-pattern-item[data-id="${patternId}"]`
              )
            ) {
              return;
            }

            // Create pattern element
            const patternElement = document.createElement("div");
            patternElement.className = "set-pattern-item";
            patternElement.setAttribute("data-id", patternId);
            patternElement.setAttribute("draggable", "true");

            patternElement.innerHTML = `
              <img src="${
                pattern.thumbnailPath ||
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
              }" 
                  class="set-pattern pixel-art-image" 
                  title="${pattern.patternName}">
              <div class="pattern-order">${nextOrder + index}</div>
              <div class="pattern-name">${pattern.patternName}</div>
              <button class="remove-pattern" title="Remove from set">×</button>
            `;

            patternsContainer.appendChild(patternElement);

            // Add event listener for remove button
            patternElement
              .querySelector(".remove-pattern")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                if (confirm("Remove this pattern from the set?")) {
                  patternElement.remove();
                  updatePatternOrders(patternsContainer);
                }
              });
          });

          // Update drag and drop
          setupSetDragAndDrop(patternsContainer);

          // Update pattern orders
          updatePatternOrders(patternsContainer);

          // Close the modal
          document.body.removeChild(modal);
          document.body.removeChild(creatorInfoStyle);
          document.body.removeChild(style);

          showNotification(`Added ${selectedItems.length} patterns to the set`);
        });
      }

      // Render patterns for selection
      function renderSelectablePatterns(
        patterns,
        container,
        existingPatternIds
      ) {
        container.innerHTML = "";

        if (patterns.length === 0) {
          container.innerHTML = "<p>No patterns found.</p>";
          return;
        }

        patterns.forEach((pattern) => {
          const isInSet = existingPatternIds.includes(pattern.id);

          const item = document.createElement("div");
          item.className = `pattern-select-item ${isInSet ? "in-set" : ""}`;
          item.setAttribute("data-id", pattern.id);

          item.innerHTML = `
            <img src="${
              pattern.thumbnailPath ||
              "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
            }" 
                class="pixel-art-image">
            <div class="pattern-name">${pattern.patternName}</div>
            <div class="pattern-creator">${pattern.creatorName}</div>
            ${isInSet ? '<div class="pattern-in-set">In Set</div>' : ""}
        `;

          // Click to select/deselect
          item.addEventListener("click", () => {
            if (isInSet) return; // Can't select patterns already in set

            item.classList.toggle("selected");
          });

          container.appendChild(item);
        });
      }

      // Delete set
      function deleteSet(setId) {
        if (
          !confirm(
            `Are you sure you want to delete this set? This will not delete the patterns in the set.`
          )
        ) {
          return;
        }

        // Remove set from patterns
        const set = appData.sets[setId];
        if (set) {
          set.patterns.forEach((patternId) => {
            if (appData.patterns[patternId]) {
              appData.patterns[patternId].setName = "";
              appData.patterns[patternId].setId = "";
            }
          });

          // Delete set
          delete appData.sets[setId];

          // Save data
          saveDataToLocalStorage();

          // Refresh views
          renderSets();
          renderSidebarFilters();

          showNotification("Set deleted successfully");
        }
      }

      // Function to validate that all patterns in a set are from the same creator
      function validateSetCreator(patternIds) {
        if (!patternIds || patternIds.length === 0) return true;

        const creatorNames = new Set();

        patternIds.forEach((id) => {
          const pattern = appData.patterns[id];
          if (pattern) {
            creatorNames.add(pattern.creatorName.toLowerCase());
          }
        });

        // Return true if all patterns have the same creator (only one entry in the Set)
        return creatorNames.size === 1;
      }

      // Function to get creator info for a set
      function getSetCreatorInfo(patternIds) {
        if (!patternIds || patternIds.length === 0)
          return { name: "Unknown", town: "Unknown" };

        const pattern = appData.patterns[patternIds[0]];
        if (!pattern) return { name: "Unknown", town: "Unknown" };

        return {
          name: pattern.creatorName,
          town: pattern.townName,
        };
      }

      // Function to render a set card (for pattern gallery view)
      function createSetCard(set) {
        const card = document.createElement("div");
        card.className = "pattern-card set-card";
        card.setAttribute("data-id", set.id);
        card.setAttribute("data-type", "set");

        // Get patterns in this set
        const patterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern)
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        if (patterns.length === 0) return null;

        // Get creator info
        const creatorInfo = getSetCreatorInfo(set.patterns);

        let thumbnailsHTML = "";

        // Check if this is a grid set or a collection set
        if (set.gridSize) {
          const [rows, cols] = set.gridSize
            .split("x")
            .map((num) => parseInt(num, 10));

          // Apply different styles based on grid orientation
          let gridClass = "";
          if (cols > rows) {
            gridClass = "horizontal-grid";
          } else if (rows > cols) {
            gridClass = "vertical-grid";
          } else {
            gridClass = "square-grid";
          }

          // Create grid preview with proper sizing and class
          thumbnailsHTML = `<div class="set-grid-preview ${gridClass}" 
                        style="--rows: ${rows}; --cols: ${cols}; 
                        grid-template-rows: repeat(${rows}, 1fr); 
                        grid-template-columns: repeat(${cols}, 1fr);">`;

          // Add patterns in order
          for (let i = 0; i < Math.min(rows * cols, patterns.length); i++) {
            const pattern = patterns[i];
            thumbnailsHTML += `
              <div class="set-grid-item">
                <img src="${
                  pattern.thumbnailPath ||
                  "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
                }" 
                  alt="${pattern.patternName}" class="pixel-art-image">
              </div>
            `;
          }

          // Fill in empty spaces if the grid isn't complete
          for (let i = patterns.length; i < rows * cols; i++) {
            thumbnailsHTML += `
              <div class="set-grid-item empty">
                <div class="empty-grid-item"></div>
              </div>
            `;
          }

          thumbnailsHTML += "</div>";
        } else {
          // Collection set preview (up to 4 thumbnails with "..." if more)
          thumbnailsHTML = '<div class="set-collection-preview">';

          // Show up to 3 thumbnails
          for (let i = 0; i < Math.min(3, patterns.length); i++) {
            const pattern = patterns[i];
            thumbnailsHTML += `
              <div class="set-collection-item">
                <img src="${
                  pattern.thumbnailPath ||
                  "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
                }" 
                  alt="${pattern.patternName}" class="pixel-art-image">
              </div>
            `;
          }

          // If there are more than 3 patterns, add the "..." item
          if (patterns.length > 3) {
            thumbnailsHTML += `
              <div class="set-collection-item more">
                <div class="more-patterns">+${patterns.length - 3} more</div>
              </div>
            `;
          }

          thumbnailsHTML += "</div>";
        }

        const html = `
          <div class="set-thumbnail">
            ${thumbnailsHTML}
          </div>
          <div class="pattern-info">
            <div class="pattern-name">${
              set.name
            } <span class="set-badge">Set</span></div>
            <div class="pattern-creator">by ${creatorInfo.name} of ${
          creatorInfo.town
        }</div>
            <div class="set-count">${patterns.length} pattern${
          patterns.length !== 1 ? "s" : ""
        }</div>
            ${
              set.gridSize
                ? `<div class="set-grid-size">${set.gridSize} grid</div>`
                : ""
            }
          </div>
        `;

        card.innerHTML = html;

        // Handle click event
        card.addEventListener("click", (e) => {
          // Check if clicking on checkbox
          if (e.target.type === "checkbox" || e.target.tagName === "LABEL") {
            e.stopPropagation();
            e.preventDefault(); // Prevent checkbox from being checked
            return;
          }

          // For normal clicks when not in selection mode, open set detail
          if (!appData.selectionMode && !e.ctrlKey && !e.metaKey) {
            openSetDetailModal(set.id);
            return;
          }

          // If in selection mode, show a notification that sets cannot be selected
          if (appData.selectionMode || e.ctrlKey || e.metaKey) {
            showNotification(
              "Sets cannot be selected individually. Please select patterns instead.",
              "error"
            );
            e.preventDefault();
          }
        });

        // Add specific handler for the checkbox
        const checkbox = card.querySelector(`#select-${set.id}`);
        if (checkbox) {
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            e.preventDefault(); // Prevent checkbox from being checked
            checkbox.checked = false; // Uncheck the checkbox
            showNotification(
              "Sets cannot be selected individually. Please select patterns instead.",
              "error"
            );
          });
        }

        return card;
      }

      // Function to open set detail modal
      function openSetDetailModal(setId) {
        const set = appData.sets[setId];
        if (!set) return;

        // Get patterns in this set
        const patterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern)
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        if (patterns.length === 0) return;

        // Create modal
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.id = "set-detail-modal";
        modal.style.display = "flex";

        // Get creator info
        const creatorInfo = getSetCreatorInfo(set.patterns);

        // Create grid layout or collection layout based on set type
        let patternsHTML = "";

        if (set.gridSize) {
          const [rows, cols] = set.gridSize
            .split("x")
            .map((num) => parseInt(num, 10));

          patternsHTML = `
            <div class="set-grid-layout" style="grid-template-rows: repeat(${rows}, 1fr); grid-template-columns: repeat(${cols}, 1fr);">
          `;

          // Position patterns in the grid
          for (let i = 0; i < Math.min(rows * cols, patterns.length); i++) {
            const pattern = patterns[i];
            patternsHTML += `
              <div class="set-detail-pattern" data-id="${pattern.id}">
                <img src="${
                  pattern.thumbnailPath ||
                  "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
                }" 
                  alt="${pattern.patternName}" class="pixel-art-image">
                <div class="pattern-name">${pattern.patternName}</div>
              </div>
            `;
          }

          // Fill in empty spaces if the grid isn't complete
          for (let i = patterns.length; i < rows * cols; i++) {
            patternsHTML += `
              <div class="set-detail-pattern empty">
                <div class="empty-grid-item"></div>
                <div class="pattern-name">Empty</div>
              </div>
            `;
          }

          patternsHTML += "</div>";
        } else {
          // Collection view
          patternsHTML = '<div class="set-collection-layout">';

          patterns.forEach((pattern) => {
            patternsHTML += `
              <div class="set-detail-pattern" data-id="${pattern.id}">
                <img src="${
                  pattern.thumbnailPath ||
                  "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+"
                }" 
                  alt="${pattern.patternName}" class="pixel-art-image">
                <div class="pattern-name">${pattern.patternName}</div>
              </div>
            `;
          });

          patternsHTML += "</div>";
        }

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">${set.name}</h2>
            
            <div class="set-detail-info">
              <div class="creator-info">
                <strong>Creator:</strong> ${creatorInfo.name} of ${
          creatorInfo.town
        }
              </div>
              <div class="set-detail-meta">
                <div><strong>Patterns:</strong> ${patterns.length}</div>
                ${
                  set.gridSize
                    ? `<div><strong>Grid Size:</strong> ${set.gridSize}</div>`
                    : ""
                }
              </div>
              ${set.notes ? `<div class="set-notes">${set.notes}</div>` : ""}
            </div>
            
            <div class="set-patterns-container">
              ${patternsHTML}
            </div>
            
            <div class="set-actions">
              <button class="btn" id="edit-set-btn" data-id="${setId}">Edit Set</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // Add event listeners
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Edit button
        modal.querySelector("#edit-set-btn").addEventListener("click", () => {
          document.body.removeChild(modal);
          editSet(setId);
        });

        // Pattern click events
        modal
          .querySelectorAll(".set-detail-pattern[data-id]")
          .forEach((patternElement) => {
            patternElement.addEventListener("click", () => {
              const patternId = patternElement.getAttribute("data-id");
              document.body.removeChild(modal);
              openPatternDetail(patternId);
            });
          });
      }

      // Render creators view
      function renderCreators() {
        const creatorList = elements.creatorList;
        creatorList.innerHTML = "";

        const creators = Object.values(appData.creators);

        if (creators.length === 0) {
          creatorList.innerHTML =
            "<p>No creators available. Import patterns to see creators or add one manually using the 'Add Creator' button.</p>";
          return;
        }

        creators.forEach((creator) => {
          const creatorCard = document.createElement("div");
          creatorCard.className = "creator-card";

          // Count patterns by this creator
          const patternCount = creator.patterns.length;
          const completionPercentage = calculateCompletionPercentage(creator);

          // Create rank badge
          let rankBadge = "";
          if (creator.rank === "verified") {
            rankBadge =
              '<span class="creator-rank verified">Verified 🌟</span>';
          } else if (creator.rank === "plagiarist") {
            rankBadge =
              '<span class="creator-rank plagiarist">Plagiarist ⚠️</span>';
          } else {
            rankBadge = '<span class="creator-rank unknown">Unknown</span>';
          }

          // Create completion badge
          let completionBadge = "";
          if (creator.isComplete) {
            completionBadge =
              '<span class="completion-badge complete">Complete</span>';
          } else if (creator.totalPatterns) {
            const percentage = Math.round(completionPercentage);
            completionBadge = `<span class="completion-badge" style="background-color: ${getCompletionColor(
              completionPercentage
            )}">${percentage}%</span>`;
          }

          const html = `
            <div class="creator-header">
              <h3>${creator.name} ${rankBadge} ${completionBadge}</h3>
              <div class="creator-code-container">
                ${
                  creator.creatorCode
                    ? `<span class="creator-code">${creator.creatorCode}</span>`
                    : ""
                }
              </div>
            </div>
            
            <div class="creator-details">
              <div class="creator-detail">
                <div class="detail-label">Town</div>
                <div class="detail-value">${creator.townName}</div>
              </div>
              
              <div class="creator-detail">
                <div class="detail-label">Patterns</div>
                <div class="detail-value">${patternCount} / ${
            creator.totalPatterns || "?"
          }</div>
              </div>
              
              <div class="creator-detail">
                <div class="detail-label">Last Updated</div>
                <div class="detail-value">${getLastUpdatedDate(creator)}</div>
              </div>
            </div>
            
            ${
              creator.notes
                ? `<div class="creator-notes">${creator.notes}</div>`
                : ""
            }
            
            <div class="creator-actions">
              <button class="btn btn-secondary" data-action="view" data-id="${
                creator.id
              }">View Patterns</button>
              <button class="btn btn-secondary" data-action="edit" data-id="${
                creator.id
              }">Edit Info</button>
            </div>
          `;

          creatorCard.innerHTML = html;

          // Add event listeners for buttons
          creatorCard
            .querySelector('[data-action="view"]')
            .addEventListener("click", () => {
              viewCreatorPatterns(creator.id);
            });

          creatorCard
            .querySelector('[data-action="edit"]')
            .addEventListener("click", () => {
              editCreator(creator.id);
            });

          creatorList.appendChild(creatorCard);
        });
      }

      // View creator patterns
      function viewCreatorPatterns(creatorId) {
        const creator = appData.creators[creatorId];
        if (!creator) return;

        // Clear all filters first
        appData.activeFilters.tags.clear();
        appData.activeFilters.sets.clear();
        appData.activeFilters.creators.clear();
        appData.activeFilters.search = "";
        document.getElementById("pattern-search").value = "";

        // Add creator filter
        appData.activeFilters.creators.add(creator.name.toLowerCase());

        // Switch to patterns tab
        elements.tabs.forEach((tab) => {
          const tabId = tab.getAttribute("data-tab");
          if (tabId === "patterns") {
            tab.click();
          }
        });

        // Make sure to render the gallery with the new filter
        renderPatternGallery();

        // Update sidebar filters to reflect the active filter
        renderSidebarFilters();
      }

      // Edit creator information
      function editCreator(creatorId) {
        const creator = appData.creators[creatorId];
        if (!creator) return;

        // Create modal for creator editing
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Edit Creator Information</h2>
            <div class="creator-edit-form">
              <div class="form-group">
                <label for="creator-name-input">Creator Name</label>
                <input type="text" id="creator-name-input" value="${
                  creator.name
                }" readonly>
                <p class="help-text">Creator name cannot be changed as it comes from the pattern files.</p>
              </div>
              
              <div class="form-group">
                <label for="creator-town-input">Town Name</label>
                <input type="text" id="creator-town-input" value="${
                  creator.townName
                }" readonly>
                <p class="help-text">Town name cannot be changed as it comes from the pattern files.</p>
              </div>
              
              <div class="form-group">
                <label for="creator-code-input">Creator Code</label>
                <input type="text" id="creator-code-input" value="${
                  creator.creatorCode || ""
                }" 
                      placeholder="MA-####-####-####" pattern="MA-\\d{4}-\\d{4}-\\d{4}">
                <p class="help-text">Format: MA-####-####-#### (e.g., MA-1234-5678-9012)</p>
              </div>
              
              <div class="form-group">
                <label for="creator-rank-input">Creator Rank</label>
                <select id="creator-rank-input">
                  <option value="unknown" ${
                    creator.rank !== "verified" && creator.rank !== "plagiarist"
                      ? "selected"
                      : ""
                  }>
                    Unknown (Default)
                  </option>
                  <option value="verified" ${
                    creator.rank === "verified" ? "selected" : ""
                  }>
                    Verified (Original Creator)
                  </option>
                  <option value="plagiarist" ${
                    creator.rank === "plagiarist" ? "selected" : ""
                  }>
                    Plagiarist (Copies Others' Work)
                  </option>
                </select>
                <p class="help-text">Select the appropriate rank based on your confidence in the creator's originality.</p>
              </div>
              
              <div class="form-group">
                <label for="creator-total-input">Total Patterns</label>
                <input type="number" id="creator-total-input" min="0" value="${
                  creator.totalPatterns || 0
                }">
                <p class="help-text">Set the total number of patterns this creator has made (if known).</p>
              </div>
              
              <div class="form-group">
                <label for="creator-complete-input">Collection Status</label>
                <select id="creator-complete-input">
                  <option value="false" ${
                    !creator.isComplete ? "selected" : ""
                  }>Incomplete</option>
                  <option value="true" ${
                    creator.isComplete ? "selected" : ""
                  }>Complete</option>
                </select>
                <p class="help-text">Mark whether you have collected all patterns from this creator.</p>
              </div>
              
              <div class="form-group">
                <label for="creator-notes-input">Notes</label>
                <textarea id="creator-notes-input" rows="4">${
                  creator.notes || ""
                }</textarea>
              </div>
              
              <div class="creator-stats">
                <h3>Collection Statistics</h3>
                <div class="stats-container">
                  <div class="stat-item">
                    <div class="stat-label">Patterns Backed Up</div>
                    <div class="stat-value">${creator.patterns.length}</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Completion Rate</div>
                    <div class="stat-value completion-rate" style="color: ${getCompletionColor(
                      calculateCompletionPercentage(creator)
                    )}">
                      ${calculateCompletionRate(creator)}
                    </div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Last Updated</div>
                    <div class="stat-value">
                      ${getLastUpdatedDate(creator)}
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="form-actions">
                <button class="btn btn-secondary" id="view-patterns-btn">View Patterns</button>
                <button class="btn" id="save-creator-btn" data-id="${creatorId}">Save Changes</button>
              </div>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // Add Creator Code formatter
        const creatorCodeInput = document.getElementById("creator-code-input");
        creatorCodeInput.addEventListener("input", function (e) {
          let value = this.value.replace(/[^A-Ma-m0-9]/g, "").toUpperCase();

          // Make sure it starts with MA
          if (value.length >= 2 && value.substring(0, 2) !== "MA") {
            value =
              "MA" + value.substring(value.length - Math.min(value.length, 12));
          } else if (value.length < 2) {
            value = value.padStart(2, "M");
          }

          // Format with dashes
          if (value.length > 2) {
            let formatted = value.substring(0, 2) + "-";

            // Add first group of digits
            const firstGroup = value.substring(2, Math.min(6, value.length));
            formatted += firstGroup;

            // Add second group if we have it
            if (value.length > 6) {
              formatted += "-" + value.substring(6, Math.min(10, value.length));

              // Add third group if we have it
              if (value.length > 10) {
                formatted +=
                  "-" + value.substring(10, Math.min(14, value.length));
              }
            }

            value = formatted;
          }

          this.value = value;
        });

        // Close button functionality
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // View patterns button
        document
          .getElementById("view-patterns-btn")
          .addEventListener("click", () => {
            document.body.removeChild(modal);
            viewCreatorPatterns(creatorId);
          });

        // Save button
        document
          .getElementById("save-creator-btn")
          .addEventListener("click", () => {
            // Get values from form
            const creatorCode = document
              .getElementById("creator-code-input")
              .value.trim();
            const rank = document.getElementById("creator-rank-input").value;
            const totalPatterns =
              parseInt(document.getElementById("creator-total-input").value) ||
              0;
            const isComplete =
              document.getElementById("creator-complete-input").value ===
              "true";
            const notes = document
              .getElementById("creator-notes-input")
              .value.trim();

            // Validate creator code format if provided
            if (creatorCode && !creatorCode.match(/^MA-\d{4}-\d{4}-\d{4}$/)) {
              showNotification(
                "Creator Code must be in format MA-####-####-####",
                "error"
              );
              return;
            }

            // Update creator object
            creator.creatorCode = creatorCode;
            creator.rank = rank;
            creator.totalPatterns = totalPatterns;
            creator.isComplete = isComplete;
            creator.notes = notes;

            // Save to localStorage
            saveDataToLocalStorage();

            // Update UI
            renderCreators();

            // Update pattern gallery to refresh creator badges
            renderPatternGallery();

            // Close modal
            document.body.removeChild(modal);

            showNotification("Creator information updated successfully");
          });

        // Update completion rate when total patterns changes
        const totalInput = document.getElementById("creator-total-input");
        const completionRate = modal.querySelector(".completion-rate");

        totalInput.addEventListener("input", () => {
          const total = parseInt(totalInput.value) || 0;
          const tempCreator = { ...creator, totalPatterns: total };
          completionRate.textContent = calculateCompletionRate(tempCreator);
          completionRate.style.color = getCompletionColor(
            calculateCompletionPercentage(tempCreator)
          );
        });

        // Automatically mark as complete if backed up equals total
        totalInput.addEventListener("change", () => {
          const total = parseInt(totalInput.value) || 0;
          const completeSelect = document.getElementById(
            "creator-complete-input"
          );

          if (total > 0 && total <= creator.patterns.length) {
            completeSelect.value = "true";
          }
        });
      }

      // Calculate completion rate display string
      function calculateCompletionRate(creator) {
        const backupCount = creator.patterns.length;
        const totalCount = creator.totalPatterns || 0;

        if (totalCount === 0) {
          return "Unknown";
        }

        const percentage = Math.round((backupCount / totalCount) * 100);
        return `${backupCount}/${totalCount} (${percentage}%)`;
      }

      // Calculate completion percentage
      function calculateCompletionPercentage(creator) {
        const backupCount = creator.patterns.length;
        const totalCount = creator.totalPatterns || 0;

        if (totalCount === 0) {
          return 0;
        }

        return (backupCount / totalCount) * 100;
      }

      // Get color based on completion percentage
      function getCompletionColor(percentage) {
        if (percentage >= 100) {
          return "var(--success-color)";
        } else if (percentage >= 75) {
          return "#2ecc71"; // Green
        } else if (percentage >= 50) {
          return "#f39c12"; // Orange
        } else if (percentage >= 25) {
          return "#e67e22"; // Dark Orange
        } else {
          return "#e74c3c"; // Red
        }
      }

      // Get the last updated date for a creator
      function getLastUpdatedDate(creator) {
        // Find the most recently modified pattern from this creator
        const patterns = creator.patterns
          .map((id) => appData.patterns[id])
          .filter((p) => p); // Remove any undefined patterns

        if (patterns.length === 0) {
          return "Never";
        }

        // Sort by lastModified date
        patterns.sort((a, b) => {
          const dateA = a.lastModified ? new Date(a.lastModified) : new Date(0);
          const dateB = b.lastModified ? new Date(b.lastModified) : new Date(0);
          return dateB - dateA; // Most recent first
        });

        // Get the most recent date
        const mostRecent = patterns[0].lastModified || patterns[0].dateAdded;

        if (!mostRecent) {
          return "Unknown";
        }

        // Format the date
        const date = new Date(mostRecent);
        return date.toLocaleDateString();
      }

      // Load app settings from localStorage
      function loadAppSettings() {
        try {
          const storedSettings = localStorage.getItem("acAppSettings");
          if (storedSettings) {
            Object.assign(appSettings, JSON.parse(storedSettings));
          }
        } catch (error) {
          console.error("Error loading app settings:", error);
        }
      }

      // Save app settings to localStorage
      function saveAppSettings() {
        try {
          localStorage.setItem("acAppSettings", JSON.stringify(appSettings));
        } catch (error) {
          console.error("Error saving app settings:", error);
          showNotification("Error saving app settings", "error");
        }
      }

      // Setup app settings UI
      function setupAppSettings() {
        // Create settings button in header
        const header = document.querySelector("header");
        const settingsBtn = document.createElement("button");
        settingsBtn.id = "settings-btn";
        settingsBtn.className = "btn btn-secondary";
        settingsBtn.textContent = "Settings";
        header.querySelector("div:last-child").prepend(settingsBtn);

        // Create settings modal
        const settingsModal = document.createElement("div");
        settingsModal.className = "modal-backdrop";
        settingsModal.id = "settings-modal";
        settingsModal.innerHTML = `
    <div class="modal">
      <button class="modal-close">&times;</button>
      <h2 class="modal-title">App Settings</h2>
      
      <div class="settings-section">
        <h3>Storage Usage</h3>
        <div class="storage-meter-container">
          <div class="storage-meter">
            <div class="storage-meter-fill" id="storage-meter-fill"></div>
          </div>
          <div class="storage-meter-labels">
            <span class="storage-used" id="storage-used">0 KB</span> / <span id="storage-total">5 MB</span>
          </div>
        </div>
        <div class="storage-breakdown">
          <p>Metadata: <span id="metadata-size">0 KB</span></p>
          <p>Thumbnails: <span id="thumbnails-size">0 KB</span></p>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Thumbnail Storage</h3>
        <div class="form-group">
          <label>
            <input type="radio" name="thumbnail-storage" id="store-base64" ${
              appSettings.storeThumbnailsAsBase64 ? "checked" : ""
            }>
            Store thumbnails as base64 (works offline, uses more storage)
          </label>
        </div>
        <div class="form-group">
          <label>
            <input type="radio" name="thumbnail-storage" id="store-paths" ${
              !appSettings.storeThumbnailsAsBase64 ? "checked" : ""
            }>
            Load thumbnails dynamically from files (saves storage, requires file access)
          </label>
        </div>
        <div id="storage-switch-warning" class="warning-message" style="display: none;">
          Switching storage methods may take some time if you have many patterns.
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Data Management</h3>
        <p class="help-text">Import or export pattern metadata including tags, sets, and creator information.</p>
        <div class="form-group" style="display: flex; gap: 10px;">
          <button id="import-metadata-btn-settings" class="btn btn-secondary">Import Metadata</button>
          <button id="export-metadata-btn-settings" class="btn btn-secondary">Export Metadata</button>
        </div>
      </div>
      
      <button class="btn" id="save-settings-btn">Save Settings</button>
    </div>
  `;
        document.body.appendChild(settingsModal);

        // Add event listeners
        settingsBtn.addEventListener("click", () => {
          updateStorageUsage();
          settingsModal.style.display = "flex";
        });

        settingsModal
          .querySelector(".modal-close")
          .addEventListener("click", () => {
            settingsModal.style.display = "none";
          });

        document
          .getElementById("store-base64")
          .addEventListener("change", function () {
            document.getElementById("storage-switch-warning").style.display =
              this.checked && !appSettings.storeThumbnailsAsBase64
                ? "block"
                : "none";
          });

        document
          .getElementById("store-paths")
          .addEventListener("change", function () {
            document.getElementById("storage-switch-warning").style.display =
              this.checked && appSettings.storeThumbnailsAsBase64
                ? "block"
                : "none";
          });

        document
          .getElementById("save-settings-btn")
          .addEventListener("click", async () => {
            const newStoreAsBase64 =
              document.getElementById("store-base64").checked;

            // If storage method is changing, we need to convert thumbnails
            if (newStoreAsBase64 !== appSettings.storeThumbnailsAsBase64) {
              showLoader("Converting thumbnails...");
              try {
                if (newStoreAsBase64) {
                  await convertToBase64Thumbnails();
                } else {
                  await convertToFilePaths();
                }
                appSettings.storeThumbnailsAsBase64 = newStoreAsBase64;
                saveAppSettings();
                saveDataToLocalStorage();
                showNotification("Settings saved and thumbnails converted");
              } catch (error) {
                console.error("Error converting thumbnails:", error);
                showNotification("Error converting thumbnails", "error");
              } finally {
                hideLoader();
              }
            } else {
              // Just save settings if nothing is changing
              appSettings.storeThumbnailsAsBase64 = newStoreAsBase64;
              saveAppSettings();
              showNotification("Settings saved");
            }

            settingsModal.style.display = "none";
            renderPatternGallery();
          });

        // Add event listeners for the import and export metadata buttons
        document
          .getElementById("import-metadata-btn-settings")
          .addEventListener("click", () => {
            // Close settings modal first
            settingsModal.style.display = "none";

            // Then show import metadata modal
            document.getElementById("metadata-file").value = "";
            document.getElementById("metadata-import-status").innerHTML = "";
            document.getElementById("import-metadata-modal").style.display =
              "flex";
          });

        document
          .getElementById("export-metadata-btn-settings")
          .addEventListener("click", () => {
            // Close settings modal first
            settingsModal.style.display = "none";

            // Then export metadata
            exportMetadata();
          });
      }

      // Update storage usage display
      function updateStorageUsage() {
        try {
          // Calculate sizes
          const patternsJson = JSON.stringify(appData.patterns);
          const creatorsJson = JSON.stringify(appData.creators);
          const setsJson = JSON.stringify(appData.sets);
          const processedFilesJson = JSON.stringify([
            ...appData.processedFiles,
          ]);

          // Calculate size of metadata (without thumbnails)
          const patternsWithoutThumbnails = JSON.parse(patternsJson);
          for (const id in patternsWithoutThumbnails) {
            if (appSettings.storeThumbnailsAsBase64) {
              patternsWithoutThumbnails[id].thumbnailPath = null;
            }
          }

          const metadataSize =
            JSON.stringify(patternsWithoutThumbnails).length +
            creatorsJson.length +
            setsJson.length +
            processedFilesJson.length;

          // Calculate thumbnails size
          const thumbnailsSize = appSettings.storeThumbnailsAsBase64
            ? patternsJson.length -
              JSON.stringify(patternsWithoutThumbnails).length
            : 0;

          // Total used size
          const totalUsed = metadataSize + thumbnailsSize;

          // Rough estimate of localStorage capacity (5MB is common)
          const totalCapacity = 5 * 1024 * 1024;

          // Update UI
          document.getElementById("metadata-size").textContent =
            formatBytes(metadataSize);
          document.getElementById("thumbnails-size").textContent =
            formatBytes(thumbnailsSize);
          document.getElementById("storage-used").textContent =
            formatBytes(totalUsed);
          document.getElementById(
            "storage-meter-fill"
          ).style.width = `${Math.min(
            100,
            (totalUsed / totalCapacity) * 100
          )}%`;

          // Change color based on usage
          const fill = document.getElementById("storage-meter-fill");
          if (totalUsed / totalCapacity > 0.9) {
            fill.style.backgroundColor = "var(--error-color)";
          } else if (totalUsed / totalCapacity > 0.7) {
            fill.style.backgroundColor = "#f39c12"; // Orange warning color
          } else {
            fill.style.backgroundColor = "var(--primary-color)";
          }
        } catch (error) {
          console.error("Error calculating storage usage:", error);
        }
      }

      // Format bytes to human-readable format
      function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return "0 Bytes";

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB"];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return (
          parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i]
        );
      }

      // Create loading overlay
      function showLoader(message = "Loading...") {
        let loader = document.getElementById("app-loader");
        if (!loader) {
          loader = document.createElement("div");
          loader.id = "app-loader";
          loader.className = "loader-overlay";
          loader.innerHTML = `
      <div class="loader-content">
        <div class="loading"></div>
        <div class="loader-message">${message}</div>
      </div>
    `;
          document.body.appendChild(loader);
        } else {
          loader.querySelector(".loader-message").textContent = message;
          loader.style.display = "flex";
        }
      }

      function hideLoader() {
        const loader = document.getElementById("app-loader");
        if (loader) {
          loader.style.display = "none";
        }
      }

      // Create a small resized thumbnail from an image file
      function createResizedThumbnail(file) {
        return new Promise((resolve, reject) => {
          if (!file) {
            reject(new Error("No file provided"));
            return;
          }

          const reader = new FileReader();
          reader.onload = function (e) {
            const img = new Image();
            img.onload = function () {
              // Create a small thumbnail
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Set to 32x32 for Animal Crossing patterns
              canvas.width = 32;
              canvas.height = 32;

              // Use pixelated rendering
              ctx.imageSmoothingEnabled = false;

              // Draw the image
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

              // Get as data URL (base64)
              const thumbnailDataUrl = canvas.toDataURL("image/png");
              resolve(thumbnailDataUrl);
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // Convert all thumbnails to base64 (when switching from file paths)
      async function convertToBase64Thumbnails() {
        const patterns = Object.values(appData.patterns);
        const totalPatterns = patterns.length;
        let processedPatterns = 0;

        for (const pattern of patterns) {
          // Skip if already has base64 data
          if (
            pattern.thumbnailPath &&
            pattern.thumbnailPath.startsWith("data:")
          ) {
            processedPatterns++;
            continue;
          }

          // Try to load from original file path
          if (pattern.originalFilePath) {
            try {
              // This approach with fetch might not work with file:/// URLs due to security restrictions
              // Try to use relative paths that might work
              const response = await fetch(pattern.originalFilePath);
              const blob = await response.blob();

              // Create thumbnail from loaded file
              pattern.thumbnailPath = await createResizedThumbnail(blob);
            } catch (error) {
              console.error(
                `Could not load image from path: ${pattern.originalFilePath}`,
                error
              );
              pattern.thumbnailPath = null; // Reset if we couldn't load
            }
          }

          processedPatterns++;
          if (processedPatterns % 10 === 0) {
            showLoader(
              `Converting thumbnails: ${processedPatterns}/${totalPatterns}`
            );
          }
        }
      }

      // Convert all thumbnails to file paths (when switching from base64)
      async function convertToFilePaths() {
        const patterns = Object.values(appData.patterns);

        for (const pattern of patterns) {
          // If we have base64 data, store the reference to original file and clear base64 data
          if (
            pattern.thumbnailPath &&
            pattern.thumbnailPath.startsWith("data:")
          ) {
            // Keep the originalFilePath but clear the base64 thumbnailPath
            // We'll use originalFilePath when loading
            if (!pattern.originalFilePath) {
              // If somehow we don't have the original path, keep base64
              pattern.originalFilePath = pattern.thumbnailPath;
            } else {
              pattern.thumbnailPath = null;
            }
          }
        }
      }

      // Import patterns
      async function importPatterns() {
        const fileInput = document.getElementById("pattern-folder");
        const files = fileInput.files;

        if (files.length === 0) {
          showNotification(
            "Please select a folder with pattern files",
            "error"
          );
          return;
        }

        const importStatus = document.getElementById("import-status");
        importStatus.innerHTML =
          '<div class="loading"></div> Scanning files...';

        try {
          // Filter files to just .nhd and .png
          const nhdFiles = Array.from(files).filter((file) =>
            file.name.endsWith(".nhd")
          );
          const pngFiles = Array.from(files).filter((file) =>
            file.name.endsWith(".png")
          );

          // Map to group pattern files by their pattern and creator name
          const patternGroups = new Map();

          // Used thumbnails tracking
          const usedThumbnails = new Set();

          // First, group patterns by their name and creator
          for (const nhdFile of nhdFiles) {
            // Skip already processed files
            if (appData.processedFiles.has(nhdFile.name)) continue;

            // Extract metadata
            const metadata = await extractMetadataFromFile(nhdFile);
            const key = `${metadata.patternName}-${metadata.creatorName}`;

            if (!patternGroups.has(key)) {
              patternGroups.set(key, []);
            }

            patternGroups.get(key).push({
              file: nhdFile,
              metadata: metadata,
            });
          }

          // Process each group to assign thumbnails in order
          const importPromises = [];

          for (const [key, patterns] of patternGroups.entries()) {
            // Sort patterns (optional, depending on your preference)
            // This sorts by the numeric prefix if present in the filename
            patterns.sort((a, b) => {
              const numA = parseInt(a.file.name.match(/^(\d+)/)?.[1] || "0");
              const numB = parseInt(b.file.name.match(/^(\d+)/)?.[1] || "0");
              return numA - numB;
            });

            // For each pattern in the group, find the corresponding thumbnail
            for (let i = 0; i < patterns.length; i++) {
              const pattern = patterns[i];
              const metadata = pattern.metadata;

              // Generate the base thumbnail name
              const sanitizedBaseName = sanitizeFilename(
                `${metadata.patternName} - ${metadata.creatorName}`
              );
              const normalizedBaseName =
                normalizeForComparison(sanitizedBaseName);

              // Find matching thumbnails in order
              let targetThumbnail = null;

              // First try the exact match for the first pattern
              if (i === 0) {
                const exactMatch = pngFiles.find((file) => {
                  if (usedThumbnails.has(file.name)) return false;

                  const normalizedFileName = normalizeForComparison(file.name);
                  const baseNameWithoutExt = normalizedBaseName;

                  return (
                    normalizedFileName === `${baseNameWithoutExt}.png` ||
                    normalizedFileName === `${baseNameWithoutExt}_x8.png`
                  );
                });

                if (exactMatch) {
                  targetThumbnail = exactMatch;
                  usedThumbnails.add(exactMatch.name);
                }
              }

              // If no exact match or not the first pattern, try numbered versions
              if (!targetThumbnail) {
                const suffix = i > 0 ? `_${i + 1}` : "";

                // Try x8 version first (higher quality)
                const x8Match = pngFiles.find((file) => {
                  if (usedThumbnails.has(file.name)) return false;

                  const normalizedFileName = normalizeForComparison(file.name);
                  const expectedName = `${normalizedBaseName}${suffix}_x8.png`;

                  return normalizedFileName === expectedName;
                });

                if (x8Match) {
                  targetThumbnail = x8Match;
                  usedThumbnails.add(x8Match.name);
                } else {
                  // Try regular version
                  const regularMatch = pngFiles.find((file) => {
                    if (usedThumbnails.has(file.name)) return false;

                    const normalizedFileName = normalizeForComparison(
                      file.name
                    );
                    const expectedName = `${normalizedBaseName}${suffix}.png`;

                    return normalizedFileName === expectedName;
                  });

                  if (regularMatch) {
                    targetThumbnail = regularMatch;
                    usedThumbnails.add(regularMatch.name);
                  }
                }
              }

              // If still no match, try to find any unused thumbnail with the base name
              if (!targetThumbnail) {
                for (const pngFile of pngFiles) {
                  if (usedThumbnails.has(pngFile.name)) continue;

                  const normalizedFileName = normalizeForComparison(
                    pngFile.name
                  );

                  if (
                    normalizedFileName.startsWith(normalizedBaseName) &&
                    (normalizedFileName.endsWith(".png") ||
                      normalizedFileName.endsWith("_x8.png"))
                  ) {
                    targetThumbnail = pngFile;
                    usedThumbnails.add(pngFile.name);
                    break;
                  }
                }
              }

              // Import the pattern with the found thumbnail
              importPromises.push(
                importPattern(pattern.file, targetThumbnail, metadata)
              );
            }
          }

          importStatus.innerHTML = `<div class="loading"></div> Importing ${importPromises.length} patterns...`;

          // Process all imports
          const results = await Promise.allSettled(importPromises);

          // Count successes and failures
          const successes = results.filter(
            (r) => r.status === "fulfilled"
          ).length;
          const failures = results.filter(
            (r) => r.status === "rejected"
          ).length;

          importStatus.innerHTML = `<div class="success-message">Imported ${successes} patterns successfully.${
            failures > 0 ? ` Failed to import ${failures} patterns.` : ""
          }</div>`;

          // Save data
          saveDataToLocalStorage();

          // Refresh views
          renderPatternGallery();
          renderSidebarFilters();

          showNotification(`Imported ${successes} patterns`);
        } catch (error) {
          console.error("Error importing patterns:", error);
          importStatus.innerHTML = `<div class="error-message">Error importing patterns: ${error.message}</div>`;
          showNotification("Error importing patterns", "error");
        }
      }

      // Helper function to sanitize filenames exactly like the C# code
      function sanitizeFilename(filename) {
        // First normalize whitespace (collapse multiple spaces to single space)
        filename = filename.replace(/\s+/g, " ");

        // Then perform the Windows character sanitization
        return filename
          .replace(/\?/g, "_")
          .replace(/\//g, "_")
          .replace(/\\/g, "_")
          .replace(/\*/g, "_")
          .replace(/:/g, "_")
          .replace(/</g, "_")
          .replace(/>/g, "_")
          .replace(/\|/g, "_")
          .replace(/"/g, "_");
      }

      // When matching thumbnails, implement a more flexible string comparison
      function normalizeForComparison(str) {
        // Remove all whitespace for comparison purposes
        return str.replace(/\s+/g, "");
      }

      // Helper function to escape special characters in regular expressions
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      // Extract metadata from a file
      async function extractMetadataFromFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = function () {
            try {
              const metadata = extractMetadataFromNHD(reader.result);
              resolve(metadata);
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function (event) {
            reject(new Error("Error reading file: " + event.target.error));
          };

          reader.readAsArrayBuffer(file);
        });
      }

      // Generate a simple hash of an image
      async function generateThumbnailHash(imageSrc) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          // Set canvas to a standard size (32x32) for consistent hashing
          canvas.width = 32;
          canvas.height = 32;

          img.onload = function () {
            try {
              // Draw image on canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

              // Get pixel data
              const imageData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Create a string from pixel data
              let hash = "";

              // Sample every 4th pixel (for performance) and use RGB values
              for (let i = 0; i < imageData.length; i += 16) {
                if (imageData[i + 3] < 128) {
                  // Transparent pixel
                  hash += "T";
                } else {
                  // For colored pixels, quantize to reduce sensitivity to minor variations
                  const r = Math.floor(imageData[i] / 32);
                  const g = Math.floor(imageData[i + 1] / 32);
                  const b = Math.floor(imageData[i + 2] / 32);
                  hash += `${r}${g}${b}`;
                }
              }

              resolve(hash);
            } catch (error) {
              reject(error);
            }
          };

          img.onerror = function () {
            reject(new Error("Error loading image for hashing"));
          };

          // Handle both base64 and file path sources
          if (typeof imageSrc === "string") {
            // If it's a string (either base64 or file path)
            img.src = imageSrc;
          } else if (imageSrc instanceof Blob) {
            // If it's a blob or file object
            img.src = URL.createObjectURL(imageSrc);
          } else {
            reject(new Error("Unsupported image source type"));
          }
        });
      }

      // Import a single pattern
      async function importPattern(nhdFile, pngFile, metadata) {
        return new Promise(async (resolve, reject) => {
          try {
            console.log(
              `Importing pattern: ${nhdFile.name}, size: ${nhdFile.size} bytes`
            );
            console.log(`PNG file available: ${pngFile !== null}`);

            // Generate pattern ID
            const patternId =
              "pattern-" + Date.now() + "-" + Math.floor(Math.random() * 1000);

            // Create pattern entry
            const pattern = {
              id: patternId,
              fileName: nhdFile.name,
              thumbnailPath: null, // Will be set below based on storage preference
              originalFilePath: null, // Store original file path for reference

              // Metadata from .nhd file
              patternName: metadata.patternName || "Unnamed Pattern",
              creatorName: metadata.creatorName || "Unknown Creator",
              townName: metadata.townName || "Unknown Town",
              townId: metadata.townId || "",

              // User-defined metadata
              tags: [],
              setName: "",
              setId: "",
              setOrder: 0,
              relatedPatterns: [],
              notes: "",

              // System metadata
              dateAdded: new Date().toISOString().split("T")[0],
              lastModified: new Date().toISOString().split("T")[0],

              // Hash for duplicate detection
              thumbnailHash: null,
            };

            // Handle thumbnail based on storage preference
            if (pngFile) {
              // Always store the original file path for reference
              pattern.originalFilePath =
                pngFile.webkitRelativePath || pngFile.name;

              // If storing as base64, create resized thumbnail
              if (appSettings.storeThumbnailsAsBase64) {
                try {
                  pattern.thumbnailPath = await createResizedThumbnail(pngFile);
                } catch (error) {
                  console.error("Error creating thumbnail:", error);
                  pattern.thumbnailPath = null;
                }
              }

              // Generate hash for the thumbnail
              try {
                // Use either the base64 or the original file for hashing
                const imageForHashing =
                  pattern.thumbnailPath || URL.createObjectURL(pngFile);
                pattern.thumbnailHash = await generateThumbnailHash(
                  imageForHashing
                );

                // If we created a blob URL for hashing, revoke it to free memory
                if (
                  !pattern.thumbnailPath &&
                  imageForHashing.startsWith("blob:")
                ) {
                  URL.revokeObjectURL(imageForHashing);
                }
              } catch (hashError) {
                console.error("Error generating hash:", hashError);
                // Continue even if hash generation fails
              }
            }

            console.log("Created pattern object:", {
              id: pattern.id,
              name: pattern.patternName,
              creator: pattern.creatorName,
              town: pattern.townName,
              hash: pattern.thumbnailHash
                ? pattern.thumbnailHash.substring(0, 20) + "..."
                : "None",
            });

            // Add pattern to data store
            appData.patterns[patternId] = pattern;

            // Create or update creator info
            const creatorId =
              "creator-" +
              pattern.creatorName.toLowerCase().replace(/[^a-z0-9]/g, "-") +
              "-" +
              pattern.townName.toLowerCase().replace(/[^a-z0-9]/g, "-");
            console.log("Creator ID:", creatorId);

            if (!appData.creators[creatorId]) {
              appData.creators[creatorId] = {
                id: creatorId,
                name: pattern.creatorName,
                townName: pattern.townName,
                creatorCode: null,
                rank: "unknown",
                patterns: [],
                totalBackedUp: 0,
                totalPatterns: 0,
                isComplete: false,
                notes: "",
              };
              console.log("Created new creator:", pattern.creatorName);
            } else {
              console.log("Adding to existing creator:", pattern.creatorName);
            }

            // Add pattern to creator
            appData.creators[creatorId].patterns.push(patternId);
            appData.creators[creatorId].totalBackedUp =
              appData.creators[creatorId].patterns.length;

            // Mark file as processed
            appData.processedFiles.add(nhdFile.name);
            console.log(`Pattern import successful: ${pattern.patternName}`);

            resolve(pattern);
          } catch (error) {
            console.error("Error processing pattern:", error);
            reject(error);
          }
        });
      }

      // Extract metadata from .nhd file
      function extractMetadataFromNHD(arrayBuffer) {
        console.log(
          "Extracting metadata from NHD file, size:",
          arrayBuffer.byteLength
        );

        // Create a DataView for easier binary data access
        const view = new DataView(arrayBuffer);

        try {
          // Extract pattern name (40 bytes at offset 0x10)
          let patternName = extractUTF16String(arrayBuffer, 0x10, 40);
          console.log("Extracted pattern name:", patternName);

          // Town ID (4 bytes at offset 0x38)
          const townId = view.getUint32(0x38, true).toString();
          console.log("Extracted town ID:", townId);

          // Extract town name (20 bytes at offset 0x3C)
          let townName = extractUTF16String(arrayBuffer, 0x3c, 20);
          console.log("Extracted town name:", townName);

          // Extract creator name (20 bytes at offset 0x58)
          let creatorName = extractUTF16String(arrayBuffer, 0x58, 20);
          console.log("Extracted creator name:", creatorName);

          return {
            patternName: patternName || "Unnamed Pattern",
            creatorName: creatorName || "Unknown Creator",
            townName: townName || "Unknown Town",
            townId: townId || "",
          };
        } catch (error) {
          console.error("Error extracting metadata:", error);
          return {
            patternName: "Unnamed Pattern",
            creatorName: "Unknown Creator",
            townName: "Unknown Town",
            townId: "",
          };
        }
      }

      // Helper function to extract UTF-16 strings from binary data
      function extractUTF16String(arrayBuffer, offset, maxByteLength) {
        // Create a DataView for reading UTF-16 values
        const dataView = new DataView(arrayBuffer);
        let result = "";

        // UTF-16 uses 2 bytes per character, so read characters until we hit null or maxByteLength
        for (let i = 0; i < maxByteLength; i += 2) {
          if (offset + i + 1 >= arrayBuffer.byteLength) break;

          const charCode = dataView.getUint16(offset + i, true); // true for little-endian

          // Stop at the null terminator
          if (charCode === 0) break;

          result += String.fromCharCode(charCode);
        }

        return result.trim();
      }

      // Add import metadata functionality
      function setupMetadataImport() {
        // Create import metadata modal
        const importMetadataModal = document.createElement("div");
        importMetadataModal.className = "modal-backdrop";
        importMetadataModal.id = "import-metadata-modal";

        importMetadataModal.innerHTML = `
    <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Import Pattern Metadata</h2>
        <div class="form-group">
            <label for="metadata-file">Select Metadata JSON File</label>
            <input type="file" id="metadata-file" accept=".json">
        </div>
        <div id="metadata-import-status"></div>
        <div class="import-options">
            <div class="form-group">
                <label>
                    <input type="checkbox" id="merge-metadata" checked>
                    Merge with existing data (recommended)
                </label>
                <p class="help-text">If unchecked, all existing metadata will be replaced with the imported data.</p>
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="update-existing" checked>
                    Update existing patterns
                </label>
                <p class="help-text">If unchecked, only new patterns will be added.</p>
            </div>
        </div>
        <button class="btn" id="start-metadata-import-btn">Import Metadata</button>
    </div>
  `;

        document.body.appendChild(importMetadataModal);

        // Close button event listener
        importMetadataModal
          .querySelector(".modal-close")
          .addEventListener("click", () => {
            importMetadataModal.style.display = "none";
          });

        // Start import button event listener
        document
          .getElementById("start-metadata-import-btn")
          .addEventListener("click", importMetadata);
      }

      // Import metadata from JSON file
      function importMetadata() {
        const fileInput = document.getElementById("metadata-file");
        const mergeMetadata = document.getElementById("merge-metadata").checked;
        const updateExisting =
          document.getElementById("update-existing").checked;
        const statusElement = document.getElementById("metadata-import-status");

        if (!fileInput.files || fileInput.files.length === 0) {
          statusElement.innerHTML =
            '<div class="error-message">Please select a metadata file to import.</div>';
          return;
        }

        const file = fileInput.files[0];

        // Check file type
        if (!file.name.endsWith(".json")) {
          statusElement.innerHTML =
            '<div class="error-message">Please select a valid JSON metadata file.</div>';
          return;
        }

        statusElement.innerHTML =
          '<div class="loading"></div> Reading metadata file...';

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const importData = JSON.parse(e.target.result);

            // Validate the imported data structure
            if (
              !importData.patterns ||
              !importData.creators ||
              !importData.sets
            ) {
              throw new Error(
                "Invalid metadata format. File should contain patterns, creators, and sets."
              );
            }

            // Import app settings if present
            if (importData.appSettings) {
              Object.assign(appSettings, importData.appSettings);
              saveAppSettings();
            }

            // Process patterns to handle different thumbnail storage formats
            // Handle both new format (with thumbnailPathBase64 and thumbnailPathFile)
            // and old format (with just thumbnailPath)
            for (const id in importData.patterns) {
              const pattern = importData.patterns[id];

              // If the exported data used the new format with separate base64 and file paths
              if (pattern.thumbnailPathBase64 || pattern.thumbnailPathFile) {
                if (
                  appSettings.storeThumbnailsAsBase64 &&
                  pattern.thumbnailPathBase64
                ) {
                  pattern.thumbnailPath = pattern.thumbnailPathBase64;
                } else {
                  pattern.thumbnailPath = null;
                }

                if (pattern.thumbnailPathFile) {
                  pattern.originalFilePath = pattern.thumbnailPathFile;
                }

                // Clean up temporary properties
                delete pattern.thumbnailPathBase64;
                delete pattern.thumbnailPathFile;
              }
              // If using old format, make sure it's compatible with current settings
              else if (pattern.thumbnailPath) {
                // If path is base64 but we're not storing base64, clear it and keep originalFilePath
                if (
                  pattern.thumbnailPath.startsWith("data:") &&
                  !appSettings.storeThumbnailsAsBase64
                ) {
                  pattern.originalFilePath =
                    pattern.originalFilePath || pattern.thumbnailPath;
                  pattern.thumbnailPath = null;
                }
                // If path is not base64 and we are storing base64, it will be loaded later on demand
              }
            }

            // Backup current data
            const backupData = {
              patterns: { ...appData.patterns },
              creators: { ...appData.creators },
              sets: { ...appData.sets },
              processedFiles: new Set([...appData.processedFiles]),
            };

            try {
              if (mergeMetadata) {
                // Merge with existing data
                mergeImportedData(importData, updateExisting);
                statusElement.innerHTML =
                  '<div class="success-message">Metadata successfully merged.</div>';
              } else {
                // Replace existing data
                if (
                  confirm(
                    "This will replace all existing metadata. Are you sure you want to continue?"
                  )
                ) {
                  replaceWithImportedData(importData);
                  statusElement.innerHTML =
                    '<div class="success-message">Metadata successfully imported.</div>';
                } else {
                  statusElement.innerHTML = "";
                  return;
                }
              }

              // Save changes
              saveDataToLocalStorage();

              // Refresh views
              renderPatternGallery();
              renderSidebarFilters();

              // Show success message with stats
              const patternCount = Object.keys(importData.patterns).length;
              const creatorCount = Object.keys(importData.creators).length;
              const setCount = Object.keys(importData.sets).length;

              showNotification(
                `Imported ${patternCount} patterns, ${creatorCount} creators, and ${setCount} sets`
              );

              // Close modal after successful import
              setTimeout(() => {
                document.getElementById("import-metadata-modal").style.display =
                  "none";
              }, 2000);
            } catch (processError) {
              console.error("Error processing imported data:", processError);

              // Restore from backup
              appData.patterns = backupData.patterns;
              appData.creators = backupData.creators;
              appData.sets = backupData.sets;
              appData.processedFiles = backupData.processedFiles;

              statusElement.innerHTML = `<div class="error-message">Error processing imported data: ${processError.message}</div>`;
            }
          } catch (parseError) {
            console.error("Error parsing JSON:", parseError);
            statusElement.innerHTML = `<div class="error-message">Error parsing metadata file: ${parseError.message}</div>`;
          }
        };

        reader.onerror = function () {
          statusElement.innerHTML =
            '<div class="error-message">Error reading the file.</div>';
        };

        reader.readAsText(file);
      }

      // Merge imported data with existing data
      function mergeImportedData(importData, updateExisting) {
        // Process patterns
        for (const [id, pattern] of Object.entries(importData.patterns)) {
          if (appData.patterns[id]) {
            // Pattern already exists
            if (updateExisting) {
              // Keep file references from existing pattern
              const existingPattern = appData.patterns[id];
              pattern.fileName = existingPattern.fileName;
              pattern.thumbnailPath = existingPattern.thumbnailPath;
              pattern.thumbnailHash = existingPattern.thumbnailHash;

              // Update existing pattern
              appData.patterns[id] = pattern;
            }
            // If not updateExisting, keep the existing pattern unchanged
          } else {
            // New pattern, just add it (note that thumbnailPath will be a URL that won't be valid)
            pattern.thumbnailPath = null; // Clear invalid thumbnail path
            pattern.thumbnailHash = null; // Clear hash since thumbnail is not available
            appData.patterns[id] = pattern;
          }
        }

        // Process creators
        for (const [id, creator] of Object.entries(importData.creators)) {
          if (appData.creators[id]) {
            // Merge pattern arrays without duplicates
            const existingCreator = appData.creators[id];
            creator.patterns = [
              ...new Set([...existingCreator.patterns, ...creator.patterns]),
            ];

            // Update creator info if updateExisting is true
            if (updateExisting) {
              creator.totalBackedUp = creator.patterns.length;
              appData.creators[id] = creator;
            } else {
              // Just update the patterns list
              existingCreator.patterns = creator.patterns;
              existingCreator.totalBackedUp = creator.patterns.length;
            }
          } else {
            // New creator, just add it
            appData.creators[id] = creator;
          }
        }

        // Process sets
        for (const [id, set] of Object.entries(importData.sets)) {
          if (appData.sets[id]) {
            // Merge pattern arrays without duplicates
            const existingSet = appData.sets[id];
            set.patterns = [
              ...new Set([...existingSet.patterns, ...set.patterns]),
            ];

            // Update set if updateExisting is true
            if (updateExisting) {
              appData.sets[id] = set;
            } else {
              // Just update the patterns list
              existingSet.patterns = set.patterns;
            }
          } else {
            // New set, just add it
            appData.sets[id] = set;
          }
        }

        // Process processed files list
        if (
          importData.processedFiles &&
          Array.isArray(importData.processedFiles)
        ) {
          importData.processedFiles.forEach((file) => {
            appData.processedFiles.add(file);
          });
        }

        // Update all patterns to make sure sets and creators are consistent
        updateRelationships();
      }

      // Replace existing data with imported data
      function replaceWithImportedData(importData) {
        // Replace patterns, but keep thumbnail references where possible
        const newPatterns = {};
        for (const [id, pattern] of Object.entries(importData.patterns)) {
          newPatterns[id] = pattern;

          // If pattern existed before, keep its thumbnail reference
          if (appData.patterns[id]) {
            newPatterns[id].thumbnailPath = appData.patterns[id].thumbnailPath;
            newPatterns[id].thumbnailHash = appData.patterns[id].thumbnailHash;
          } else {
            // Clear invalid thumbnail paths for new patterns
            newPatterns[id].thumbnailPath = null;
            newPatterns[id].thumbnailHash = null;
          }
        }

        // Replace everything with imported data
        appData.patterns = newPatterns;
        appData.creators = importData.creators;
        appData.sets = importData.sets;

        // Process processed files list
        if (
          importData.processedFiles &&
          Array.isArray(importData.processedFiles)
        ) {
          appData.processedFiles = new Set(importData.processedFiles);
        }

        // Update all patterns to make sure sets and creators are consistent
        updateRelationships();
      }

      // Update relationships between patterns, creators, and sets
      function updateRelationships() {
        // Ensure all patterns in sets have correct set references
        for (const [setId, set] of Object.entries(appData.sets)) {
          set.patterns.forEach((patternId, index) => {
            const pattern = appData.patterns[patternId];
            if (pattern) {
              pattern.setId = setId;
              pattern.setName = set.name;
              pattern.setOrder = index + 1;
            }
          });
        }

        // Ensure all patterns listed in creators exist
        for (const [creatorId, creator] of Object.entries(appData.creators)) {
          // Filter out non-existent patterns
          creator.patterns = creator.patterns.filter(
            (patternId) => appData.patterns[patternId]
          );
          creator.totalBackedUp = creator.patterns.length;
        }
      }

      // Export metadata
      function exportMetadata() {
        const exportData = {
          patterns: {},
          creators: appData.creators,
          sets: appData.sets,
          processedFiles: [...appData.processedFiles],
          appSettings: appSettings,
        };

        // Export patterns with both base64 and file paths for maximum compatibility
        for (const id in appData.patterns) {
          exportData.patterns[id] = { ...appData.patterns[id] };

          // If we have base64 data and original file path, include both
          if (
            appData.patterns[id].thumbnailPath &&
            appData.patterns[id].originalFilePath
          ) {
            exportData.patterns[id].thumbnailPathBase64 =
              appData.patterns[id].thumbnailPath;
            exportData.patterns[id].thumbnailPathFile =
              appData.patterns[id].originalFilePath;
          }
        }

        // Create download link
        const dataStr = JSON.stringify(exportData);
        const dataUri =
          "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);

        const exportFileName =
          "ac-pattern-metadata-" +
          new Date().toISOString().split("T")[0] +
          ".json";

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", dataUri);
        linkElement.setAttribute("download", exportFileName);
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);

        showNotification("Metadata exported successfully");
      }

      // Scan for duplicates
      async function scanForDuplicates() {
        const duplicatesContainer = elements.duplicatesContainer;
        duplicatesContainer.innerHTML =
          '<div class="loading"></div> Scanning for duplicates...';

        try {
          // Get all patterns with thumbnails or hashes
          const patterns = Object.values(appData.patterns).filter(
            (p) =>
              p.thumbnailHash ||
              (appSettings.storeThumbnailsAsBase64
                ? p.thumbnailPath
                : p.originalFilePath)
          );

          if (patterns.length === 0) {
            duplicatesContainer.innerHTML =
              "<p>No patterns with thumbnails available to scan.</p>";
            return;
          }

          // Generate hashes for patterns that don't have them yet
          const patternsWithoutHash = patterns.filter((p) => !p.thumbnailHash);

          if (patternsWithoutHash.length > 0) {
            duplicatesContainer.innerHTML =
              '<div class="loading"></div> Generating hashes for patterns...';

            for (const pattern of patternsWithoutHash) {
              try {
                // Use the appropriate thumbnail source
                const thumbnailSrc = appSettings.storeThumbnailsAsBase64
                  ? pattern.thumbnailPath
                  : pattern.originalFilePath;

                if (thumbnailSrc) {
                  pattern.thumbnailHash = await generateThumbnailHash(
                    thumbnailSrc
                  );
                }
              } catch (error) {
                console.error(
                  `Error generating hash for pattern ${pattern.id}:`,
                  error
                );
              }
            }

            // Save the newly generated hashes
            saveDataToLocalStorage();
          }

          // Group patterns by hash
          const hashedPatterns = {};
          patterns
            .filter((p) => p.thumbnailHash)
            .forEach((pattern) => {
              if (!hashedPatterns[pattern.thumbnailHash]) {
                hashedPatterns[pattern.thumbnailHash] = [];
              }
              hashedPatterns[pattern.thumbnailHash].push(pattern.id);
            });

          // Find duplicate sets (patterns with the same hash)
          const duplicates = Object.values(hashedPatterns).filter(
            (patternIds) => patternIds.length > 1
          );

          // Render results
          if (duplicates.length === 0) {
            duplicatesContainer.innerHTML =
              "<p>No duplicate patterns found.</p>";
          } else {
            duplicatesContainer.innerHTML = `
                <div class="success-message">Found ${duplicates.length} sets of duplicate patterns.</div>
                <div class="duplicate-sets-container"></div>
            `;

            const container = duplicatesContainer.querySelector(
              ".duplicate-sets-container"
            );

            // Render each duplicate set
            duplicates.forEach((set, index) => {
              const setDiv = document.createElement("div");
              setDiv.className = "duplicate-set";

              // Get patterns for this set
              const setPatterns = set
                .map((id) => appData.patterns[id])
                .filter((p) => p);

              setDiv.innerHTML = `
                    <div class="duplicate-set-header">
                        <h3>Duplicate Set #${index + 1}</h3>
                        <div class="similarity-info">
                            <span class="similarity-badge high">Exact Match</span>
                        </div>
                    </div>
                    <div class="duplicate-patterns">
                        ${setPatterns
                          .map(
                            (pattern) => `
                            <div class="duplicate-pattern" data-id="${
                              pattern.id
                            }">
                                <div class="pattern-preview">
                                    <img src="${pattern.thumbnailPath}" alt="${
                              pattern.patternName
                            }" class="pixel-art-image">
                                    <div class="pattern-select">
                                        <input type="radio" name="primary-${index}" value="${
                              pattern.id
                            }" 
                                            id="primary-${pattern.id}" ${
                              set.indexOf(pattern.id) === 0 ? "checked" : ""
                            }>
                                        <label for="primary-${
                                          pattern.id
                                        }">Primary</label>
                                    </div>
                                </div>
                                <div class="pattern-details">
                                    <div class="pattern-name">${
                                      pattern.patternName
                                    }</div>
                                    <div class="pattern-creator">by ${
                                      pattern.creatorName
                                    }</div>
                                    <div class="pattern-metadata">
                                        <span>Added: ${
                                          pattern.dateAdded || "Unknown"
                                        }</span>
                                        <span>${
                                          pattern.tags.length > 0
                                            ? `Tags: ${pattern.tags.join(", ")}`
                                            : "No tags"
                                        }</span>
                                        <span>${
                                          pattern.setName
                                            ? `In set: ${pattern.setName}`
                                            : "Not in a set"
                                        }</span>
                                    </div>
                                </div>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                    <div class="duplicate-actions">
                        <button class="btn" data-action="merge" data-set="${index}">Merge Selected as Primary</button>
                        <button class="btn btn-secondary" data-action="keep-all" data-set="${index}">Keep All as Related</button>
                        <button class="btn btn-secondary" data-action="ignore" data-set="${index}">Ignore</button>
                    </div>
                `;

              container.appendChild(setDiv);
            });

            // Add event listeners for action buttons
            container
              .querySelectorAll('[data-action="merge"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  const radioName = `primary-${setIndex}`;
                  const checkedRadio = container.querySelector(
                    `input[name="${radioName}"]:checked`
                  );

                  if (checkedRadio) {
                    const primaryId = checkedRadio.value;
                    const setIds = duplicates[setIndex];
                    mergeDuplicates(setIds, primaryId);
                  } else {
                    showNotification(
                      "Please select a primary pattern",
                      "error"
                    );
                  }
                });
              });

            container
              .querySelectorAll('[data-action="keep-all"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  keepAllDuplicates(duplicates[setIndex]);
                });
              });

            container
              .querySelectorAll('[data-action="ignore"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  const setDiv = button.closest(".duplicate-set");
                  setDiv.remove();

                  // Check if there are any sets left
                  if (
                    container.querySelectorAll(".duplicate-set").length === 0
                  ) {
                    duplicatesContainer.innerHTML =
                      "<p>No duplicate patterns found.</p>";
                  }
                });
              });
          }
        } catch (error) {
          console.error("Error scanning for duplicates:", error);
          duplicatesContainer.innerHTML = `<div class="error-message">Error scanning for duplicates: ${error.message}</div>`;
        }
      }

      // Compare two images for similarity
      async function compareImages(src1, src2, canvas, ctx) {
        return new Promise((resolve, reject) => {
          const img1 = new Image();
          const img2 = new Image();

          let img1Loaded = false;
          let img2Loaded = false;

          img1.onload = function () {
            img1Loaded = true;
            if (img2Loaded) compareLoaded();
          };

          img2.onload = function () {
            img2Loaded = true;
            if (img1Loaded) compareLoaded();
          };

          img1.onerror = img2.onerror = function () {
            reject(new Error("Error loading image for comparison"));
          };

          function compareLoaded() {
            try {
              // Draw first image
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img1, 0, 0, canvas.width, canvas.height);
              const data1 = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Draw second image
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img2, 0, 0, canvas.width, canvas.height);
              const data2 = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Compare pixel data
              let diff = 0;
              let total = data1.length;

              for (let i = 0; i < total; i += 4) {
                // Calculate color difference in RGB channels
                diff += Math.abs(data1[i] - data2[i]); // R
                diff += Math.abs(data1[i + 1] - data2[i + 1]); // G
                diff += Math.abs(data1[i + 2] - data2[i + 2]); // B
              }

              // Calculate average difference per pixel
              const avgDiff = diff / (total / 4);

              // Consider images equal if the difference is below threshold
              // Adjust this threshold based on your needs
              resolve(avgDiff < 10);
            } catch (error) {
              reject(error);
            }
          }

          // Set image sources to start loading
          img1.src = src1;
          img2.src = src2;
        });
      }

      // Merge duplicate patterns
      async function mergeDuplicates(patternIds, primaryId) {
        if (!patternIds || patternIds.length < 2) return;

        // Find primary pattern
        const primary = appData.patterns[primaryId];
        if (!primary) return;

        // Move primary to beginning of array (if not already)
        patternIds = [
          primaryId,
          ...patternIds.filter((id) => id !== primaryId),
        ];

        // Collect tags from all duplicates
        const allTags = new Set(primary.tags);

        // Process each duplicate
        for (let i = 1; i < patternIds.length; i++) {
          const duplicateId = patternIds[i];
          const duplicate = appData.patterns[duplicateId];

          if (!duplicate) continue;

          // Collect tags
          duplicate.tags.forEach((tag) => allTags.add(tag));

          // If the duplicate is in a set but the primary isn't, move primary to that set
          if (duplicate.setId && !primary.setId) {
            primary.setId = duplicate.setId;
            primary.setName = duplicate.setName;
            primary.setOrder = duplicate.setOrder;

            // Update set data
            const set = appData.sets[duplicate.setId];
            if (set) {
              set.patterns = set.patterns.map((id) =>
                id === duplicateId ? primaryId : id
              );
            }
          }

          // Combine notes if any
          if (duplicate.notes && duplicate.notes !== primary.notes) {
            primary.notes = primary.notes
              ? primary.notes + "\n\nFrom merged pattern: " + duplicate.notes
              : "From merged pattern: " + duplicate.notes;
          }

          // Keep thumbnail data if primary doesn't have it
          if (appSettings.storeThumbnailsAsBase64) {
            if (!primary.thumbnailPath && duplicate.thumbnailPath) {
              primary.thumbnailPath = duplicate.thumbnailPath;
            }
          }

          // Keep original file path if primary doesn't have it
          if (!primary.originalFilePath && duplicate.originalFilePath) {
            primary.originalFilePath = duplicate.originalFilePath;
          }

          // Remove from creator's patterns
          const creatorId = Object.keys(appData.creators).find((cid) =>
            appData.creators[cid].patterns.includes(duplicateId)
          );

          if (creatorId && appData.creators[creatorId]) {
            appData.creators[creatorId].patterns = appData.creators[
              creatorId
            ].patterns.filter((id) => id !== duplicateId);
            appData.creators[creatorId].totalBackedUp =
              appData.creators[creatorId].patterns.length;
          }

          // Delete the duplicate pattern
          delete appData.patterns[duplicateId];
        }

        // Update the primary pattern with all collected tags
        primary.tags = [...allTags];
        primary.lastModified = new Date().toISOString().split("T")[0];

        // Save data
        saveDataToLocalStorage();

        // Refresh views
        scanForDuplicates();
        renderPatternGallery();
        renderSidebarFilters();

        showNotification("Duplicate patterns merged successfully");
      }

      // Keep all duplicate patterns but mark them as related
      function keepAllDuplicates(patternIds) {
        if (!patternIds || patternIds.length < 2) return;

        // Update each pattern to reference others as related
        patternIds.forEach((id) => {
          const pattern = appData.patterns[id];
          if (!pattern) return;

          // Set related patterns (excluding self)
          pattern.relatedPatterns = patternIds.filter((pid) => pid !== id);
          pattern.lastModified = new Date().toISOString().split("T")[0];
        });

        // Save data
        saveDataToLocalStorage();

        // Refresh views
        scanForDuplicates();

        showNotification("Patterns marked as related");
      }

      // Function to add the "Add Creator" button to the creator tab
      function addCreateCreatorButton() {
        const creatorActionBar = document.querySelector(
          "#creators .action-bar"
        );
        const createBtn = document.createElement("button");
        createBtn.id = "create-creator-btn";
        createBtn.className = "btn create-creator-btn";
        createBtn.textContent = "Add Creator";
        createBtn.addEventListener("click", openCreateCreatorModal);

        creatorActionBar.appendChild(createBtn);
      }

      // 4. Create the Creator form modal
      function createCreatorModal() {
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.id = "creator-modal";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title" id="creator-modal-title">Add New Creator</h2>
            
            <div class="form-group">
              <label for="creator-name-input">Creator Name*</label>
              <input type="text" id="creator-name-input" required>
            </div>
            
            <div class="form-group">
              <label for="creator-town-input">Town Name*</label>
              <input type="text" id="creator-town-input" required>
            </div>
            
            <div class="form-group">
              <label for="creator-code-input">Creator Code</label>
              <input type="text" id="creator-code-input" placeholder="MA-####-####-####" pattern="MA-\\d{4}-\\d{4}-\\d{4}">
              <p class="help-text">Format: MA-####-####-#### (e.g., MA-1234-5678-9012)</p>
            </div>
            
            <div class="form-group">
              <label for="creator-rank-input">Creator Rank</label>
              <select id="creator-rank-input">
                <option value="unknown">Unknown (Default)</option>
                <option value="verified">Verified (Original Creator)</option>
                <option value="plagiarist">Plagiarist (Copies Others' Work)</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="creator-total-input">Total Patterns</label>
              <input type="number" id="creator-total-input" min="0" value="0">
              <p class="help-text">Set the total number of patterns this creator has made (if known).</p>
            </div>
            
            <div class="form-group">
              <label for="creator-complete-input">Collection Status</label>
              <select id="creator-complete-input">
                <option value="false" selected>Incomplete</option>
                <option value="true">Complete</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="creator-notes-input">Notes</label>
              <textarea id="creator-notes-input" rows="4"></textarea>
            </div>
            
            <button class="btn" id="save-creator-btn">Save Creator</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Set up the close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Set up the save button
        modal
          .querySelector("#save-creator-btn")
          .addEventListener("click", saveCreator);

        // Add creator code formatter
        const creatorCodeInput = modal.querySelector("#creator-code-input");
        creatorCodeInput.addEventListener("input", formatCreatorCode);

        return modal;
      }

      // 5. Format creator code as user types (MA-####-####-####)
      function formatCreatorCode(e) {
        const input = e.target;
        let value = input.value.replace(/[^A-Ma-m0-9]/g, "").toUpperCase();

        // Make sure it starts with MA
        if (value.length >= 2 && value.substring(0, 2) !== "MA") {
          value =
            "MA" + value.substring(value.length - Math.min(value.length, 12));
        } else if (value.length < 2) {
          value = value.padStart(2, "M");
        }

        // Format with dashes
        if (value.length > 2) {
          let formatted = value.substring(0, 2) + "-";

          // Add first group of digits
          const firstGroup = value.substring(2, 6);
          formatted += firstGroup;

          // Add second group if we have it
          if (value.length > 6) {
            formatted += "-" + value.substring(6, 10);

            // Add third group if we have it
            if (value.length > 10) {
              formatted += "-" + value.substring(10, 14);
            }
          }

          value = formatted;
        }

        input.value = value;
      }

      // 6. Open Creator Modal for adding a new creator
      function openCreateCreatorModal() {
        const modal = createCreatorModal();
        modal.style.display = "flex";
        document.getElementById("creator-modal-title").textContent =
          "Add New Creator";
        document.getElementById("creator-name-input").focus();
      }

      // 7. Save a new or edited creator
      function saveCreator() {
        const nameInput = document.getElementById("creator-name-input");
        const townInput = document.getElementById("creator-town-input");

        // Validate required fields
        if (!nameInput.value.trim() || !townInput.value.trim()) {
          showNotification(
            "Creator Name and Town Name are required fields",
            "error"
          );
          return;
        }

        const name = nameInput.value.trim();
        const town = townInput.value.trim();
        const code = document.getElementById("creator-code-input").value.trim();
        const rank = document.getElementById("creator-rank-input").value;
        const total =
          parseInt(document.getElementById("creator-total-input").value) || 0;
        const isComplete =
          document.getElementById("creator-complete-input").value === "true";
        const notes = document
          .getElementById("creator-notes-input")
          .value.trim();

        // Generate creator ID
        const creatorId =
          document.getElementById("save-creator-btn").getAttribute("data-id") ||
          "creator-" +
            name.toLowerCase().replace(/[^a-z0-9]/g, "-") +
            "-" +
            town.toLowerCase().replace(/[^a-z0-9]/g, "-") +
            "-" +
            Date.now();

        // Check for existing creator with same name+town
        const existingCreator = Object.values(appData.creators).find(
          (c) =>
            c.name.toLowerCase() === name.toLowerCase() &&
            c.townName.toLowerCase() === town.toLowerCase() &&
            c.id !== creatorId
        );

        if (existingCreator) {
          showNotification(
            "A creator with this name and town already exists",
            "error"
          );
          return;
        }

        // Create or update the creator
        appData.creators[creatorId] = {
          id: creatorId,
          name: name,
          townName: town,
          creatorCode: code,
          rank: rank,
          patterns: appData.creators[creatorId]?.patterns || [],
          totalBackedUp: appData.creators[creatorId]?.totalBackedUp || 0,
          totalPatterns: total,
          isComplete: isComplete,
          notes: notes,
        };

        // Save to localStorage
        saveDataToLocalStorage();

        // Close the modal
        const modal = document.getElementById("creator-modal");
        document.body.removeChild(modal);

        // Refresh creators view
        renderCreators();

        // Refresh pattern gallery to update badges
        renderPatternGallery();

        showNotification("Creator saved successfully");
      }

      // Show notification
      function showNotification(message, type = "success") {
        const notification = elements.notification;
        notification.textContent = message;
        notification.className = "notification show " + type;

        setTimeout(() => {
          notification.classList.remove("show");
        }, 3000);
      }

      // Debounce function for search input
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      // Initialize the app
      document.addEventListener("DOMContentLoaded", initApp);
    </script>
  </body>
</html>
