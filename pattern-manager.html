<!--
CURRENT BUG LIST (address later)
[ ] When reverting back to Base64 encoded thumbnails from dynamic loading,
      thumbnails do not properly generate (all patterns show "No Thumbnail").
[ ] The 'create set' button should be disabled when selected patterns are from multiple creators.
[ ] The vertical/horizontal grids are flipped IMO. 3x1 should mean 3 columns, 1 row and right now
      it means the opposite!
[ ] Creators alphabetical and pattern # are opposite so the arrows don't really work for both...
[ ] Should probably integrate the TownID and the PlayerID from the NHD file into the program's
      creator ID to ensure that creators with the same name & town name (but presumably
      different IDs) don't get merged
[ ] The duplicate detection UI is currently bugged after handling an unclear number of items
[ ] Add Patterns modal doesn't properly enforce that sets must only have patterns from the same
      creator (lets you add patterns of two creators to one set when creating for 1st time)
[ ] Clicking outside a modal should close it
[ ] Clicking on a set in select mode should open the edit set modal
[ ] pattern set selection action thingy shouldn't appear on other tabs at all
[ ] set order should account for # of empty spaces & those should sort before full sets
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="./pattern-manager/favicon.svg"
      type="image/svg+xml"
    />
    <title>ACNH Custom Pattern Manager友</title>
    <link rel="stylesheet" href="./pattern-manager/css/main.css" />
    <link rel="stylesheet" href="./pattern-manager/css/header.css" />
    <link rel="stylesheet" href="./pattern-manager/css/sidebar.css" />
    <link rel="stylesheet" href="./pattern-manager/css/action-bar.css" />
    <link rel="stylesheet" href="./pattern-manager/css/pattern-gallery.css" />
    <link rel="stylesheet" href="./pattern-manager/css/sets.css" />
    <link rel="stylesheet" href="./pattern-manager/css/creators.css" />
    <link rel="stylesheet" href="./pattern-manager/css/duplicates.css" />
  </head>
  <body>
    <div class="app-header-container">
      <header>
        <div class="logo">
          <img
            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMjYuMjQgMzExLjA3Ij48cGF0aCBmaWxsPSIjMWFhZTVlIiBkPSJNMjY2LjM4IDEuMjZjLS45MyA5LjEyLTcuNzEgNDcuMjEtMjcuMjggODMuNDRhMSAxIDAgMCAxLTEuNy0uMDZjLTQtOC4yNC0yNC44Ni00NC41OC03OS4yOS00NC45MUM5Ni43MSAzOS4zNSA2Ni42NyA4NyA2Ni42NyA4N3MtMjMuNDUgMzIuOTMtMzMuNDkgOTQuODktMjIuNjEgNzktMjIuNjEgNzlMLjM5IDI3N2EyLjU0IDIuNTQgMCAwIDAgMS4xMSAzLjY3YzEzIDUuODEgNzIuNjggMzAuMzggMTUxLjY4IDMwLjM4IDUzLjggMCA3MC03LjU4IDc0LjI1LTEwLjU1YS42MS42MSAwIDAgMC0uMzUtMS4xMmMtMTAuNTUgMS4xNi01MS4yLTUuMjYtNTEuMi00NCAwLTM0Ljc5IDI1LjMtNTEuNjIgNTEuODEtNTIuODMgMTIuNTYtLjU4IDM5LjM1IDQuNzQgNDcuNzIgMjkuMyA3IDIwLjY2LTIuMzEgMzkuMTUtNS40NSA0NC41YS42Mi42MiAwIDAgMCAuNzcuODljOS41Mi0zLjg0IDUzLjcxLTI1Ljc3IDU1LjQ3LTkzLjk1IDEuNTUtNTkuOTEtNDcuNjQtODUuNjItNzAuOC04Ni43MWExLjE4IDEuMTggMCAwIDEtMS0xLjYyYzYuMjMtMTUuOTQgNDUtNTcuMjcgNTEuODQtNjQuNDZhMS41NyAxLjU3IDAgMCAwIDAtMi4xN0ExNTkuMDUgMTU5LjA1IDAgMCAwIDI2OC40Ni4xN2ExLjQyIDEuNDIgMCAwIDAtMi4wOCAxLjA5WiIvPjwvc3ZnPg=="
            alt="Animal Crossing Leaf Logo"
          />
          <h1>ACNH Custom Pattern Manager</h1>
        </div>
        <div class="header-actions">
          <button id="import-btn" class="btn">Import Patterns</button>
        </div>
      </header>

      <nav>
        <ul class="nav-tabs">
          <li class="active" data-tab="patterns">Patterns</li>
          <li data-tab="sets">Sets</li>
          <li data-tab="creators">Creators</li>
          <li data-tab="duplicates">Duplicates</li>
        </ul>
      </nav>
    </div>
    <div class="container">
      <div id="patterns" class="tab-content active">
        <div class="action-bar">
          <div class="search-bar">
            <input
              type="text"
              id="pattern-search"
              placeholder="Search patterns..."
            />
            <button class="btn">Search</button>
          </div>
          <div class="sort-dropdown-container">
            <button
              id="sort-dropdown-button"
              class="btn btn-secondary sort-dropdown-button"
            >
              Sort: Alphabetical <span class="dropdown-arrow">▼</span>
            </button>
            <div class="sort-dropdown-menu">
              <div
                class="sort-option active"
                data-sort="alphabetical"
                data-direction="asc"
              >
                <span class="sort-icon">↓</span> Alphabetical
              </div>
              <div
                class="sort-option"
                data-sort="set-size"
                data-direction="asc"
              >
                <span class="sort-icon">↓</span> Set Size
              </div>
              <div class="sort-option" data-sort="tag" data-direction="asc">
                <span class="sort-icon">↓</span> Group by 🏷️
              </div>
              <div class="sort-option" data-sort="creator" data-direction="asc">
                <span class="sort-icon">↓</span> Group by 🎨
              </div>
              <hr />
              <div class="sort-option-setting">
                <label class="show-all-tags-label">
                  <input type="checkbox" id="show-all-tags" disabled />
                  Show patterns under all relevant tags
                </label>
              </div>
            </div>
          </div>
        </div>

        <div class="main-content">
          <div class="sidebar">
            <div class="sidebar-section">
              <h3 class="sidebar-title">🏷️ Tags</h3>
              <ul class="sidebar-list" id="tag-filters">
                <!-- Tags will be inserted here -->
              </ul>
            </div>
            <div class="sidebar-section collapsed">
              <h3 class="sidebar-title collapsed">🎨 Creators</h3>
              <ul class="sidebar-list" id="creator-filters">
                <!-- Creators will be inserted here -->
              </ul>
            </div>
            <!-- <div class="sidebar-section">
              <h3 class="sidebar-title">Sets</h3>
              <ul class="sidebar-list" id="set-filters">
                <li>Star Collection <span class="filter-count">3</span></li>
                <li>Path Set <span class="filter-count">6</span></li>
              </ul>
            </div> -->
          </div>

          <div class="content-area">
            <div class="pattern-gallery" id="pattern-gallery">
              <!-- Pattern cards will be inserted here -->
            </div>
          </div>
        </div>
      </div>

      <div id="sets" class="tab-content">
        <div class="action-bar">
          <div class="search-bar">
            <input type="text" id="set-search" placeholder="Search sets..." />
            <button class="btn">Search</button>
          </div>
          <div>
            <button id="create-set-btn" class="btn">Create New Set</button>
          </div>
        </div>

        <div class="set-manager" id="set-manager">
          <!-- Set items will be inserted here -->
        </div>
      </div>

      <div id="creators" class="tab-content">
        <div class="action-bar">
          <div class="search-bar">
            <input
              type="text"
              id="creator-search"
              placeholder="Search creators..."
            />
            <button class="btn">Search</button>
          </div>
        </div>

        <div id="creator-list">
          <!-- Creator items will be inserted here -->
        </div>
      </div>

      <div id="duplicates" class="tab-content">
        <div class="action-bar">
          <button id="scan-duplicates-btn" class="btn">
            Scan for Duplicates
          </button>
        </div>

        <div id="duplicates-container">
          <p>No duplicate patterns detected.</p>
        </div>
      </div>
    </div>

    <!-- Pattern Details Modal -->
    <div class="modal-backdrop" id="pattern-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Pattern Details</h2>
        <div class="pattern-detail">
          <div class="pattern-image">
            <img id="modal-pattern-img" src="" alt="Pattern" />
          </div>
          <div class="pattern-details">
            <div class="form-group">
              <label for="pattern-name">Pattern Name</label>
              <input type="text" id="pattern-name" disabled />
            </div>
            <div class="form-group">
              <label for="pattern-alternate-name">Alternate Name</label>
              <input
                type="text"
                id="pattern-alternate-name"
                placeholder="Optional alternate/translated name"
              />
            </div>
            <div class="form-group">
              <label for="creator-name">Creator</label>
              <input type="text" id="creator-name" disabled />
            </div>
            <div class="form-group">
              <label for="town-name">Town</label>
              <input type="text" id="town-name" disabled />
            </div>
            <div class="form-group">
              <label for="pattern-tags">Tags</label>
              <div class="tag-input" id="tag-input">
                <!-- Tags will be inserted here -->
                <input type="text" placeholder="Add a tag..." />
              </div>
            </div>
            <div class="form-group">
              <label for="pattern-set">Set</label>
              <select id="pattern-set">
                <option value="">None</option>
                <!-- Set options will be inserted here -->
              </select>
            </div>
            <div class="form-group">
              <label for="set-order">Set Order</label>
              <input type="number" id="set-order" min="1" />
            </div>
            <div class="form-group full-width">
              <label for="pattern-notes">Notes</label>
              <textarea id="pattern-notes" rows="3"></textarea>
            </div>
            <button class="btn" id="save-pattern-btn">Save Changes</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Create Set Modal -->
    <div class="modal-backdrop" id="set-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Create New Set</h2>
        <div class="form-group">
          <label for="set-name">Set Name</label>
          <input type="text" id="set-name" />
        </div>
        <div class="form-group">
          <label for="set-grid-size">Grid Size (Optional)</label>
          <select id="set-grid-size">
            <option value="">No Grid (Pattern Collection)</option>
            <option value="2x2">2 × 2 Grid</option>
            <option value="3x3">3 × 3 Grid</option>
            <option value="4x4">4 × 4 Grid</option>
            <option value="1x2">1 × 2 Grid (Horiz)</option>
            <option value="1x3">1 × 3 Grid (Horiz)</option>
            <option value="1x4">1 × 4 Grid (Horiz)</option>
            <option value="2x3">2 × 3 Grid (Horiz)</option>
            <option value="2x4">2 × 4 Grid (Horiz)</option>
            <option value="2x1">2 × 1 Grid (Vert)</option>
            <option value="3x1">3 × 1 Grid (Vert)</option>
            <option value="4x1">4 × 1 Grid (Vert)</option>
          </select>
          <p class="help-text">
            Select a grid size if this set forms a larger image when combined,
            or leave as "No Grid" if it's just a collection.
          </p>
        </div>
        <div class="form-group full-width">
          <label for="set-notes">Notes</label>
          <textarea id="set-notes" rows="3"></textarea>
        </div>
        <button class="btn" id="save-set-btn">Create Set</button>
      </div>
    </div>

    <!-- Import Patterns Modal -->
    <div class="modal-backdrop" id="import-modal">
      <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Import Patterns</h2>
        <div class="form-group full-width">
          <label for="pattern-folder">Select Pattern Folder</label>
          <input
            type="file"
            id="pattern-folder"
            webkitdirectory
            directory
            multiple
          />
        </div>
        <div id="import-status" class="full-width"></div>
        <button class="btn" id="start-import-btn">Import Patterns</button>
      </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
      Operation completed successfully.
    </div>

    <script>
      // Main app data store
      const appData = {
        patterns: {},
        creators: {},
        sets: {},
        processedFiles: new Set(),
        activeFilters: {
          tags: new Set(),
          creators: new Set(),
          sets: new Set(),
          search: "",
          untagged: false,
        },
        selectionMode: false,
        selectedPatterns: new Set(),
      };

      // Global settings object
      const appSettings = {
        storeThumbnailsAsBase64: false,
        lastImportDirectory: "",
      };

      // DOM Elements
      const elements = {
        tabs: document.querySelectorAll(".nav-tabs li"),
        tabContents: document.querySelectorAll(".tab-content"),
        patternGallery: document.getElementById("pattern-gallery"),
        patternModal: document.getElementById("pattern-modal"),
        setModal: document.getElementById("set-modal"),
        importModal: document.getElementById("import-modal"),
        notification: document.getElementById("notification"),
        modalCloseButtons: document.querySelectorAll(".modal-close"),
        importBtn: document.getElementById("import-btn"),
        exportBtn: document.getElementById("export-btn"),
        createSetBtn: document.getElementById("create-set-btn"),
        savePatternBtn: document.getElementById("save-pattern-btn"),
        saveSetBtn: document.getElementById("save-set-btn"),
        startImportBtn: document.getElementById("start-import-btn"),
        scanDuplicatesBtn: document.getElementById("scan-duplicates-btn"),
        patternSearch: document.getElementById("pattern-search"),
        setManager: document.getElementById("set-manager"),
        creatorList: document.getElementById("creator-list"),
        duplicatesContainer: document.getElementById("duplicates-container"),
        tagFilters: document.getElementById("tag-filters"),
        creatorFilters: document.getElementById("creator-filters"),
        setFilters: document.getElementById("set-filters"),
      };

      // Initialize the application
      function initApp() {
        loadDataFromLocalStorage();
        loadAppSettings();
        setupEventListeners();
        setupMetadataImport();
        setupAppSettings();
        renderPatternGallery();
        setupMultiSelectUI();
        renderSidebarFilters();
        enhanceFiltering();
        addBackToTopButton();
        addCreateCreatorButton();
        initSorting();
        initCreatorSorting();
        setupCollapsibleSidebar();
        setupCreatorSearch();
        setupSetSearch();
      }

      function getPatternThumbnailSrc(pattern) {
        // If we're storing base64 data and it exists, use it
        if (appSettings.storeThumbnailsAsBase64 && pattern.encodedThumbnail) {
          return pattern.encodedThumbnail;
        }

        // If we're using relative paths and thumbnailPath exists, use it
        if (!appSettings.storeThumbnailsAsBase64 && pattern.thumbnailPath) {
          // URL encode the # character in the path
          return pattern.thumbnailPath.replace(/#/g, "%23");
        }

        // Fallback to placeholder image if no valid thumbnail source found
        return "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMjAwIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjhmOCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTk5Ij5ObyBUaHVtYm5haWw8L3RleHQ+PC9zdmc+";
      }

      function generateCreatorId(creatorName, townName, addTimestamp = false) {
        // First, normalize the strings to handle unicode variations
        const normalizedCreator = creatorName.normalize("NFC");
        const normalizedTown = townName.normalize("NFC");

        // Generate a more consistent ID using base64 encoding
        // This avoids issues with different character encodings
        const creatorPart = btoa(
          unescape(encodeURIComponent(normalizedCreator))
        )
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");

        const townPart = btoa(unescape(encodeURIComponent(normalizedTown)))
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");

        let id = `creator-${creatorPart}-${townPart}`;

        // Add timestamp if requested (for manually created creators)
        if (addTimestamp) {
          id += `-${Date.now()}`;
        }

        return id;
      }

      // Load data from localStorage
      function loadDataFromLocalStorage() {
        try {
          const storedPatterns = localStorage.getItem("acPatterns");
          const storedCreators = localStorage.getItem("acCreators");
          const storedSets = localStorage.getItem("acSets");
          const storedProcessedFiles = localStorage.getItem("acProcessedFiles");

          if (storedPatterns) appData.patterns = JSON.parse(storedPatterns);
          if (storedCreators) appData.creators = JSON.parse(storedCreators);
          if (storedSets) appData.sets = JSON.parse(storedSets);
          if (storedProcessedFiles) {
            appData.processedFiles = new Set(JSON.parse(storedProcessedFiles));
          }
        } catch (error) {
          console.error("Error loading data from localStorage:", error);
          showNotification(
            "Error loading saved data. Starting fresh.",
            "error"
          );
        }
      }

      // Save data to localStorage
      function saveDataToLocalStorage() {
        try {
          const patternIds = Object.keys(appData.patterns);
          if (patternIds.length > 0) {
            const sampleId = patternIds[0];
            console.log(
              `Sample pattern ${sampleId} hash before saving: ${appData.patterns[sampleId].fileHash}`
            );
          }
          // If not storing base64 thumbnails, create a copy of patterns without the base64 data
          if (!appSettings.storeThumbnailsAsBase64) {
            const patternsForStorage = {};

            for (const id in appData.patterns) {
              const pattern = { ...appData.patterns[id] };

              // Clear base64 data before storing
              if (
                pattern.encodedThumbnail &&
                pattern.encodedThumbnail.startsWith("data:")
              ) {
                pattern.encodedThumbnail = null;
              }

              patternsForStorage[id] = pattern;
            }

            localStorage.setItem(
              "acPatterns",
              JSON.stringify(patternsForStorage)
            );
          } else {
            // Store as is with base64 data
            localStorage.setItem(
              "acPatterns",
              JSON.stringify(appData.patterns)
            );
          }

          // Save other data as before
          localStorage.setItem("acCreators", JSON.stringify(appData.creators));
          localStorage.setItem("acSets", JSON.stringify(appData.sets));
          localStorage.setItem(
            "acProcessedFiles",
            JSON.stringify([...appData.processedFiles])
          );
        } catch (error) {
          console.error("Error saving data to localStorage:", error);
          showNotification(
            "Error saving data. Please export your metadata as backup.",
            "error"
          );
        }
      }

      // Setup event listeners
      function setupEventListeners() {
        // Tab navigation
        elements.tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            const tabId = tab.getAttribute("data-tab");
            elements.tabs.forEach((t) => t.classList.remove("active"));
            elements.tabContents.forEach((tc) => tc.classList.remove("active"));
            tab.classList.add("active");
            document.getElementById(tabId).classList.add("active");

            // Render tab-specific content
            if (tabId === "sets") {
              renderSets();
            } else if (tabId === "creators") {
              renderCreators();
            }
          });
        });

        // Modal close buttons
        elements.modalCloseButtons.forEach((button) => {
          button.addEventListener("click", () => {
            elements.patternModal.style.display = "none";
            elements.setModal.style.display = "none";
            elements.importModal.style.display = "none";
          });
        });

        // Button event listeners
        elements.importBtn.addEventListener("click", () => {
          elements.importModal.style.display = "flex";
        });

        elements.createSetBtn.addEventListener("click", () => {
          elements.setModal.style.display = "flex";
        });

        elements.savePatternBtn.addEventListener("click", savePatternChanges);
        elements.saveSetBtn.addEventListener("click", createNewSet);
        elements.startImportBtn.addEventListener("click", importPatterns);
        elements.scanDuplicatesBtn.addEventListener("click", scanForDuplicates);

        // Search input
        elements.patternSearch.addEventListener(
          "input",
          debounce(function () {
            appData.activeFilters.search = this.value.trim().toLowerCase();
            renderPatternGallery();
            updateActiveFilterDisplay();
          }, 300)
        );
      }

      // Setup search functionality for creators
      function setupCreatorSearch() {
        const searchInput = document.getElementById("creator-search");

        searchInput.addEventListener(
          "input",
          debounce(function () {
            const searchTerm = this.value.trim().toLowerCase();

            // Get all creator cards
            const creatorCards = document.querySelectorAll(
              "#creator-list .creator-card"
            );

            creatorCards.forEach((card) => {
              const creatorName = card
                .querySelector("h3")
                .textContent.toLowerCase();
              const townName = card
                .querySelector(".detail-value")
                .textContent.toLowerCase();
              const creatorCode =
                card
                  .querySelector(".creator-code")
                  ?.textContent.toLowerCase() || "";
              const notes =
                card
                  .querySelector(".creator-notes")
                  ?.textContent.toLowerCase() || "";

              // Check if any of the creator's data matches the search term
              const isMatch =
                creatorName.includes(searchTerm) ||
                townName.includes(searchTerm) ||
                creatorCode.includes(searchTerm) ||
                notes.includes(searchTerm);

              // Show or hide based on match
              card.style.display = isMatch ? "flex" : "none";
            });

            // Show a message if no creators match
            const noResultsMsg = document.getElementById("no-creator-results");
            if (
              !noResultsMsg &&
              Array.from(creatorCards).every(
                (card) => card.style.display === "none"
              )
            ) {
              const msg = document.createElement("p");
              msg.id = "no-creator-results";
              msg.textContent = "No creators match your search.";
              document.getElementById("creator-list").appendChild(msg);
            } else if (
              noResultsMsg &&
              Array.from(creatorCards).some(
                (card) => card.style.display === "flex"
              )
            ) {
              noResultsMsg.remove();
            }
          }, 300)
        );

        // Setup search button click
        const searchButton = searchInput.nextElementSibling;
        if (searchButton && searchButton.tagName === "BUTTON") {
          searchButton.addEventListener("click", function () {
            // Trigger the input event to perform the search
            const event = new Event("input", { bubbles: true });
            searchInput.dispatchEvent(event);
          });
        }
      }

      // Setup search functionality for sets
      function setupSetSearch() {
        const searchInput = document.getElementById("set-search");

        searchInput.addEventListener(
          "input",
          debounce(function () {
            const searchTerm = this.value.trim().toLowerCase();

            // Get all set items
            const setItems = document.querySelectorAll(
              "#set-manager .set-item"
            );

            setItems.forEach((item) => {
              const setName = item
                .querySelector("h3")
                .textContent.toLowerCase();
              const setNotes = item
                .querySelector("p")
                .textContent.toLowerCase();
              const patterns = Array.from(
                item.querySelectorAll(".set-pattern")
              ).map(
                (pattern) => pattern.getAttribute("title")?.toLowerCase() || ""
              );

              // Check if the set name, notes, or any pattern name matches the search term
              const isMatch =
                setName.includes(searchTerm) ||
                setNotes.includes(searchTerm) ||
                patterns.some((pattern) => pattern.includes(searchTerm));

              // Show or hide based on match
              item.style.display = isMatch ? "block" : "none";
            });

            // Show a message if no sets match
            const noResultsMsg = document.getElementById("no-set-results");
            if (
              !noResultsMsg &&
              Array.from(setItems).every(
                (item) => item.style.display === "none"
              )
            ) {
              const msg = document.createElement("p");
              msg.id = "no-set-results";
              msg.textContent = "No sets match your search.";
              document.getElementById("set-manager").appendChild(msg);
            } else if (
              noResultsMsg &&
              Array.from(setItems).some(
                (item) => item.style.display === "block"
              )
            ) {
              noResultsMsg.remove();
            }
          }, 300)
        );

        // Setup search button click
        const searchButton = searchInput.nextElementSibling;
        if (searchButton && searchButton.tagName === "BUTTON") {
          searchButton.addEventListener("click", function () {
            // Trigger the input event to perform the search
            const event = new Event("input", { bubbles: true });
            searchInput.dispatchEvent(event);
          });
        }
      }

      function addBackToTopButton() {
        // Create the button
        const backToTopBtn = document.createElement("button");
        backToTopBtn.id = "back-to-top-btn";
        backToTopBtn.innerHTML = "↑";
        backToTopBtn.title = "Back to Top";
        backToTopBtn.setAttribute("aria-label", "Back to Top");
        document.body.appendChild(backToTopBtn);

        // Add scroll event listener to show/hide button
        window.addEventListener("scroll", () => {
          if (window.scrollY > 300) {
            backToTopBtn.classList.add("visible");
          } else {
            backToTopBtn.classList.remove("visible");
          }
        });

        // Add click event to scroll to top
        backToTopBtn.addEventListener("click", () => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        });
      }

      function enhanceFiltering() {
        // Add initialization for active filters display
        updateActiveFilterDisplay();

        // Update the Setup event listeners function to include the pattern search input
        const originalPatternSearchListener = elements.patternSearch.onInput;
        elements.patternSearch.addEventListener(
          "input",
          debounce(function () {
            appData.activeFilters.search = this.value.trim().toLowerCase();
            renderPatternGallery();
            updateActiveFilterDisplay();
          }, 300)
        );
      }

      // Render pattern gallery
      function renderPatternGallery() {
        const gallery = elements.patternGallery;
        gallery.innerHTML = "";

        // Track which patterns are in sets to avoid duplicates
        const patternsInRenderedSets = new Set();

        // Get current sort settings
        const sort = appData.activeSort || {
          type: "alphabetical",
          direction: "asc",
        };

        // Get all patterns
        const allPatterns = Object.values(appData.patterns);
        const filteredPatterns = filterPatterns(allPatterns);

        // Check if we have any patterns at all
        const hasAnyPatterns = Object.keys(appData.patterns).length > 0;

        // Check if any filters are active
        const hasActiveFilters =
          appData.activeFilters.tags.size > 0 ||
          appData.activeFilters.creators.size > 0 ||
          appData.activeFilters.sets.size > 0 ||
          appData.activeFilters.search ||
          appData.activeFilters.untagged;

        // Filter visible sets
        const visibleSets = Object.values(appData.sets).filter((set) => {
          // Skip empty sets
          if (!set.patterns || set.patterns.length === 0) return false;

          // For untagged filter, check if any pattern in the set is untagged
          if (appData.activeFilters.untagged) {
            // Check if any pattern in the set has no tags
            const hasUntaggedPattern = set.patterns.some((patternId) => {
              const pattern = appData.patterns[patternId];
              return pattern && pattern.tags.length === 0;
            });

            if (!hasUntaggedPattern) {
              return false; // Skip this set if it has no untagged patterns
            }
          }

          // For sets with a creator filter, check if any pattern in the set matches
          if (appData.activeFilters.creators.size > 0) {
            // Get the first pattern to check its creator
            const firstPatternId = set.patterns[0];
            const pattern = appData.patterns[firstPatternId];
            if (!pattern) return false;

            if (
              !appData.activeFilters.creators.has(
                pattern.creatorName.toLowerCase()
              )
            ) {
              return false;
            }
          }

          // For sets with a set filter, check if this set matches
          if (appData.activeFilters.sets.size > 0) {
            if (!appData.activeFilters.sets.has(set.name.toLowerCase())) {
              return false;
            }
          }

          // For tag filters, check if any pattern in the set has the tag
          if (appData.activeFilters.tags.size > 0) {
            // Check if any pattern in the set has all the required tags
            const hasAllTags = set.patterns.some((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return false;

              return Array.from(appData.activeFilters.tags).every((tag) =>
                pattern.tags.some((patternTag) => {
                  const patternTagLower = patternTag.toLowerCase();
                  // Check for exact match or if it's a child of the parent tag
                  return (
                    patternTagLower === tag ||
                    patternTagLower.startsWith(tag + ">")
                  );
                })
              );
            });

            if (!hasAllTags) return false;
          }

          // For search filter, check if set name or any pattern in the set matches
          if (appData.activeFilters.search) {
            const searchTerm = appData.activeFilters.search.toLowerCase();

            // Check set name
            if (set.name.toLowerCase().includes(searchTerm)) return true;

            // Check pattern names
            const hasMatchingPattern = set.patterns.some((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return false;

              return (
                pattern.patternName.toLowerCase().includes(searchTerm) ||
                pattern.alternateName.toLowerCase().includes(searchTerm) ||
                pattern.creatorName.toLowerCase().includes(searchTerm)
              );
            });

            if (!hasMatchingPattern) return false;
          }

          return true;
        });

        // Handle empty results
        if (filteredPatterns.length === 0 && visibleSets.length === 0) {
          // Different message based on whether there are any patterns or active filters
          if (!hasAnyPatterns) {
            gallery.innerHTML =
              "<p>No patterns found. Import patterns to get started.</p>";
          } else if (hasActiveFilters) {
            // We have patterns, but none match the current filters
            let message =
              "<p>No patterns match the current filter combination. Try adjusting or clearing your filters.</p>";

            gallery.innerHTML = message;
          } else {
            // We have patterns, but none are being displayed for some other reason
            gallery.innerHTML = "<p>No patterns available to display.</p>";
          }
          return;
        }

        // HANDLE SORTING AND RENDERING BASED ON SORT TYPE
        if (sort.type === "alphabetical") {
          // Create a unified array of both sets and patterns
          const allItems = [];

          // Add sets as items
          visibleSets.forEach((set) => {
            allItems.push({
              isSet: true,
              set: set,
              name: set.name, // For sorting
            });

            // Track patterns in sets
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Add individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (!patternsInRenderedSets.has(pattern.id)) {
              allItems.push({
                isSet: false,
                pattern: pattern,
                name: pattern.alternateName || pattern.patternName, // For sorting
              });
            }
          });

          // Sort all items alphabetically
          const sortedItems = allItems.sort((a, b) => {
            return sort.direction === "asc"
              ? a.name.toLowerCase().localeCompare(b.name.toLowerCase())
              : b.name.toLowerCase().localeCompare(a.name.toLowerCase());
          });

          // Render each item based on its type
          sortedItems.forEach((item) => {
            if (item.isSet) {
              const setCard = createSetCard(item.set);
              if (setCard) gallery.appendChild(setCard);
            } else {
              const patternCard = createPatternCard(item.pattern);
              gallery.appendChild(patternCard);
            }
          });
        } else if (sort.type === "creator") {
          // Group both sets and patterns by creator
          const creatorGroups = {};

          // First group visible sets by creator
          visibleSets.forEach((set) => {
            if (set.patterns.length === 0) return;

            // Get creator from first pattern in set
            const firstPatternId = set.patterns[0];
            const pattern = appData.patterns[firstPatternId];
            if (!pattern) return;

            const creatorName = pattern.creatorName;

            if (!creatorGroups[creatorName]) {
              creatorGroups[creatorName] = [];
            }

            // Add set as an item
            creatorGroups[creatorName].push({
              isSet: true,
              set: set,
              name: set.name, // For sorting within creator group
            });

            // Track patterns in this set
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Then group individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (patternsInRenderedSets.has(pattern.id)) return;

            const creatorName = pattern.creatorName;

            if (!creatorGroups[creatorName]) {
              creatorGroups[creatorName] = [];
            }

            creatorGroups[creatorName].push({
              isSet: false,
              pattern: pattern,
              name: pattern.alternateName || pattern.patternName, // For sorting within creator group
            });
          });

          // Sort the creator names
          const sortedCreatorNames = Object.keys(creatorGroups).sort((a, b) => {
            return sort.direction === "asc"
              ? a.toLowerCase().localeCompare(b.toLowerCase())
              : b.toLowerCase().localeCompare(a.toLowerCase());
          });

          // Render each creator section
          sortedCreatorNames.forEach((creatorName) => {
            const creatorItems = creatorGroups[creatorName];

            // Create a section for this creator
            const creatorSection = document.createElement("div");
            creatorSection.className = "pattern-group-section";

            // Create creator header with count
            const creatorHeader = document.createElement("div");
            creatorHeader.className = "group-header";
            creatorHeader.innerHTML = `
              ${creatorName} <span class="group-count">${creatorItems.length}</span>
            `;
            creatorSection.appendChild(creatorHeader);

            // Create grid for this creator's patterns
            const patternsGrid = document.createElement("div");
            patternsGrid.className = "pattern-gallery";

            // Sort items within the group alphabetically
            creatorItems.sort((a, b) => {
              return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });

            // Create cards for this creator
            creatorItems.forEach((item) => {
              if (item.isSet) {
                const setCard = createSetCard(item.set);
                if (setCard) {
                  patternsGrid.appendChild(setCard);
                }
              } else {
                const card = createPatternCard(item.pattern);
                patternsGrid.appendChild(card);
              }
            });

            creatorSection.appendChild(patternsGrid);
            gallery.appendChild(creatorSection);
          });
        } else if (sort.type === "tag") {
          // Group by tag with hierarchy support
          const tagGroups = {};

          // Process sets first
          visibleSets.forEach((set) => {
            if (!set.patterns || set.patterns.length === 0) return;

            // Determine primary tag for the set
            const tagCounts = new Map();

            // Count occurrences of each tag across patterns in the set
            // For hierarchical tags, count the top-level parent tags
            set.patterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern || !pattern.tags.length) return;

              pattern.tags.forEach((tag) => {
                // Get the top-level parent for hierarchical tags
                const topLevelTag = tag.split(">")[0];
                tagCounts.set(
                  topLevelTag,
                  (tagCounts.get(topLevelTag) || 0) + 1
                );
              });
            });

            // Find the most frequent tag
            let primaryTag = "untagged";
            let maxCount = 0;

            tagCounts.forEach((count, tag) => {
              if (count > maxCount) {
                maxCount = count;
                primaryTag = tag;
              }
            });

            // Add set to the corresponding tag group
            if (!tagGroups[primaryTag]) {
              tagGroups[primaryTag] = [];
            }

            tagGroups[primaryTag].push({
              isSet: true,
              set: set,
              name: set.name, // For sorting within tag group
              topLevelTag: primaryTag,
              // Get the full hierarchical path for sub-sorting
              subTags: getSetSubTags(set),
            });

            // Track patterns in this set
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Process individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (patternsInRenderedSets.has(pattern.id)) return;

            // For patterns with no tags
            if (pattern.tags.length === 0) {
              if (!tagGroups["untagged"]) {
                tagGroups["untagged"] = [];
              }

              tagGroups["untagged"].push({
                isSet: false,
                pattern: pattern,
                name: pattern.alternateName || pattern.patternName,
                topLevelTag: "untagged",
                subTags: [],
              });
              return;
            }

            // For each tag in the pattern, add to appropriate group
            // We'll use the first tag's top level for grouping
            const firstTag = pattern.tags[0];
            const topLevelTag = firstTag.split(">")[0];

            if (!tagGroups[topLevelTag]) {
              tagGroups[topLevelTag] = [];
            }

            tagGroups[topLevelTag].push({
              isSet: false,
              pattern: pattern,
              name: pattern.alternateName || pattern.patternName,
              topLevelTag: topLevelTag,
              subTags: getPatternSubTags(pattern),
            });
          });

          // Sort the tag names
          const sortedTagNames = Object.keys(tagGroups).sort((a, b) => {
            // Special case: "untagged" always at the end
            // TODO: odd, I'd want untagged to always be at the top I think...
            // but that might not be a great end user UX idk
            if (a === "untagged") return sort.direction === "asc" ? 1 : -1;
            if (b === "untagged") return sort.direction === "asc" ? -1 : 1;

            return sort.direction === "asc"
              ? a.toLowerCase().localeCompare(b.toLowerCase())
              : b.toLowerCase().localeCompare(a.toLowerCase());
          });

          // Render each tag section
          sortedTagNames.forEach((tagName) => {
            const tagItems = tagGroups[tagName];

            // Create a section for this tag
            const tagSection = document.createElement("div");
            tagSection.className = "pattern-group-section";

            // Create tag header with count
            const tagHeader = document.createElement("div");
            tagHeader.className = "group-header";
            tagHeader.innerHTML = `
      ${tagName} <span class="group-count">${tagItems.length}</span>
    `;
            tagSection.appendChild(tagHeader);

            // Create grid for this tag's patterns
            const patternsGrid = document.createElement("div");
            patternsGrid.className = "pattern-gallery";

            // Sort items within the tag group based on their hierarchical structure
            tagItems.sort((a, b) => {
              // First sort by sub-tag path if available
              const aSubTags = a.subTags;
              const bSubTags = b.subTags;

              // Compare each level of the hierarchy
              const minLength = Math.min(aSubTags.length, bSubTags.length);

              for (let i = 0; i < minLength; i++) {
                const comparison = aSubTags[i].localeCompare(bSubTags[i]);
                if (comparison !== 0) {
                  return comparison;
                }
              }

              // If sub-tags match up to a point, shorter paths come first
              if (aSubTags.length !== bSubTags.length) {
                return aSubTags.length - bSubTags.length;
              }

              // If hierarchy is identical, sort by name
              return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });

            // Create items for this tag
            tagItems.forEach((item) => {
              if (item.isSet) {
                const setCard = createSetCard(item.set);
                if (setCard) {
                  patternsGrid.appendChild(setCard);
                }
              } else {
                const card = createPatternCard(item.pattern);
                patternsGrid.appendChild(card);
              }
            });

            tagSection.appendChild(patternsGrid);
            gallery.appendChild(tagSection);
          });

          // Helper function to get the hierarchical sub-tags of a pattern
          function getPatternSubTags(pattern) {
            // Get the most specific hierarchical tag (assuming first tag is primary)
            if (!pattern.tags.length) return [];

            // Find the tag with the most levels of hierarchy
            const primaryTag = pattern.tags.reduce((deepest, current) => {
              const deepestLevels = deepest.split(">").length;
              const currentLevels = current.split(">").length;
              return currentLevels > deepestLevels ? current : deepest;
            }, pattern.tags[0]);

            // Return the segments as an array
            return primaryTag.split(">");
          }

          // Helper function to get the hierarchical sub-tags of a set
          function getSetSubTags(set) {
            if (!set.patterns || set.patterns.length === 0) return [];

            // Count tag hierarchies across all patterns in the set
            const tagHierarchyCounts = new Map();

            set.patterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern || !pattern.tags.length) return;

              // Find the deepest hierarchical tag in this pattern
              const deepestTag = pattern.tags.reduce((deepest, current) => {
                const deepestLevels = deepest.split(">").length;
                const currentLevels = current.split(">").length;
                return currentLevels > deepestLevels ? current : deepest;
              }, pattern.tags[0]);

              // Count occurrences of this hierarchy
              tagHierarchyCounts.set(
                deepestTag,
                (tagHierarchyCounts.get(deepestTag) || 0) + 1
              );
            });

            // Find the most common hierarchy
            let mostCommonTag = "";
            let maxCount = 0;

            tagHierarchyCounts.forEach((count, tag) => {
              if (count > maxCount) {
                maxCount = count;
                mostCommonTag = tag;
              }
            });

            // Return the segments as an array
            return mostCommonTag ? mostCommonTag.split(">") : [];
          }
        } else if (sort.type === "set-size") {
          // Create a unified array of both sets and patterns
          const allItems = [];

          // Add sets as items
          visibleSets.forEach((set) => {
            allItems.push({
              isSet: true,
              set: set,
              name: set.name,
              // Add size information for sorting
              gridSize: set.gridSize || "no-grid",
            });

            // Track patterns in sets
            set.patterns.forEach((patternId) => {
              patternsInRenderedSets.add(patternId);
            });
          });

          // Add individual patterns not in sets
          filteredPatterns.forEach((pattern) => {
            if (!patternsInRenderedSets.has(pattern.id)) {
              allItems.push({
                isSet: false,
                pattern: pattern,
                name: pattern.alternateName || pattern.patternName,
                gridSize: "not-in-set", // For individual patterns
              });
            }
          });

          // Define the order of the size groups for sorting
          const sizeOrder = [
            "not-in-set", // Individual patterns not in sets
            "no-grid", // Collection sets without grid
            "1x2",
            "1x3",
            "1x4",
            "2x1", // 2-pattern grids
            "3x1", // 3-pattern grids
            "4x1", // 4-pattern line grids
            "2x2", // 4-pattern square grid
            "2x3", // 6-pattern grid (2 rows, 3 columns)
            "2x4", // 8-pattern grid (2 rows, 4 columns)
            "3x3", // 9-pattern square grid
            "4x4", // 16-pattern square grid
          ];

          // Sort all items by size and then by name
          const sortedItems = allItems.sort((a, b) => {
            const indexA = sizeOrder.indexOf(a.gridSize);
            const indexB = sizeOrder.indexOf(b.gridSize);

            // First sort by grid size
            if (indexA !== indexB) {
              // Handle cases where one or both sizes aren't in our predefined order
              if (indexA === -1 && indexB === -1) {
                // Both are custom sizes not in our list, compare them directly
                return sort.direction === "asc"
                  ? a.gridSize.localeCompare(b.gridSize)
                  : b.gridSize.localeCompare(a.gridSize);
              }
              if (indexA === -1) return sort.direction === "asc" ? 1 : -1;
              if (indexB === -1) return sort.direction === "asc" ? -1 : 1;

              // Both are in our list, use the predefined order
              return sort.direction === "asc"
                ? indexA - indexB
                : indexB - indexA;
            }

            // If same size, sort alphabetically by name
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
          });

          // Render each item based on its type
          sortedItems.forEach((item) => {
            if (item.isSet) {
              const setCard = createSetCard(item.set);
              if (setCard) gallery.appendChild(setCard);
            } else {
              const patternCard = createPatternCard(item.pattern);
              gallery.appendChild(patternCard);
            }
          });
        }
      }

      // Filter patterns based on active filters
      function filterPatterns(patterns) {
        return patterns.filter((pattern) => {
          // Search filter
          if (
            appData.activeFilters.search &&
            !pattern.patternName
              .toLowerCase()
              .includes(appData.activeFilters.search) &&
            !(
              pattern.alternateName &&
              pattern.alternateName
                .toLowerCase()
                .includes(appData.activeFilters.search)
            ) &&
            !pattern.creatorName
              .toLowerCase()
              .includes(appData.activeFilters.search)
          ) {
            return false;
          }

          // Untagged filter - only apply if untagged filter is active
          if (appData.activeFilters.untagged) {
            return pattern.tags.length === 0;
          }

          // Tag filters - only apply if tags filter is active
          if (appData.activeFilters.tags.size > 0) {
            return Array.from(appData.activeFilters.tags).every((filterTag) => {
              // Handle special case: parent>untagged
              if (filterTag.endsWith(">untagged")) {
                const parentTag = filterTag.split(">untagged")[0].toLowerCase();
                const patternTagsLower = pattern.tags.map((t) =>
                  t.toLowerCase()
                );

                // Pattern must have the parent tag
                const hasParentTag = patternTagsLower.includes(parentTag);

                // But must NOT have any child tags of that parent
                const hasChildTag = patternTagsLower.some(
                  (tag) => tag !== parentTag && tag.startsWith(parentTag + ">")
                );

                const result = hasParentTag && !hasChildTag;
                return result;
              }

              // Simple case: direct tag match
              if (
                pattern.tags.some(
                  (patternTag) => patternTag.toLowerCase() === filterTag
                )
              ) {
                return true;
              }

              // Hierarchical case: if filter is a parent tag, also match child tags
              return pattern.tags.some((patternTag) => {
                // Convert both to lowercase for case-insensitive comparison
                const lowercasePatternTag = patternTag.toLowerCase();
                // Check if this pattern tag starts with the filter tag followed by ">"
                return (
                  lowercasePatternTag.startsWith(filterTag + ">") ||
                  // Also check for exact match (redundant with above, but keeping for clarity)
                  lowercasePatternTag === filterTag
                );
              });
            });

            if (!hasMatchingTag) return false;
          }

          // Creator filters - only apply if creators filter is active
          if (appData.activeFilters.creators.size > 0) {
            if (
              !appData.activeFilters.creators.has(
                pattern.creatorName.toLowerCase()
              )
            ) {
              return false;
            }
          }

          // Set filters - only apply if sets filter is active
          if (appData.activeFilters.sets.size > 0) {
            if (
              !pattern.setName ||
              !appData.activeFilters.sets.has(pattern.setName.toLowerCase())
            ) {
              return false;
            }
          }

          return true;
        });
      }

      // Add the sort by dropdown menu
      function setupSortByDropdown() {
        // Find dropdown elements that are in the HTML template
        const sortButton = document.querySelector(".sort-dropdown-button");
        const dropdownMenu = document.querySelector(".sort-dropdown-menu");

        if (!sortButton || !dropdownMenu) return;

        // Toggle dropdown on button click
        sortButton.addEventListener("click", function (e) {
          e.stopPropagation();
          dropdownMenu.classList.toggle("show");
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener("click", function () {
          dropdownMenu.classList.remove("show");
        });

        // Handle sort option selection
        dropdownMenu.querySelectorAll(".sort-option").forEach((option) => {
          option.addEventListener("click", function (e) {
            e.stopPropagation();

            const sortType = this.getAttribute("data-sort");
            let direction = this.getAttribute("data-direction");

            // Toggle direction if the same option is clicked again
            if (this.classList.contains("active")) {
              direction = direction === "asc" ? "desc" : "asc";
              this.setAttribute("data-direction", direction);
              this.querySelector(".sort-icon").textContent =
                direction === "asc" ? "↓" : "↑";
            } else {
              // Reset all options
              dropdownMenu.querySelectorAll(".sort-option").forEach((opt) => {
                opt.classList.remove("active");
              });

              // Mark current option as active
              this.classList.add("active");
            }

            // Update app state with the selected sort
            appData.activeSort = {
              type: sortType,
              direction: direction,
            };

            // Update button text to show current sort
            const sortText = this.textContent.trim();
            sortButton.innerHTML = `Sort: ${sortText} <span class="dropdown-arrow">▼</span>`;

            // Hide the dropdown
            dropdownMenu.classList.remove("show");

            // Re-render the gallery
            renderPatternGallery();
          });
        });

        // Set initial sort state if not already set
        if (!appData.activeSort) {
          appData.activeSort = {
            type: "alphabetical",
            direction: "asc",
          };
        }
      }

      // Setup sort dropdown for creators tab
      function setupCreatorSortDropdown() {
        // Find the action bar in creators tab
        const actionBar = document.querySelector("#creators .action-bar");

        // Create the dropdown container
        const sortDropdownContainer = document.createElement("div");
        sortDropdownContainer.className = "sort-dropdown-container";

        // Create the dropdown button
        const sortButton = document.createElement("button");
        sortButton.id = "creator-sort-dropdown-button";
        sortButton.className = "btn btn-secondary sort-dropdown-button";
        sortButton.innerHTML =
          'Sort: Alphabetical <span class="dropdown-arrow">▼</span>';

        // Create the dropdown menu
        const dropdownMenu = document.createElement("div");
        dropdownMenu.className = "sort-dropdown-menu";
        dropdownMenu.innerHTML = `
    <div class="sort-option active" data-sort="alphabetical" data-direction="asc">
      <span class="sort-icon"></span> Alphabetical
    </div>
    <div class="sort-option" data-sort="pattern-count" data-direction="desc">
      <span class="sort-icon">↓</span> Pattern Count
    </div>
  `;

        // Assemble dropdown
        sortDropdownContainer.appendChild(sortButton);
        sortDropdownContainer.appendChild(dropdownMenu);

        // Insert before the Add Creator button
        const createBtn = actionBar.querySelector("#create-creator-btn");
        actionBar.insertBefore(sortDropdownContainer, createBtn);

        // Toggle dropdown on button click
        sortButton.addEventListener("click", function (e) {
          e.stopPropagation();
          dropdownMenu.classList.toggle("show");
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener("click", function () {
          dropdownMenu.classList.remove("show");
        });

        // Handle sort option selection
        dropdownMenu.querySelectorAll(".sort-option").forEach((option) => {
          option.addEventListener("click", function (e) {
            e.stopPropagation();

            const sortType = this.getAttribute("data-sort");
            let direction = this.getAttribute("data-direction");

            // Toggle direction if the same option is clicked again
            if (this.classList.contains("active")) {
              direction = direction === "asc" ? "desc" : "asc";
              this.setAttribute("data-direction", direction);
              this.querySelector(".sort-icon").textContent =
                direction === "asc" ? "↑" : "↓";
            } else {
              // Reset all options
              dropdownMenu.querySelectorAll(".sort-option").forEach((opt) => {
                opt.classList.remove("active");
              });

              // Mark current option as active
              this.classList.add("active");
            }

            // Update app state with the selected sort
            appData.creatorSort = {
              type: sortType,
              direction: direction,
            };

            // Update button text to show current sort
            const sortText = this.textContent.trim();
            sortButton.innerHTML = `Sort: ${sortText} <span class="dropdown-arrow">▼</span>`;

            // Hide the dropdown
            dropdownMenu.classList.remove("show");

            // Re-render the creators list
            renderCreators();
          });
        });
      }

      // Initialize the sorting
      function initSorting() {
        appData.activeSort = {
          type: "alphabetical",
          direction: "asc",
        };

        setupSortByDropdown();
      }

      function initCreatorSorting() {
        // Set default sort if not already set
        if (!appData.creatorSort) {
          appData.creatorSort = {
            type: "alphabetical",
            direction: "asc",
          };
        }

        // Setup the dropdown UI
        setupCreatorSortDropdown();
      }

      // Add to setupEventListeners function - new button for selection mode
      function setupMultiSelectUI() {
        // Create selection mode toggle button
        const actionBar = document.querySelector(".action-bar");
        const selectionBtn = document.createElement("button");
        selectionBtn.id = "selection-mode-btn";
        selectionBtn.className = "btn btn-secondary";
        selectionBtn.innerHTML = '<span class="selection-icon">☐</span> Select';

        // Insert before the Sort By button
        const sortByBtn = actionBar.querySelector(".sort-dropdown-container");
        sortByBtn.parentNode.insertBefore(selectionBtn, sortByBtn);

        // Add event listener
        selectionBtn.addEventListener("click", toggleSelectionMode);

        // Add selection action panel (hidden initially)
        const selectionPanel = document.createElement("div");
        selectionPanel.id = "selection-panel";
        selectionPanel.className = "selection-panel";
        selectionPanel.innerHTML = `
          <div class="selection-count">0 patterns selected</div>
          <div class="selection-actions">
            <button id="add-tags-btn" class="btn btn-small">Edit Tags</button>
            <button id="create-set-btn" class="btn btn-small">Create Set</button>
          </div>
          <button id="clear-selection-btn" class="btn btn-small btn-secondary">Clear</button>
        `;

        // Add to document
        document.querySelector(".container").appendChild(selectionPanel);

        // Add event listeners for selection panel buttons
        document
          .getElementById("add-tags-btn")
          .addEventListener("click", () => batchAddTags());
        document
          .getElementById("selection-panel")
          .querySelector("#create-set-btn")
          .addEventListener("click", () => batchCreateSet());
        document
          .getElementById("clear-selection-btn")
          .addEventListener("click", clearSelection);
      }

      // Toggle selection mode
      function toggleSelectionMode() {
        appData.selectionMode = !appData.selectionMode;

        // Update button appearance
        const selectionBtn = document.getElementById("selection-mode-btn");
        if (appData.selectionMode) {
          selectionBtn.classList.add("active");
          selectionBtn.innerHTML =
            '<span class="selection-icon">☑</span> Cancel';
        } else {
          selectionBtn.classList.remove("active");
          selectionBtn.innerHTML =
            '<span class="selection-icon">☐</span> Select';
          clearSelection();
        }

        // Re-render pattern gallery to show/hide checkboxes
        renderPatternGallery();
      }

      // Create a pattern card element
      function createPatternCard(pattern) {
        const card = document.createElement("div");
        card.className = "pattern-card";
        card.setAttribute("data-id", pattern.id);

        // Add selected class if pattern is selected
        if (appData.selectedPatterns.has(pattern.id)) {
          card.classList.add("selected");
        }

        // Determine thumbnail source
        let thumbnailSrc = getPatternThumbnailSrc(pattern);

        // Get creator info to determine if we need to add rank badges
        let creatorBadge = "";
        const creatorId = Object.keys(appData.creators).find((id) => {
          return (
            appData.creators[id].name === pattern.creatorName &&
            appData.creators[id].townName === pattern.townName
          );
        });

        if (creatorId) {
          const creator = appData.creators[creatorId];
          if (creator.rank === "verified") {
            creatorBadge =
              '<div class="verified-badge" title="Verified Creator">🌟 Verified</div>';
          } else if (creator.rank === "plagiarist") {
            creatorBadge =
              '<span class="plagiarist-badge" title="Plagiarized Pattern">⚠️ Plagiarized</span>';
          }
        }

        // Selection checkbox (only visible in selection mode)
        const selectionCheckbox = appData.selectionMode
          ? `<div class="pattern-select">
            <input type="checkbox" id="select-${pattern.id}" ${
              appData.selectedPatterns.has(pattern.id) ? "checked" : ""
            }>
            <label for="select-${pattern.id}"></label>
          </div>`
          : "";

        // Process tags to display only the leaf part of hierarchical tags
        const displayTags = pattern.tags.map((tag) => {
          const segments = tag.split(">");
          // Return just the last segment (leaf node)
          return segments[segments.length - 1];
        });

        // Remove duplicates (in case after trimming parent path we have duplicates)
        const uniqueDisplayTags = [...new Set(displayTags)];

        // Get display name if alternate is set
        const displayName = pattern.alternateName || pattern.patternName;

        const html = `
          ${selectionCheckbox}
          <img class="pattern-thumbnail" src="${thumbnailSrc}" alt="${displayName}">
            ${creatorBadge}
            <div class="pattern-info">
            <div class="pattern-name">${displayName}</div>
            <div class="pattern-creator">by ${pattern.creatorName} of ${
          pattern.townName
        }</div>
            <div class="tag-list">
              ${uniqueDisplayTags
                .map((tag) => `<span class="tag">${tag}</span>`)
                .join("")}
            </div>
          </div>
        `;

        card.innerHTML = html;

        // Modified click event handling
        card.addEventListener("click", (e) => {
          // Check if clicking on checkbox
          if (e.target.type === "checkbox" || e.target.tagName === "LABEL") {
            e.stopPropagation();
            return;
          }

          // For normal clicks when not in selection mode, open pattern detail
          if (!appData.selectionMode && !e.ctrlKey && !e.metaKey) {
            openPatternDetail(pattern.id);
            return;
          }

          // For Ctrl/Cmd+click or in selection mode, toggle selection
          togglePatternSelection(pattern.id);
          e.preventDefault();
        });

        // Add specific handler for the checkbox
        const checkbox = card.querySelector(`#select-${pattern.id}`);
        if (checkbox) {
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            togglePatternSelection(pattern.id);
          });
        }

        return card;
      }

      // Toggle pattern selection
      function togglePatternSelection(patternId) {
        // Check if this is a set
        const item = document.querySelector(
          `.pattern-card[data-id="${patternId}"]`
        );
        const isSet = item && item.getAttribute("data-type") === "set";

        if (isSet) {
          const setId = patternId;
          const set = appData.sets[setId];

          if (!set || !set.patterns || set.patterns.length === 0) {
            return; // Invalid set or empty set
          }

          // Toggle the selection state based on first pattern in set
          const firstPatternId = set.patterns[0];
          const allSelected = set.patterns.every((id) =>
            appData.selectedPatterns.has(id)
          );

          if (allSelected) {
            // If all patterns in the set are selected, deselect them all
            set.patterns.forEach((patternId) => {
              appData.selectedPatterns.delete(patternId);
            });
          } else {
            // Otherwise, select all patterns in the set
            set.patterns.forEach((patternId) => {
              appData.selectedPatterns.add(patternId);
            });
          }
        } else {
          // Regular pattern selection toggle
          if (appData.selectedPatterns.has(patternId)) {
            appData.selectedPatterns.delete(patternId);
          } else {
            appData.selectedPatterns.add(patternId);
          }
        }

        // Update UI
        updateSelectionUI();

        // If not in selection mode but patterns are selected, enter selection mode
        if (!appData.selectionMode && appData.selectedPatterns.size > 0) {
          toggleSelectionMode();
        }
      }

      // Update selection UI elements
      function updateSelectionUI() {
        // Update pattern card styling
        document.querySelectorAll(".pattern-card").forEach((card) => {
          const patternId = card.getAttribute("data-id");
          const isSet = card.getAttribute("data-type") === "set";

          if (isSet) {
            // For sets, check if all patterns in the set are selected
            const set = appData.sets[patternId];
            if (set && set.patterns && set.patterns.length > 0) {
              const allSelected = set.patterns.every((id) =>
                appData.selectedPatterns.has(id)
              );

              if (allSelected) {
                card.classList.add("selected");
                const checkbox = card.querySelector(`#select-${patternId}`);
                if (checkbox) checkbox.checked = true;
              } else {
                card.classList.remove("selected");
                const checkbox = card.querySelector(`#select-${patternId}`);
                if (checkbox) checkbox.checked = false;
              }
            }
          } else {
            // Regular pattern
            if (appData.selectedPatterns.has(patternId)) {
              card.classList.add("selected");
              const checkbox = card.querySelector(`#select-${patternId}`);
              if (checkbox) checkbox.checked = true;
            } else {
              card.classList.remove("selected");
              const checkbox = card.querySelector(`#select-${patternId}`);
              if (checkbox) checkbox.checked = false;
            }
          }
        });

        // Update selection panel
        const panel = document.getElementById("selection-panel");
        const count = appData.selectedPatterns.size;

        if (count > 0) {
          panel.classList.add("active");
          panel.querySelector(
            ".selection-count"
          ).textContent = `${count} pattern${count !== 1 ? "s" : ""} selected`;

          // Check if any sets are selected by looking at sets where all their patterns are selected
          const setsSelected = Object.values(appData.sets).some(
            (set) =>
              set.patterns &&
              set.patterns.length > 0 &&
              set.patterns.every((id) => appData.selectedPatterns.has(id))
          );

          // Disable "Create Set" button if any sets are completely selected
          const createSetBtn = panel.querySelector("#create-set-btn");
          if (createSetBtn) {
            createSetBtn.disabled = setsSelected;
            createSetBtn.title = setsSelected
              ? "Cannot add sets to sets"
              : "Create a new set with selected patterns";

            if (setsSelected) {
              createSetBtn.classList.add("disabled");
            } else {
              createSetBtn.classList.remove("disabled");
            }
          }
        } else {
          panel.classList.remove("active");
        }
      }

      // Clear pattern selection
      function clearSelection() {
        appData.selectedPatterns.clear();
        updateSelectionUI();
      }

      // Add tags to multiple patterns
      function batchAddTags() {
        if (appData.selectedPatterns.size === 0) return;

        // Get the selected patterns
        const selectedPatternIds = Array.from(appData.selectedPatterns);
        const selectedPatterns = selectedPatternIds
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern);

        if (selectedPatterns.length === 0) return;

        // Find common tags among all selected patterns
        let commonTags = [...selectedPatterns[0].tags];

        // Keep only tags that exist in all selected patterns
        for (let i = 1; i < selectedPatterns.length; i++) {
          commonTags = commonTags.filter((tag) =>
            selectedPatterns[i].tags.some(
              (patternTag) => patternTag.toLowerCase() === tag.toLowerCase()
            )
          );
        }

        // Create modal for tag input
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Edit Tags for ${appData.selectedPatterns.size} Patterns</h2>
            
            <div class="form-group full-width">
              <label>Edit Tags</label>
              <div class="tag-input" id="batch-tag-input">
                <input type="text" placeholder="Add a tag...">
              </div>
              <p class="help-text">Enter each tag and press Enter or comma to add. Remove tags by clicking the × button.</p>
              <p class="help-text">Use > for hierarchical tags (e.g., "clothing>shirt>long-sleeve").</p>
            </div>
            
            <div class="form-group full-width" style="display: flex;">
              <input type="checkbox" id="batch-tag-merge" checked style="width: unset; margin-right: 7px;">
              <label>
                Merge with existing tags (uncheck to replace all tags)
              </label>
            </div>
            
            <button class="btn" id="apply-batch-tags-btn">Apply Tags</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Setup tag input
        const tagInput = modal.querySelector("#batch-tag-input");
        setupBatchTagInput(tagInput);

        // Add common tags to the input
        commonTags.forEach((tag) => {
          addBatchTag(tag, tagInput);
        });

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Apply button
        modal
          .querySelector("#apply-batch-tags-btn")
          .addEventListener("click", () => {
            const mergeTags =
              document.getElementById("batch-tag-merge").checked;
            const tagElements = tagInput.querySelectorAll(".tag-item");

            // Get tags from UI
            const tags = Array.from(tagElements).map((el) =>
              el.textContent.trim().replace(/\s*×\s*$/, "")
            );

            // Apply tags to all selected patterns
            appData.selectedPatterns.forEach((patternId) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return;

              if (mergeTags) {
                // For each tag, ensure all parent tags are also added
                const tagsToApply = new Set();

                tags.forEach((tag) => {
                  const segments = tag.split(">");
                  let currentPath = "";

                  for (const segment of segments) {
                    currentPath = currentPath
                      ? `${currentPath}>${segment}`
                      : segment;
                    tagsToApply.add(currentPath);
                  }
                });

                // Merge with existing tags (avoid duplicates)
                const existingTags = new Set(
                  pattern.tags.map((tag) => tag.toLowerCase())
                );
                const newTags = [...pattern.tags];

                tagsToApply.forEach((tag) => {
                  if (!existingTags.has(tag.toLowerCase())) {
                    newTags.push(tag);
                  }
                });

                pattern.tags = newTags;
              } else {
                // Replace all tags, but still ensure hierarchical integrity
                const tagsToApply = new Set();

                tags.forEach((tag) => {
                  const segments = tag.split(">");
                  let currentPath = "";

                  for (const segment of segments) {
                    currentPath = currentPath
                      ? `${currentPath}>${segment}`
                      : segment;
                    tagsToApply.add(currentPath);
                  }
                });

                pattern.tags = [...tagsToApply];
              }

              // Update modification date
              pattern.lastModified = new Date().toISOString().split("T")[0];
            });

            // Save changes
            saveDataToLocalStorage();

            // Store the count before clearing
            const patternCount = appData.selectedPatterns.size;

            // Close modal
            document.body.removeChild(modal);

            // Clear selection
            clearSelection();

            // Refresh UI
            renderPatternGallery();
            renderSidebarFilters();

            showNotification(`Tags applied to ${patternCount} patterns`);
          });
      }

      // Setup tag input for batch operations
      function setupBatchTagInput(tagInput) {
        const input = tagInput.querySelector("input");

        // Add event listeners for tag input
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const tag = input.value.trim();
            if (tag) {
              addBatchTag(tag, tagInput);
              input.value = "";
            }
          } else if (e.key === "Backspace" && input.value === "") {
            // Remove the last tag when backspace is pressed in an empty input
            const tagElements = tagInput.querySelectorAll(".tag-item");
            if (tagElements.length > 0) {
              tagInput.removeChild(tagElements[tagElements.length - 1]);
            }
          }
        });

        // Add autocomplete for hierarchical tags
        input.addEventListener("input", (e) => {
          const value = input.value.trim().toLowerCase();

          // Only show suggestions if there's input and it's at least 1 character
          if (value.length < 1) {
            // Remove existing suggestions
            const existingSuggestions = document.getElementById(
              "batch-tag-suggestions"
            );
            if (existingSuggestions) {
              existingSuggestions.remove();
            }
            return;
          }

          // Get all existing tags across all patterns
          const allTags = new Set();
          Object.values(appData.patterns).forEach((pattern) => {
            pattern.tags.forEach((tag) => allTags.add(tag.toLowerCase()));
          });

          // Filter tags that match the input
          const exactMatches = [];
          const hierarchyMatches = [];

          // Check for exact matches and hierarchy-based matches
          allTags.forEach((tag) => {
            // Skip if this tag already exists in the batch input
            if (batchTagExists(tag, tagInput)) return;

            // Direct matches anywhere in the tag
            if (tag.includes(value)) {
              exactMatches.push(tag);
              return;
            }

            // Check if any segment in a hierarchical tag matches
            const segments = tag.split(">");
            for (const segment of segments) {
              if (segment.includes(value)) {
                hierarchyMatches.push(tag);
                return;
              }
            }
          });

          // Combine matches
          const allMatches = [...exactMatches, ...hierarchyMatches];

          // Sort matches alphabetically
          allMatches.sort((a, b) => a.localeCompare(b));

          // Limit results
          const matches = allMatches.slice(0, 5);

          if (matches.length > 0) {
            showBatchTagSuggestions(matches, tagInput, input);
          } else {
            // Remove suggestions if no matches
            const existingSuggestions = document.getElementById(
              "batch-tag-suggestions"
            );
            if (existingSuggestions) {
              existingSuggestions.remove();
            }
          }
        });

        // Focus the input field
        input.focus();
      }

      function batchTagExists(tag, tagInput) {
        const tagElements = tagInput.querySelectorAll(".tag-item");
        const normalizedTag = tag.toLowerCase();

        return Array.from(tagElements).some((el) => {
          const existingTag = el.textContent
            .trim()
            .replace(/\s*×\s*$/, "")
            .toLowerCase();
          return existingTag === normalizedTag;
        });
      }

      function showBatchTagSuggestions(suggestions, tagInput, inputElement) {
        // Remove existing suggestions
        const existingSuggestions = document.getElementById(
          "batch-tag-suggestions"
        );
        if (existingSuggestions) {
          existingSuggestions.remove();
        }

        if (suggestions.length === 0) return;

        // Create suggestions container
        const suggestionsContainer = document.createElement("div");
        suggestionsContainer.id = "batch-tag-suggestions";
        suggestionsContainer.style.position = "absolute";
        suggestionsContainer.style.zIndex = "1000";
        suggestionsContainer.style.backgroundColor = "white";
        suggestionsContainer.style.border = "1px solid var(--border-color)";
        suggestionsContainer.style.borderRadius = "4px";
        suggestionsContainer.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
        suggestionsContainer.style.width = `${tagInput.offsetWidth}px`;
        suggestionsContainer.style.maxHeight = "150px";
        suggestionsContainer.style.overflowY = "auto";

        // Position below the tag input
        const rect = tagInput.getBoundingClientRect();
        suggestionsContainer.style.top = `${rect.bottom + window.scrollY}px`;
        suggestionsContainer.style.left = `${rect.left + window.scrollX}px`;

        // Add suggestions
        suggestions.forEach((suggestion) => {
          const suggestionElement = document.createElement("div");

          // Format hierarchical tags for better display
          if (suggestion.includes(">")) {
            const segments = suggestion.split(">");
            const formatted = segments
              .map(
                (segment, index) =>
                  `<span style="opacity:${
                    0.6 + 0.4 * (index / segments.length)
                  }">
          ${index > 0 ? "› " : ""}${segment}
        </span>`
              )
              .join(" ");
            suggestionElement.innerHTML = formatted;
          } else {
            suggestionElement.textContent = suggestion;
          }

          suggestionElement.style.padding = "8px 12px";
          suggestionElement.style.cursor = "pointer";
          suggestionElement.style.borderBottom =
            "1px solid var(--border-color)";

          suggestionElement.addEventListener("mouseover", () => {
            suggestionElement.style.backgroundColor = "var(--secondary-color)";
          });

          suggestionElement.addEventListener("mouseout", () => {
            suggestionElement.style.backgroundColor = "white";
          });

          suggestionElement.addEventListener("click", () => {
            addBatchTag(suggestion, tagInput);
            inputElement.value = "";
            suggestionsContainer.remove();
            inputElement.focus();
          });

          suggestionsContainer.appendChild(suggestionElement);
        });

        // Add click outside to close suggestions
        document.addEventListener("click", function closeHandler(e) {
          if (
            !suggestionsContainer.contains(e.target) &&
            e.target !== inputElement
          ) {
            suggestionsContainer.remove();
            document.removeEventListener("click", closeHandler);
          }
        });

        // Add to document
        document.body.appendChild(suggestionsContainer);
      }

      // Add tag to batch tag input
      function addBatchTag(tag, tagInput) {
        tag = tag.trim();
        if (!tag) return;

        // Check if tag already exists
        if (batchTagExists(tag, tagInput)) return;

        // Create tag element
        const tagElement = document.createElement("div");
        tagElement.className = "tag-item";

        tagElement.innerHTML = `${tag} <span class="tag-remove">×</span>`;

        // Add click event to remove tag
        tagElement
          .querySelector(".tag-remove")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            tagInput.removeChild(tagElement);
          });

        tagInput.insertBefore(tagElement, tagInput.querySelector("input"));
      }

      // Create a new set with selected patterns
      function batchCreateSet() {
        if (appData.selectedPatterns.size === 0) return;

        // Create modal for new set
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Create New Set with ${appData.selectedPatterns.size} Patterns</h2>
            
            <div class="form-group">
              <label for="new-set-name">Set Name</label>
              <input type="text" id="new-set-name" placeholder="Enter set name">
            </div>
            
            <div class="form-group">
              <label for="new-set-grid-size">Grid Size (Optional)</label>
              <select id="new-set-grid-size">
                <option value="">No Grid (Pattern Collection)</option>
                <option value="2x2">2 × 2 Grid</option>
                <option value="3x3">3 × 3 Grid</option>
                <option value="4x4">4 × 4 Grid</option>
                <option value="1x2">1 × 2 Grid (Horiz)</option>
                <option value="1x3">1 × 3 Grid (Horiz)</option>
                <option value="1x4">1 × 4 Grid (Horiz)</option>
                <option value="2x3">2 × 3 Grid (Horiz)</option>
                <option value="2x4">2 × 4 Grid (Horiz)</option>
                <option value="2x1">2 × 1 Grid (Vert)</option>
                <option value="3x1">3 × 1 Grid (Vert)</option>
                <option value="4x1">4 × 1 Grid (Vert)</option>
              </select>
              <p class="help-text">Select a grid size if this set forms a larger image when combined.</p>
            </div>
            
            <div class="form-group full-width">
              <label for="new-set-notes">Notes (Optional)</label>
              <textarea id="new-set-notes" rows="3" placeholder="Enter notes about this set"></textarea>
            </div>
            
            <div id="set-creator-warning" class="warning-message" style="display: none;">
              Warning: The selected patterns are from different creators. Sets must contain patterns from the same creator.
            </div>
            
            <button class="btn" id="create-new-set-btn">Create Set</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Validate creators
        const selectedPatternIds = Array.from(appData.selectedPatterns);
        const isSameCreator = validateSetCreator(selectedPatternIds);

        // Show warning if patterns are from different creators
        if (!isSameCreator) {
          const warningElem = modal.querySelector("#set-creator-warning");
          warningElem.style.display = "block";
          modal.querySelector("#create-new-set-btn").disabled = true;
        }

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Create button
        modal
          .querySelector("#create-new-set-btn")
          .addEventListener("click", () => {
            const setName = document
              .getElementById("new-set-name")
              .value.trim();

            if (!setName) {
              showNotification("Please enter a set name", "error");
              return;
            }

            // Check creator validation again
            if (!isSameCreator) {
              showNotification(
                "Cannot create a set with patterns from different creators",
                "error"
              );
              return;
            }

            const setNotes = document
              .getElementById("new-set-notes")
              .value.trim();
            const gridSize = document.getElementById("new-set-grid-size").value;

            // Generate ID
            const setId = "set-" + Date.now();

            // Get selected pattern IDs
            const patternIds = Array.from(appData.selectedPatterns);

            // Create set
            appData.sets[setId] = {
              id: setId,
              name: setName,
              patterns: patternIds,
              notes: setNotes,
              gridSize: gridSize || null, // Store null if no grid size selected
            };

            // Update patterns
            patternIds.forEach((patternId, index) => {
              const pattern = appData.patterns[patternId];
              if (!pattern) return;

              // Remove from previous set if any
              if (pattern.setId && appData.sets[pattern.setId]) {
                appData.sets[pattern.setId].patterns = appData.sets[
                  pattern.setId
                ].patterns.filter((id) => id !== patternId);
              }

              // Update pattern
              pattern.setId = setId;
              pattern.setName = setName;
              pattern.setOrder = index + 1;
              pattern.lastModified = new Date().toISOString().split("T")[0];
            });

            // Save data
            saveDataToLocalStorage();

            // Close modal
            document.body.removeChild(modal);

            // Clear selection
            clearSelection();

            // Refresh UI
            renderPatternGallery();
            renderSidebarFilters();

            showNotification(
              `Created new set "${setName}" with ${patternIds.length} patterns`
            );
          });
      }

      function logPatternTagCounts() {
        // Build parent-only tag counts - these are patterns that have only the parent tag
        // but none of the child tags
        const parentOnlyTagCounts = {};

        // First, collect all parent tags
        const parentTags = new Set();
        const allTags = new Set();

        // Collect all tags first
        Object.values(appData.patterns).forEach((pattern) => {
          pattern.tags.forEach((tag) => {
            const tagLower = tag.toLowerCase();
            allTags.add(tagLower);

            if (tagLower.includes(">")) {
              const parent = tagLower.split(">")[0];
              parentTags.add(parent);
            }
          });
        });

        // Now count patterns that have ONLY the parent tag without any child tags
        Object.values(appData.patterns).forEach((pattern) => {
          const patternTagsLower = pattern.tags.map((t) => t.toLowerCase());

          // Check each parent tag
          parentTags.forEach((parentTag) => {
            // If the pattern has the parent tag
            if (patternTagsLower.includes(parentTag)) {
              // Check if it has any child tags
              const hasChildTag = patternTagsLower.some(
                (tag) => tag !== parentTag && tag.startsWith(parentTag + ">")
              );

              // If it doesn't have any child tags, count it as "parent-only"
              if (!hasChildTag) {
                parentOnlyTagCounts[parentTag] =
                  (parentOnlyTagCounts[parentTag] || 0) + 1;
              }
            }
          });
        });

        return parentOnlyTagCounts;
      }

      // Render sidebar filters
      function renderSidebarFilters() {
        // Get parent-only tag counts
        const parentOnlyTagCounts = logPatternTagCounts();

        // Render tag filters
        const allTags = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          pattern.tags.forEach((tag) => {
            const tagLower = tag.toLowerCase();
            allTags.set(tagLower, (allTags.get(tagLower) || 0) + 1);
          });
        });

        // Count untagged patterns (no tags at all)
        const untaggedCount = Object.values(appData.patterns).filter(
          (pattern) => pattern.tags.length === 0
        ).length;

        // Create the untagged filter HTML
        const untaggedFilterHTML = `
          <li class="${
            appData.activeFilters.untagged ? "active" : ""
          }" data-filter="untagged">
            untagged 
            <span class="filter-count">${untaggedCount}</span>
          </li>`;

        // Group tags into a hierarchical structure
        const tagHierarchy = {};

        Array.from(allTags.entries()).forEach(([tag, count]) => {
          const segments = tag.split(">");

          if (segments.length === 1) {
            // This is a top-level tag
            if (!tagHierarchy[tag]) {
              tagHierarchy[tag] = { count: count, children: {} };
            } else {
              tagHierarchy[tag].count = count;
            }
          } else {
            // This is a nested tag, add to parent
            const parentTag = segments[0]; // Get top-level parent
            const childTag = segments.slice(1).join(">"); // Rest is the child

            // Ensure parent exists
            if (!tagHierarchy[parentTag]) {
              tagHierarchy[parentTag] = { count: 0, children: {} };
            }

            // Add child to parent
            if (!tagHierarchy[parentTag].children[childTag]) {
              tagHierarchy[parentTag].children[childTag] = {
                fullTag: tag,
                count: count,
              };
            } else {
              tagHierarchy[parentTag].children[childTag].count = count;
            }
          }
        });

        // Render the hierarchical tags
        let tagFiltersHTML = untaggedFilterHTML;

        Object.keys(tagHierarchy)
          .sort((a, b) => {
            // Special case: "untagged" always at the top
            if (a === "untagged") return -1;
            if (b === "untagged") return 1;

            // Otherwise sort by count (highest first)
            return tagHierarchy[b].count - tagHierarchy[a].count;
          })
          .forEach((tag) => {
            const isActive = appData.activeFilters.tags.has(tag);
            const hasChildren =
              Object.keys(tagHierarchy[tag].children).length > 0;
            const isParentOfActiveChild =
              hasChildren &&
              Object.values(tagHierarchy[tag].children).some((child) =>
                appData.activeFilters.tags.has(child.fullTag)
              );

            // Check if the parent>untagged filter is active
            const isParentUntaggedActive = appData.activeFilters.tags.has(
              `${tag}>untagged`
            );

            // Determine if this parent should appear expanded based on if it or any of its children are active
            const shouldExpand =
              isActive || isParentOfActiveChild || isParentUntaggedActive;

            tagFiltersHTML += `
              <li class="${isActive ? "active" : ""} ${
              hasChildren ? "tag-parent" : ""
            }" data-tag="${tag}">
                ${tag} 
                <span class="filter-count">${tagHierarchy[tag].count}</span>
              </li>`;

            if (hasChildren) {
              // Determine visibility based on whether parent or any child is active
              const visibilityClass = shouldExpand ? "visible" : "";

              tagFiltersHTML += `<div class="tag-children ${visibilityClass}">`;

              // Add "untagged" option within the parent tag if there are patterns with only the parent tag
              const parentOnlyCount = parentOnlyTagCounts[tag] || 0;
              if (parentOnlyCount > 0) {
                const specialFilterTag = `${tag}>untagged`;
                const isUntaggedActive =
                  appData.activeFilters.tags.has(specialFilterTag);

                tagFiltersHTML += `
                  <li class="${
                    isUntaggedActive ? "active" : ""
                  } level-1" data-tag="${specialFilterTag}">
                    no child tag
                    <span class="filter-count">${parentOnlyCount}</span>
                  </li>`;
              }

              // Then add all the regular child tags
              Object.keys(tagHierarchy[tag].children)
                .sort()
                .forEach((childTag) => {
                  const child = tagHierarchy[tag].children[childTag];
                  const childIsActive = appData.activeFilters.tags.has(
                    child.fullTag
                  );

                  tagFiltersHTML += `
                    <li class="${
                      childIsActive ? "active" : ""
                    } level-1" data-tag="${child.fullTag}">
                      ${childTag.split(">")[0]} 
                      <span class="filter-count">${child.count}</span>
                    </li>`;
                });

              tagFiltersHTML += `</div>`;
            }
          });

        elements.tagFilters.innerHTML =
          tagFiltersHTML || "<li>No tags available</li>";

        // Setup tag filter click events
        elements.tagFilters.querySelectorAll("li[data-tag]").forEach((li) => {
          li.addEventListener("click", (e) => {
            const tag = li.getAttribute("data-tag");
            if (!tag) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.tags.delete(tag);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.tags.has(tag)) {
                  appData.activeFilters.tags.delete(tag);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.tags.add(tag);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.tags.has(tag) &&
                  appData.activeFilters.tags.size === 1
                ) {
                  // If this is the only active tag, clicking it should deselect it
                  appData.activeFilters.tags.delete(tag);
                  li.classList.remove("active");

                  // Hide all tag-children
                  document.querySelectorAll(".tag-children").forEach((elem) => {
                    elem.classList.remove("visible");
                  });
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.tags.clear();
                  elements.tagFilters.querySelectorAll("li").forEach((item) => {
                    item.classList.remove("active");
                  });

                  appData.activeFilters.tags.add(tag);
                  li.classList.add("active");

                  // Hide all tag-children first
                  document.querySelectorAll(".tag-children").forEach((elem) => {
                    elem.classList.remove("visible");
                  });

                  // For parent tags, toggle visibility of children
                  if (li.classList.contains("tag-parent")) {
                    const nextElement = li.nextElementSibling;
                    if (
                      nextElement &&
                      nextElement.classList.contains("tag-children")
                    ) {
                      nextElement.classList.toggle("visible");
                    }
                  } else {
                    // For child tags, ensure parent's children remain visible
                    const parentContainer = li.closest(".tag-children");
                    if (parentContainer) {
                      parentContainer.classList.add("visible");
                    }
                  }
                }
              }

              // Turn off untagged filter when selecting a tag
              appData.activeFilters.untagged = false;
              elements.tagFilters
                .querySelector("li[data-filter='untagged']")
                ?.classList.remove("active");
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });

        // Setup untagged filter click event
        const untaggedFilter = elements.tagFilters.querySelector(
          "li[data-filter='untagged']"
        );
        if (untaggedFilter) {
          untaggedFilter.addEventListener("click", (e) => {
            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.untagged = false;
              untaggedFilter.classList.remove("active");
            } else {
              // Toggle the untagged filter
              appData.activeFilters.untagged = !appData.activeFilters.untagged;

              if (appData.activeFilters.untagged) {
                untaggedFilter.classList.add("active");
                // Clear tag filters when untagged is selected
                appData.activeFilters.tags.clear();
                elements.tagFilters
                  .querySelectorAll("li[data-tag]")
                  .forEach((item) => {
                    item.classList.remove("active");
                  });

                // Hide all children tags
                document.querySelectorAll(".tag-children").forEach((elem) => {
                  elem.classList.remove("visible");
                });
              } else {
                untaggedFilter.classList.remove("active");
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        }

        // Similar implementation for creators and sets filters with the same pattern
        renderCreatorFilters();
        // renderSetFilters();

        // Update the active filter display after rendering all filters
        updateActiveFilterDisplay();
      }

      // Render creator filters
      function renderCreatorFilters() {
        const creatorCounts = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          const creatorName = pattern.creatorName.toLowerCase();
          creatorCounts.set(
            creatorName,
            (creatorCounts.get(creatorName) || 0) + 1
          );
        });

        const creatorFiltersHTML = Array.from(creatorCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([creator, count]) => {
            const isActive = appData.activeFilters.creators.has(creator);
            return `
        <li class="${isActive ? "active" : ""}" data-creator="${creator}">
          ${creator} 
          <span class="filter-count">${count}</span>
        </li>`;
          })
          .join("");

        elements.creatorFilters.innerHTML =
          creatorFiltersHTML || "<li>No creators available</li>";

        // Setup creator filter click events
        elements.creatorFilters.querySelectorAll("li").forEach((li) => {
          li.addEventListener("click", (e) => {
            const creator = li.getAttribute("data-creator");
            if (!creator) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.creators.delete(creator);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.creators.has(creator)) {
                  appData.activeFilters.creators.delete(creator);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.creators.add(creator);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.creators.has(creator) &&
                  appData.activeFilters.creators.size === 1
                ) {
                  // If this is the only active creator, clicking it should deselect it
                  appData.activeFilters.creators.delete(creator);
                  li.classList.remove("active");
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.creators.clear();
                  elements.creatorFilters
                    .querySelectorAll("li")
                    .forEach((item) => {
                      item.classList.remove("active");
                    });

                  appData.activeFilters.creators.add(creator);
                  li.classList.add("active");
                }
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });
      }

      // Render set filters
      function renderSetFilters() {
        const setCounts = new Map();
        Object.values(appData.patterns).forEach((pattern) => {
          if (!pattern.setName) return;

          const setNameLower = pattern.setName.toLowerCase();
          setCounts.set(setNameLower, (setCounts.get(setNameLower) || 0) + 1);
        });

        const setFiltersHTML = Array.from(setCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([setName, count]) => {
            const isActive = appData.activeFilters.sets.has(setName);
            return `
        <li class="${isActive ? "active" : ""}" data-set="${setName}">
          ${setName} 
          <span class="filter-count">${count}</span>
          ${isActive ? '<span class="filter-remove">×</span>' : ""}
        </li>`;
          })
          .join("");

        elements.setFilters.innerHTML =
          setFiltersHTML || "<li>No sets available</li>";

        // Setup set filter click events
        elements.setFilters.querySelectorAll("li").forEach((li) => {
          li.addEventListener("click", (e) => {
            const setName = li.getAttribute("data-set");
            if (!setName) return;

            // Check if click was on the remove button
            if (e.target.classList.contains("filter-remove")) {
              appData.activeFilters.sets.delete(setName);
              li.classList.remove("active");
            } else {
              // Toggle the filter - clicking an active filter deselects it
              if (e.ctrlKey || e.metaKey) {
                // Toggle with Ctrl/Cmd key - multi-select mode
                if (appData.activeFilters.sets.has(setName)) {
                  appData.activeFilters.sets.delete(setName);
                  li.classList.remove("active");
                } else {
                  appData.activeFilters.sets.add(setName);
                  li.classList.add("active");
                }
              } else {
                // Single select behavior
                if (
                  appData.activeFilters.sets.has(setName) &&
                  appData.activeFilters.sets.size === 1
                ) {
                  // If this is the only active set, clicking it should deselect it
                  appData.activeFilters.sets.delete(setName);
                  li.classList.remove("active");
                } else {
                  // Otherwise clear other filters and select just this one
                  appData.activeFilters.sets.clear();
                  elements.setFilters.querySelectorAll("li").forEach((item) => {
                    item.classList.remove("active");
                  });

                  appData.activeFilters.sets.add(setName);
                  li.classList.add("active");
                }
              }
            }

            renderPatternGallery();
            updateActiveFilterDisplay();
          });
        });
      }

      // Add a new function to show active filters
      function updateActiveFilterDisplay() {
        // Create or get the active filters container
        let activeFiltersContainer = document.getElementById(
          "active-filters-container"
        );
        if (!activeFiltersContainer) {
          // Create the container if it doesn't exist
          activeFiltersContainer = document.createElement("div");
          activeFiltersContainer.id = "active-filters-container";
          activeFiltersContainer.className = "active-filters-container";

          // Insert it after the search bar
          const actionBar = document.querySelector(".action-bar");
          const searchBarDiv =
            actionBar.querySelector(".search-bar").parentNode;

          // Create a wrapper div to contain filters and maintain layout
          const filterWrapperDiv = document.createElement("div");
          filterWrapperDiv.className = "filter-wrapper";
          filterWrapperDiv.appendChild(activeFiltersContainer);

          // Insert in the middle of the action bar (after search, before controls)
          actionBar.insertBefore(
            filterWrapperDiv,
            actionBar.querySelector("#selection-mode-btn")
          );
        }

        // Check if we have any active filters
        const hasActiveFilters =
          appData.activeFilters.tags.size > 0 ||
          appData.activeFilters.creators.size > 0 ||
          appData.activeFilters.sets.size > 0 ||
          appData.activeFilters.untagged ||
          appData.activeFilters.search;

        // Clear the container
        activeFiltersContainer.innerHTML = "";

        // If no active filters, hide the container
        if (!hasActiveFilters) {
          activeFiltersContainer.style.display = "none";
          return;
        }

        // Show the container
        activeFiltersContainer.style.display = "flex";

        // Add title
        const title = document.createElement("div");
        title.className = "active-filters-title";
        title.textContent = "Active Filters:";
        activeFiltersContainer.appendChild(title);

        // Add filters list
        const filtersList = document.createElement("div");
        filtersList.className = "active-filters-list";

        // Add search filter if active
        if (appData.activeFilters.search) {
          const searchFilter = document.createElement("span");
          searchFilter.className = "active-filter search-filter";
          searchFilter.innerHTML = `Search: "${appData.activeFilters.search}" <span class="filter-remove" data-type="search">×</span>`;
          filtersList.appendChild(searchFilter);
        }

        // Add untagged filter if active
        if (appData.activeFilters.untagged) {
          const untaggedFilter = document.createElement("span");
          untaggedFilter.className = "active-filter tag-filter";
          untaggedFilter.innerHTML = `🏷️ untagged <span class="filter-remove" data-type="untagged">×</span>`;
          filtersList.appendChild(untaggedFilter);
        }

        // Add tag filters - group hierarchical tags by parent
        const tagGroups = new Map();

        // Group tags by their top-level parent
        appData.activeFilters.tags.forEach((tag) => {
          const segments = tag.split(">");
          const topLevelTag = segments[0];

          if (!tagGroups.has(topLevelTag)) {
            tagGroups.set(topLevelTag, []);
          }

          tagGroups.get(topLevelTag).push(tag);
        });

        // Create filter elements for each tag group
        tagGroups.forEach((tags, topLevelTag) => {
          const tagFilter = document.createElement("span");
          tagFilter.className = "active-filter tag-filter";

          // Sort tags by hierarchy depth
          tags.sort((a, b) => a.split(">").length - b.split(">").length);

          // Format tags nicely
          let tagContent = `🏷️ ${topLevelTag}`;

          // Add sub-tags if present (skip duplicates and top level)
          const subTags = tags.filter(
            (t) => t !== topLevelTag && t.startsWith(topLevelTag + ">")
          );

          // TODO: would be nicer if it said the subtag name
          if (subTags.length > 0) {
            tagContent += ` (${subTags.length} sub-tag${
              subTags.length > 1 ? "s" : ""
            })`;
          }

          tagFilter.innerHTML = `${tagContent} <span class="filter-remove" data-type="tag" data-value="${topLevelTag}">×</span>`;
          tagFilter.title = tags.join("\n");
          filtersList.appendChild(tagFilter);
        });

        // Add creator filters
        appData.activeFilters.creators.forEach((creator) => {
          const creatorFilter = document.createElement("span");
          creatorFilter.className = "active-filter creator-filter";
          creatorFilter.innerHTML = `🎨 ${creator} <span class="filter-remove" data-type="creator" data-value="${creator}">×</span>`;
          filtersList.appendChild(creatorFilter);
        });

        // Add set filters
        appData.activeFilters.sets.forEach((set) => {
          const setFilter = document.createElement("span");
          setFilter.className = "active-filter set-filter";
          setFilter.innerHTML = `Set: ${set} <span class="filter-remove" data-type="set" data-value="${set}">×</span>`;
          filtersList.appendChild(setFilter);
        });

        activeFiltersContainer.appendChild(filtersList);

        // Add clear all button
        const clearAll = document.createElement("button");
        clearAll.className = "btn btn-secondary clear-all-filters";
        clearAll.textContent = "Clear All";
        activeFiltersContainer.appendChild(clearAll);

        // Add event listeners for remove buttons
        activeFiltersContainer
          .querySelectorAll(".filter-remove")
          .forEach((removeBtn) => {
            removeBtn.addEventListener("click", (e) => {
              const type = e.target.getAttribute("data-type");
              const value = e.target.getAttribute("data-value");

              if (type === "search") {
                appData.activeFilters.search = "";
                document.getElementById("pattern-search").value = "";
              } else if (type === "tag") {
                // For hierarchical tags, remove the top level and all children
                appData.activeFilters.tags.forEach((tag) => {
                  if (tag === value || tag.startsWith(value + ">")) {
                    appData.activeFilters.tags.delete(tag);
                  }
                });
              } else if (type === "creator") {
                appData.activeFilters.creators.delete(value);
              } else if (type === "set") {
                appData.activeFilters.sets.delete(value);
              } else if (type === "untagged") {
                appData.activeFilters.untagged = false;
              }

              renderPatternGallery();
              renderSidebarFilters(); // This will also call updateActiveFilterDisplay again
            });
          });

        // Add event listener for clear all button
        clearAll.addEventListener("click", () => {
          appData.activeFilters.tags.clear();
          appData.activeFilters.creators.clear();
          appData.activeFilters.sets.clear();
          appData.activeFilters.search = "";
          appData.activeFilters.untagged = false;
          document.getElementById("pattern-search").value = "";

          renderPatternGallery();
          renderSidebarFilters();
        });
      }

      // Open pattern detail modal
      function openPatternDetail(patternId) {
        const pattern = appData.patterns[patternId];
        if (!pattern) return;

        // Determine thumbnail source similar to createPatternCard
        let thumbnailSrc = getPatternThumbnailSrc(pattern);

        // Set pattern details in modal (using the determined thumbnail source)
        document.getElementById("modal-pattern-img").src = thumbnailSrc;
        document
          .getElementById("modal-pattern-img")
          .classList.add("pixel-art-image");

        document.getElementById("pattern-name").value = pattern.patternName;
        document.getElementById("pattern-alternate-name").value =
          pattern.alternateName || "";
        document.getElementById("creator-name").value = pattern.creatorName;
        document.getElementById("town-name").value = pattern.townName;
        document.getElementById("pattern-notes").value = pattern.notes || "";

        // Set up tag input
        const tagInput = document.getElementById("tag-input");
        // Clear existing tags except the input
        Array.from(tagInput.children).forEach((child) => {
          if (child.tagName !== "INPUT") {
            tagInput.removeChild(child);
          }
        });

        // Add current tags
        pattern.tags.forEach((tag) => {
          const tagElement = document.createElement("div");
          tagElement.className = "tag-item";
          tagElement.innerHTML = `${tag} <span class="tag-remove">×</span>`;

          // Add click event to remove tag
          tagElement
            .querySelector(".tag-remove")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              tagInput.removeChild(tagElement);
            });

          tagInput.insertBefore(tagElement, tagInput.querySelector("input"));
        });

        // Set up enhanced tag input functionality
        setupTagInput();

        // Set up set selection
        const setSelect = document.getElementById("pattern-set");

        // Clear options except the "None" option
        while (setSelect.options.length > 1) {
          setSelect.remove(1);
        }

        // Add set options
        Object.values(appData.sets).forEach((set) => {
          const option = document.createElement("option");
          option.value = set.id;
          option.textContent = set.name;
          option.selected = pattern.setId === set.id;
          setSelect.appendChild(option);
        });

        // Set order
        document.getElementById("set-order").value = pattern.setOrder || 1;

        // Set data-id attribute for saving
        elements.savePatternBtn.setAttribute("data-id", patternId);

        // Show modal
        elements.patternModal.style.display = "flex";
      }

      // Enhanced tag input handling
      function setupTagInput() {
        const tagInput = document.getElementById("tag-input");
        const input = tagInput.querySelector("input");

        // Clear existing event listeners
        const newInput = input.cloneNode(true);
        input.parentNode.replaceChild(newInput, input);

        // Add event listeners for tag input
        newInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const tag = newInput.value.trim();
            if (tag) {
              addTag(tag);
              newInput.value = "";
            }
          } else if (e.key === "Backspace" && newInput.value === "") {
            // Remove the last tag when backspace is pressed in an empty input
            const tagElements = tagInput.querySelectorAll(".tag-item");
            if (tagElements.length > 0) {
              tagInput.removeChild(tagElements[tagElements.length - 1]);
            }
          }
        });

        // Add autocomplete for tags with hierarchical awareness
        newInput.addEventListener("input", (e) => {
          const value = newInput.value.trim().toLowerCase();

          // Only show suggestions if there's input and it's at least 1 character
          if (value.length < 1) {
            // Remove existing suggestions if input is cleared
            const existingSuggestions =
              document.getElementById("tag-suggestions");
            if (existingSuggestions) {
              existingSuggestions.remove();
            }
            return;
          }

          // Get all existing tags from all patterns
          const allTags = new Set();
          Object.values(appData.patterns).forEach((pattern) => {
            pattern.tags.forEach((tag) => allTags.add(tag.toLowerCase()));
          });

          // Filter tags that match the input
          const matches = [];

          // Try exact matches first
          allTags.forEach((tag) => {
            if (tag.includes(value) && !tagExists(tag)) {
              matches.push(tag);
            }
          });

          // Then try hierarchical completions
          // For example, if input is "shirt", suggest "clothing>shirt" if it exists
          allTags.forEach((tag) => {
            const segments = tag.split(">");
            const lastSegment = segments[segments.length - 1];

            if (
              lastSegment.includes(value) &&
              !matches.includes(tag) &&
              !tagExists(tag)
            ) {
              matches.push(tag);
            }
          });

          // Sort matches alphabetically
          matches.sort((a, b) => a.localeCompare(b));

          // Show top 5 suggestions
          showTagSuggestions(matches.slice(0, 5));
        });

        // Focus the input field
        newInput.focus();
      }

      // Function to add a new tag
      function addTag(tag) {
        // Skip empty tags
        tag = tag.trim();
        if (!tag) return;

        const tagInput = document.getElementById("tag-input");

        // Check if tag already exists
        if (tagExists(tag)) return;

        // Parse hierarchical tag
        const segments = tag.split(">");

        // Generate all parent tags that need to be included
        const tagsToAdd = [];
        let currentPath = "";

        for (const segment of segments) {
          currentPath = currentPath ? `${currentPath}>${segment}` : segment;
          tagsToAdd.push(currentPath);
        }

        // Add all necessary tags (avoiding duplicates)
        for (const tagToAdd of tagsToAdd) {
          if (!tagExists(tagToAdd)) {
            const tagElement = document.createElement("div");
            tagElement.className = "tag-item";
            tagElement.innerHTML = `${tagToAdd} <span class="tag-remove">×</span>`;

            // Add click event to remove tag
            tagElement
              .querySelector(".tag-remove")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                tagInput.removeChild(tagElement);
              });

            tagInput.insertBefore(tagElement, tagInput.querySelector("input"));
          }
        }
      }

      // Check if tag already exists in the input
      function tagExists(tag) {
        const tagInput = document.getElementById("tag-input");
        const tagElements = tagInput.querySelectorAll(".tag-item");
        const normalizedTag = tag.toLowerCase();

        return Array.from(tagElements).some((el) => {
          const existingTag = el.textContent
            .trim()
            .replace(/\s*×\s*$/, "")
            .toLowerCase();
          return existingTag === normalizedTag;
        });
      }

      // Show tag suggestions
      function showTagSuggestions(suggestions) {
        // Remove existing suggestions
        const existingSuggestions = document.getElementById("tag-suggestions");
        if (existingSuggestions) {
          existingSuggestions.remove();
        }

        if (suggestions.length === 0) return;

        const tagInput = document.getElementById("tag-input");

        // Create suggestions container
        const suggestionsContainer = document.createElement("div");
        suggestionsContainer.id = "tag-suggestions";
        suggestionsContainer.className = "tag-suggestions";

        // Position below the tag input
        const rect = tagInput.getBoundingClientRect();
        suggestionsContainer.style.position = "absolute";
        suggestionsContainer.style.top = `${rect.bottom + window.scrollY}px`;
        suggestionsContainer.style.left = `${rect.left + window.scrollX}px`;
        suggestionsContainer.style.width = `${tagInput.offsetWidth}px`;
        suggestionsContainer.style.zIndex = "1000";
        suggestionsContainer.style.backgroundColor = "white";
        suggestionsContainer.style.border = "1px solid var(--border-color)";
        suggestionsContainer.style.borderRadius = "4px";
        suggestionsContainer.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
        suggestionsContainer.style.maxHeight = "200px";
        suggestionsContainer.style.overflowY = "auto";

        // Add suggestions
        suggestions.forEach((suggestion) => {
          const suggestionElement = document.createElement("div");
          suggestionElement.className = "tag-suggestion-item";
          suggestionElement.textContent = suggestion;
          suggestionElement.style.padding = "8px 12px";
          suggestionElement.style.cursor = "pointer";
          suggestionElement.style.borderBottom =
            "1px solid var(--border-color)";

          // Hover states
          suggestionElement.addEventListener("mouseover", () => {
            suggestionElement.style.backgroundColor =
              "var(--secondary-color-light, #f0f0f0)";
          });

          suggestionElement.addEventListener("mouseout", () => {
            suggestionElement.style.backgroundColor = "";
          });

          suggestionElement.addEventListener("click", () => {
            addTag(suggestion);
            tagInput.querySelector("input").value = "";
            suggestionsContainer.remove();
            tagInput.querySelector("input").focus();
          });

          suggestionsContainer.appendChild(suggestionElement);
        });

        // Add click outside to close suggestions
        document.addEventListener("click", function closeHandler(e) {
          if (
            !suggestionsContainer.contains(e.target) &&
            e.target !== tagInput.querySelector("input")
          ) {
            suggestionsContainer.remove();
            document.removeEventListener("click", closeHandler);
          }
        });

        // Add to document
        document.body.appendChild(suggestionsContainer);
      }

      // Save pattern changes
      function savePatternChanges() {
        const patternId = elements.savePatternBtn.getAttribute("data-id");
        if (!patternId || !appData.patterns[patternId]) return;

        const pattern = appData.patterns[patternId];

        // Get alternate name from input
        const alternateName = document
          .getElementById("pattern-alternate-name")
          .value.trim();

        // Get current tags from tag elements
        const tagElements = document.querySelectorAll("#tag-input .tag-item");
        const tags = Array.from(tagElements).map((el) => {
          // Extract tag text without the "×" remove button
          return el.textContent.trim().replace(/\s*×\s*$/, "");
        });

        // Get set selection
        const setSelect = document.getElementById("pattern-set");
        const setId = setSelect.value;

        // Get previous setId to handle set removal
        const previousSetId = pattern.setId;

        // Get set name from selected option
        const setName = setId
          ? setSelect.options[setSelect.selectedIndex].text
          : "";

        // Get set order
        const setOrder =
          parseInt(document.getElementById("set-order").value) || 1;

        // Get notes
        const notes = document.getElementById("pattern-notes").value.trim();

        // Update pattern
        pattern.alternateName = alternateName;
        pattern.tags = tags;
        pattern.setId = setId;
        pattern.setName = setName;
        pattern.setOrder = setOrder;
        pattern.notes = notes;
        pattern.lastModified = new Date().toISOString().split("T")[0];

        // Handle set changes

        // If the pattern was removed from a set
        if (previousSetId && previousSetId !== setId) {
          // Remove pattern from previous set
          if (appData.sets[previousSetId]) {
            appData.sets[previousSetId].patterns = appData.sets[
              previousSetId
            ].patterns.filter((id) => id !== patternId);
          }
        }

        // If the pattern was added to a set or stayed in the same set
        if (setId) {
          const set = appData.sets[setId];
          if (set) {
            // Add pattern to set if not already there
            if (!set.patterns.includes(patternId)) {
              set.patterns.push(patternId);
            }

            // Re-sort the set patterns by their setOrder
            const patternsInSet = set.patterns
              .map((id) => appData.patterns[id])
              .filter((p) => p) // Filter out any null patterns
              .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

            // Update the setOrder values to be sequential
            patternsInSet.forEach((p, index) => {
              p.setOrder = index + 1;
            });

            // Update set patterns order
            set.patterns = patternsInSet.map((p) => p.id);
          }
        }

        // Save data
        saveDataToLocalStorage();

        // Close modal
        elements.patternModal.style.display = "none";

        // Refresh views
        renderPatternGallery();
        renderSidebarFilters();

        // If we're on the Sets tab, refresh the sets view
        const activeTab = document.querySelector(".nav-tabs li.active");
        if (activeTab && activeTab.getAttribute("data-tab") === "sets") {
          renderSets();
        }

        showNotification("Pattern updated successfully");
      }

      // Create new set
      function createNewSet() {
        const setName = document.getElementById("set-name").value.trim();
        if (!setName) {
          showNotification("Please enter a set name", "error");
          return;
        }

        const setNotes = document.getElementById("set-notes").value.trim();

        // Get grid size selection
        const gridSizeSelect = document.getElementById("set-grid-size");
        const gridSize = gridSizeSelect.value; // Will be empty string for collection sets

        // Generate ID
        const setId = "set-" + Date.now();

        // Create set
        appData.sets[setId] = {
          id: setId,
          name: setName,
          patterns: [],
          notes: setNotes,
          gridSize: gridSize || null, // Store null if no grid size selected
        };

        // Save data
        saveDataToLocalStorage();

        // Close modal and clear inputs
        document.getElementById("set-name").value = "";
        document.getElementById("set-notes").value = "";
        document.getElementById("set-grid-size").value = "";
        elements.setModal.style.display = "none";

        // Refresh views
        renderSets();
        renderSidebarFilters();

        showNotification("Set created successfully");
      }

      // Render sets view with grid-based layout (preserving drag and drop)
      // Render sets view with grid-based layout
      function renderSets() {
        const setManager = elements.setManager;
        setManager.innerHTML = "";

        // Remove any "no results" message from previous searches
        const noResultsMsg = document.getElementById("no-set-results");
        if (noResultsMsg) noResultsMsg.remove();

        // Reset search input
        const searchInput = document.getElementById("set-search");
        if (searchInput) searchInput.value = "";

        const sets = Object.values(appData.sets);

        if (sets.length === 0) {
          setManager.innerHTML =
            "<p>No sets available. Create a new set to get started.</p>";
          return;
        }

        sets.forEach((set) => {
          // Get patterns in this set
          const setPatterns = set.patterns
            .map((id) => appData.patterns[id])
            .filter((pattern) => pattern) // Filter out any null/undefined patterns
            .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

          if (setPatterns.length === 0) return; // Skip empty sets

          // Determine grid type and class
          let gridClass = "";
          let gridHTML = "";

          if (set.gridSize) {
            const [rows, cols] = set.gridSize
              .split("x")
              .map((num) => parseInt(num, 10));

            // Set appropriate grid class
            if (cols > rows) {
              gridClass = "horizontal-grid";
            } else if (rows > cols) {
              gridClass = "vertical-grid";
            } else {
              gridClass = "square-grid";
            }

            // Create grid display with appropriate styling
            gridHTML = `
        <div class="set-grid-display ${gridClass}" style="
          grid-template-rows: repeat(${rows}, 1fr);
          grid-template-columns: repeat(${cols}, 1fr);">
      `;

            // Add patterns in order
            for (
              let i = 0;
              i < Math.min(rows * cols, setPatterns.length);
              i++
            ) {
              const pattern = setPatterns[i];
              gridHTML += `
          <div class="set-grid-item" data-id="${pattern.id}" data-order="${
                i + 1
              }">
            <img src="${getPatternThumbnailSrc(pattern)}" 
                alt="${pattern.patternName}"
                title="${pattern.patternName}" 
                class="pixel-art-image">
          </div>
        `;
            }

            // Fill in empty spaces if the grid isn't complete
            for (let i = setPatterns.length; i < rows * cols; i++) {
              gridHTML += `
          <div class="set-grid-item empty">
            <div class="empty-grid-item"></div>
          </div>
        `;
            }

            gridHTML += "</div>";
          } else {
            // For non-grid sets, create a collection display (2x2 or 3x3)
            const collectionClass = setPatterns.length > 4 ? "large" : "";
            const columns = setPatterns.length > 4 ? 3 : 2;

            gridHTML = `<div class="set-collection-display ${collectionClass}">`;

            // Add up to 9 patterns (3x3) or 4 patterns (2x2)
            const maxPatterns = columns === 3 ? 9 : 4;

            for (
              let i = 0;
              i < Math.min(maxPatterns, setPatterns.length);
              i++
            ) {
              const pattern = setPatterns[i];
              gridHTML += `
          <div class="set-grid-item" data-id="${pattern.id}" data-order="${
                i + 1
              }">
            <img src="${getPatternThumbnailSrc(pattern)}" 
                alt="${pattern.patternName}"
                title="${pattern.patternName}" 
                class="pixel-art-image">
          </div>
        `;
            }

            // If there are more patterns than we can show, add a counter for the rest
            if (setPatterns.length > maxPatterns) {
              const remainingCount = setPatterns.length - maxPatterns;
              gridHTML += `
          <div class="set-grid-item more">
            <div class="more-patterns">+${remainingCount} more</div>
          </div>
        `;
            }

            gridHTML += "</div>";
          }

          // Create set item element
          const setItem = document.createElement("div");
          setItem.className = `set-item ${gridClass}`;
          setItem.setAttribute("data-id", set.id);

          // Calculate creator information
          const creatorInfo = getSetCreatorInfo(set.patterns);

          // Create set HTML
          setItem.innerHTML = `
            <div class="set-header">
              <h3>
                ${set.name}
                <span class="set-counter">${setPatterns.length}</span>
              </h3>
              <div class="set-creator">by ${creatorInfo.name} of ${
                  creatorInfo.town
                }</div>
              ${
                set.gridSize
                  ? `<div class="set-grid-info">${set.gridSize} grid</div>`
                  : ""
              }
              ${set.notes ? `<p>${set.notes}</p>` : ""}
            </div>
            
            ${gridHTML}
            
            <div class="set-actions">
              <button class="btn btn-secondary" data-action="edit" data-id="${
                set.id
              }">Edit</button>
              <button class="btn btn-secondary" data-action="delete" data-id="${
                set.id
              }">Delete</button>
            </div>
          `;

          // Add click event for grid items to show pattern details
          setItem
            .querySelectorAll(".set-grid-item[data-id]")
            .forEach((gridItem) => {
              gridItem.addEventListener("click", () => {
                const patternId = gridItem.getAttribute("data-id");
                openPatternDetail(patternId);
              });
            });

          // Add event listeners for buttons
          setItem
            .querySelector('[data-action="edit"]')
            .addEventListener("click", () => {
              editSet(set.id);
            });

          setItem
            .querySelector('[data-action="delete"]')
            .addEventListener("click", () => {
              deleteSet(set.id);
            });

          setManager.appendChild(setItem);
        });
      }

      // Setup drag and drop for pattern ordering in the Sets view
      function setupDragAndDrop(container) {
        if (!container) return;

        const patterns = container.querySelectorAll(".set-pattern");
        let draggedItem = null;

        // Create drop indicator
        let dropIndicator = document.createElement("div");
        dropIndicator.className = "drop-indicator";
        document.body.appendChild(dropIndicator);

        // Position container to allow absolute positioning within
        if (window.getComputedStyle(container).position === "static") {
          container.style.position = "relative";
        }

        // Initialize drag events
        patterns.forEach((pattern) => {
          pattern.setAttribute("draggable", "true");

          pattern.addEventListener("dragstart", (e) => {
            draggedItem = pattern;
            e.dataTransfer.setData(
              "text/plain",
              pattern.getAttribute("data-id")
            );
            setTimeout(() => pattern.classList.add("dragging"), 0);
          });

          pattern.addEventListener("dragend", () => {
            pattern.classList.remove("dragging");
            dropIndicator.style.display = "none";
            draggedItem = null;
          });

          pattern.addEventListener("click", () => {
            const patternId = pattern.getAttribute("data-id");
            openPatternDetail(patternId);
          });
        });

        // Track target for insertion
        let targetItem = null;
        let insertBefore = true;

        container.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";

          if (!draggedItem) return;

          // Get container position
          const containerRect = container.getBoundingClientRect();

          // Find possible drop positions
          const items = [...container.querySelectorAll(".set-pattern")];

          // If no items or only the dragged item, position at the start
          if (items.length <= 1) {
            positionIndicatorAtStart();
            return;
          }

          // Find the immediate item under the cursor
          const elemUnderCursor = document.elementFromPoint(
            e.clientX,
            e.clientY
          );
          const itemUnderCursor = elemUnderCursor?.closest(".set-pattern");

          if (itemUnderCursor && itemUnderCursor !== draggedItem) {
            // We're directly over an item
            const rect = itemUnderCursor.getBoundingClientRect();
            const mouseX = e.clientX;

            // Determine if we're on the left or right half of the item
            const itemCenter = rect.left + rect.width / 2;
            const beforeItem = mouseX < itemCenter;

            // Only update indicator if position changed
            if (targetItem !== itemUnderCursor || insertBefore !== beforeItem) {
              targetItem = itemUnderCursor;
              insertBefore = beforeItem;

              // Position the indicator
              positionIndicator(
                itemUnderCursor,
                beforeItem ? "before" : "after"
              );
            }
          } else {
            // We're in empty space - find the nearest item
            let closestItem = null;
            let minDistance = Infinity;
            let closestPosition = "after";

            items.forEach((item) => {
              if (item === draggedItem) return;

              const rect = item.getBoundingClientRect();

              // Calculate distances to left and right edges
              const distToLeft = Math.abs(e.clientX - rect.left);
              const distToRight = Math.abs(e.clientX - rect.right);

              if (distToLeft < minDistance) {
                closestItem = item;
                minDistance = distToLeft;
                closestPosition = "before";
              }

              if (distToRight < minDistance) {
                closestItem = item;
                minDistance = distToRight;
                closestPosition = "after";
              }
            });

            if (closestItem) {
              if (
                targetItem !== closestItem ||
                insertBefore !== (closestPosition === "before")
              ) {
                targetItem = closestItem;
                insertBefore = closestPosition === "before";
                positionIndicator(closestItem, closestPosition);
              }
            } else {
              // Fallback to start of container
              positionIndicatorAtStart();
            }
          }

          function positionIndicator(element, position) {
            const rect = element.getBoundingClientRect();
            const scrollTop =
              window.scrollY || document.documentElement.scrollTop;
            const scrollLeft =
              window.scrollX || document.documentElement.scrollLeft;

            dropIndicator.style.display = "block";
            dropIndicator.style.height = `${rect.height}px`;
            dropIndicator.style.width = "4px";
            dropIndicator.style.position = "absolute";
            dropIndicator.style.backgroundColor = "var(--primary-color)";
            dropIndicator.style.borderRadius = "2px";
            dropIndicator.style.zIndex = "10000";
            dropIndicator.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";

            if (position === "before") {
              dropIndicator.style.left = `${rect.left + scrollLeft - 2}px`;
            } else {
              dropIndicator.style.left = `${rect.right + scrollLeft - 2}px`;
            }

            dropIndicator.style.top = `${rect.top + scrollTop}px`;
          }

          function positionIndicatorAtStart() {
            const rect = containerRect;
            const scrollTop =
              window.scrollY || document.documentElement.scrollTop;
            const scrollLeft =
              window.scrollX || document.documentElement.scrollLeft;

            dropIndicator.style.display = "block";
            dropIndicator.style.height = `${
              items[0]?.getBoundingClientRect().height || 32
            }px`;
            dropIndicator.style.width = "4px";
            dropIndicator.style.position = "absolute";
            dropIndicator.style.backgroundColor = "var(--primary-color)";
            dropIndicator.style.borderRadius = "2px";
            dropIndicator.style.zIndex = "10000";
            dropIndicator.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";

            dropIndicator.style.left = `${rect.left + scrollLeft + 5}px`;
            dropIndicator.style.top = `${rect.top + scrollTop + 5}px`;

            targetItem = null;
            insertBefore = true;
          }
        });

        container.addEventListener("dragleave", (e) => {
          // Only hide indicator if leaving the container itself
          if (!container.contains(e.relatedTarget)) {
            dropIndicator.style.display = "none";
            targetItem = null;
          }
        });

        container.addEventListener("drop", (e) => {
          e.preventDefault();
          dropIndicator.style.display = "none";

          if (!draggedItem) return;

          const patternId = draggedItem.getAttribute("data-id");
          const setId = container
            .closest(".set-item")
            .querySelector('[data-action="edit"]')
            .getAttribute("data-id");

          if (targetItem) {
            // If we have a target and insert position
            if (insertBefore) {
              // Insert before target
              if (
                targetItem !== draggedItem &&
                targetItem.previousSibling !== draggedItem
              ) {
                container.insertBefore(draggedItem, targetItem);
              }
            } else {
              // Insert after target
              if (
                targetItem !== draggedItem &&
                targetItem.nextSibling !== draggedItem
              ) {
                if (targetItem.nextSibling) {
                  container.insertBefore(draggedItem, targetItem.nextSibling);
                } else {
                  container.appendChild(draggedItem);
                }
              }
            }
          } else {
            // Default to appending at the end
            container.appendChild(draggedItem);
          }

          // Update pattern orders in data model
          const patterns = container.querySelectorAll(".set-pattern");
          patterns.forEach((pattern, index) => {
            const id = pattern.getAttribute("data-id");
            if (appData.patterns[id]) {
              appData.patterns[id].setOrder = index + 1;
            }
          });

          // Update set patterns array order
          if (appData.sets[setId]) {
            const newOrder = Array.from(patterns).map((p) =>
              p.getAttribute("data-id")
            );
            appData.sets[setId].patterns = newOrder;
          }

          // Save to localStorage
          saveDataToLocalStorage();

          // Clean up
          targetItem = null;
        });

        // Clean up when done
        return () => {
          if (document.body.contains(dropIndicator)) {
            document.body.removeChild(dropIndicator);
          }
        };
      }

      // Helper function for drag and drop
      function getDragAfterElement(container, x) {
        const draggableElements = [
          ...container.querySelectorAll(".set-pattern:not(.dragging)"),
        ];

        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = x - box.left - box.width / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      // Edit set
      function editSet(setId) {
        const set = appData.sets[setId];
        if (!set) return;

        // Clone the create set modal for editing
        const editModal = elements.setModal.cloneNode(true);
        document.body.appendChild(editModal);

        // Update modal title and button text
        editModal.querySelector(".modal-title").textContent = "Edit Set";
        editModal.querySelector("#save-set-btn").textContent = "Save Changes";

        // Create a new ID for the edit modal to avoid conflicts
        editModal.id = "edit-set-modal";

        // Set values
        editModal.querySelector("#set-name").value = set.name;
        editModal.querySelector("#set-notes").value = set.notes || "";

        // Find or create grid size select
        let gridSizeSelect = editModal.querySelector("#set-grid-size");
        if (!gridSizeSelect) {
          // If the set modal hasn't been updated yet, add the grid size field
          const notesFormGroup = editModal
            .querySelector('label[for="set-notes"]')
            .closest(".form-group");

          const gridSizeFormGroup = document.createElement("div");
          gridSizeFormGroup.className = "form-group";
          gridSizeFormGroup.innerHTML = `
            <label for="set-grid-size">Grid Size (Optional)</label>
            <select id="set-grid-size">
              <option value="">No Grid (Pattern Collection)</option>
                <option value="2x2">2 × 2 Grid</option>
                <option value="3x3">3 × 3 Grid</option>
                <option value="4x4">4 × 4 Grid</option>
                <option value="1x2">1 × 2 Grid (Horiz)</option>
                <option value="1x3">1 × 3 Grid (Horiz)</option>
                <option value="1x4">1 × 4 Grid (Horiz)</option>
                <option value="2x3">2 × 3 Grid (Horiz)</option>
                <option value="2x4">2 × 4 Grid (Horiz)</option>
                <option value="2x1">2 × 1 Grid (Vert)</option>
                <option value="3x1">3 × 1 Grid (Vert)</option>
                <option value="4x1">4 × 1 Grid (Vert)</option>
            </select>
            <p class="help-text">Select a grid size if this set forms a larger image when combined, or leave as "No Grid" if it's just a collection.</p>
          `;

          notesFormGroup.after(gridSizeFormGroup);
          gridSizeSelect = editModal.querySelector("#set-grid-size");
        }

        // Set grid size value
        if (set.gridSize) {
          gridSizeSelect.value = set.gridSize;
        } else {
          gridSizeSelect.value = "";
        }

        // Add pattern management section
        const formGroup = document.createElement("div");
        formGroup.className = "form-group full-width";
        formGroup.innerHTML = `
          <label>Patterns</label>
          <div class="set-patterns-container">
            <div class="set-patterns" id="edit-set-patterns"></div>
          </div>
          <p class="help-text">Drag to reorder. Click to remove.</p>
        `;

        // Insert before save button
        const saveBtn = editModal.querySelector("#save-set-btn");
        saveBtn.parentNode.insertBefore(formGroup, saveBtn);

        // Get patterns in this set
        const setPatterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern) // Filter out any null/undefined patterns
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        // Populate patterns
        const patternsContainer = editModal.querySelector("#edit-set-patterns");

        setPatterns.forEach((pattern) => {
          const patternElement = document.createElement("div");
          patternElement.className = "set-pattern-item";
          patternElement.setAttribute("data-id", pattern.id);
          patternElement.setAttribute("draggable", "true");

          patternElement.innerHTML = `
            <img src="${getPatternThumbnailSrc(pattern)}" 
                class="set-pattern pixel-art-image" 
                title="${pattern.patternName}">
            <div class="pattern-order">${pattern.setOrder || 0}</div>
            <!--<div class="pattern-name">${pattern.patternName}</div>-->
            <button class="remove-pattern" title="Remove from set">×</button>
        `;

          patternsContainer.appendChild(patternElement);
        });

        // Add button to add more patterns
        const addPatternsBtn = document.createElement("button");
        addPatternsBtn.className = "btn btn-secondary";
        addPatternsBtn.textContent = "Add Patterns";
        addPatternsBtn.style.marginTop = "10px";
        formGroup.appendChild(addPatternsBtn);

        // Setup drag and drop for pattern ordering
        setupSetDragAndDrop(patternsContainer);

        // Remove pattern event listeners
        patternsContainer.querySelectorAll(".remove-pattern").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const patternItem = btn.closest(".set-pattern-item");
            const patternId = patternItem.getAttribute("data-id");

            if (confirm("Remove this pattern from the set?")) {
              patternItem.remove();
              updatePatternOrders(patternsContainer);
            }
          });
        });

        // Add patterns button click
        addPatternsBtn.addEventListener("click", () => {
          showAddPatternsModal(setId, patternsContainer);
        });

        // Save changes
        const saveEditBtn = editModal.querySelector("#save-set-btn");
        saveEditBtn.addEventListener("click", () => {
          // Update set data
          set.name = editModal.querySelector("#set-name").value.trim();
          set.notes = editModal.querySelector("#set-notes").value.trim();

          // Update grid size
          const gridSizeSelect = editModal.querySelector("#set-grid-size");
          set.gridSize = gridSizeSelect.value || null;

          // Get pattern order from UI
          const patternItems =
            patternsContainer.querySelectorAll(".set-pattern-item");
          const patternIds = Array.from(patternItems).map((item) =>
            item.getAttribute("data-id")
          );

          // Validate that all patterns are from the same creator
          if (!validateSetCreator(patternIds)) {
            showNotification(
              "Cannot save set with patterns from different creators",
              "error"
            );
            return;
          }

          // Update set patterns
          set.patterns = patternIds;

          // Update pattern setOrder values
          patternIds.forEach((id, index) => {
            if (appData.patterns[id]) {
              appData.patterns[id].setOrder = index + 1;
            }
          });

          // Check for removed patterns and update them
          const removedPatternIds = set.patterns.filter(
            (id) => !patternIds.includes(id)
          );
          removedPatternIds.forEach((id) => {
            if (appData.patterns[id]) {
              appData.patterns[id].setId = "";
              appData.patterns[id].setName = "";
              appData.patterns[id].setOrder = 0;
            }
          });

          // Save data
          saveDataToLocalStorage();

          // Remove modal
          document.body.removeChild(editModal);

          // Refresh views
          renderSets();
          renderSidebarFilters();
          renderPatternGallery();

          showNotification("Set updated successfully");
        });

        // Close button
        const closeBtn = editModal.querySelector(".modal-close");
        closeBtn.addEventListener("click", () => {
          document.body.removeChild(editModal);
        });

        // Show the modal
        editModal.style.display = "flex";
      }

      // Setup drag and drop for set editing
      function setupSetDragAndDrop(container) {
        if (!container) return;

        const patternItems = container.querySelectorAll(".set-pattern-item");
        let draggedItem = null;

        // Create drop indicator
        let dropIndicator = document.createElement("div");
        dropIndicator.className = "drop-indicator";
        document.body.appendChild(dropIndicator);

        // Position container to allow absolute positioning within
        if (window.getComputedStyle(container).position === "static") {
          container.style.position = "relative";
        }

        // Initialize drag events
        patternItems.forEach((item) => {
          item.setAttribute("draggable", "true");

          item.addEventListener("dragstart", (e) => {
            draggedItem = item;
            e.dataTransfer.setData("text/plain", item.getAttribute("data-id"));
            setTimeout(() => item.classList.add("dragging"), 0);
          });

          item.addEventListener("dragend", () => {
            item.classList.remove("dragging");
            dropIndicator.style.display = "none";
            draggedItem = null;
          });

          // Prevent opening pattern detail when clicking on a pattern in edit mode
          item.addEventListener("click", (e) => {
            e.stopPropagation();
          });
        });

        // Track last insert position to prevent constant repositioning
        let lastInsertPosition = null;
        let targetItem = null;
        let insertBefore = true;

        container.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";

          if (!draggedItem) return;

          // Get container position
          const containerRect = container.getBoundingClientRect();

          // Find possible drop positions
          const items = [...container.querySelectorAll(".set-pattern-item")];

          // If no items or only the dragged item, position at the start
          if (items.length <= 1) {
            positionIndicatorAtStart();
            return;
          }

          // Find the immediate item under the cursor
          const elemUnderCursor = document.elementFromPoint(
            e.clientX,
            e.clientY
          );
          const itemUnderCursor = elemUnderCursor?.closest(".set-pattern-item");

          if (itemUnderCursor && itemUnderCursor !== draggedItem) {
            // We're directly over an item
            const rect = itemUnderCursor.getBoundingClientRect();
            const mouseX = e.clientX;

            // Determine if we're on the left or right half of the item
            const itemCenter = rect.left + rect.width / 2;
            const beforeItem = mouseX < itemCenter;

            // Only update indicator if position changed
            if (targetItem !== itemUnderCursor || insertBefore !== beforeItem) {
              targetItem = itemUnderCursor;
              insertBefore = beforeItem;

              // Position the indicator
              positionIndicator(
                itemUnderCursor,
                beforeItem ? "before" : "after"
              );
            }
          } else {
            // We're in empty space - find the nearest item
            let closestItem = null;
            let minDistance = Infinity;
            let closestPosition = "after";

            items.forEach((item) => {
              if (item === draggedItem) return;

              const rect = item.getBoundingClientRect();

              // Calculate distances to left and right edges
              const distToLeft = Math.abs(e.clientX - rect.left);
              const distToRight = Math.abs(e.clientX - rect.right);

              if (distToLeft < minDistance) {
                closestItem = item;
                minDistance = distToLeft;
                closestPosition = "before";
              }

              if (distToRight < minDistance) {
                closestItem = item;
                minDistance = distToRight;
                closestPosition = "after";
              }
            });

            if (closestItem) {
              if (
                targetItem !== closestItem ||
                insertBefore !== (closestPosition === "before")
              ) {
                targetItem = closestItem;
                insertBefore = closestPosition === "before";
                positionIndicator(closestItem, closestPosition);
              }
            } else {
              // Fallback to start of container
              positionIndicatorAtStart();
            }
          }

          function positionIndicator(element, position) {
            const rect = element.getBoundingClientRect();
            const scrollTop =
              window.scrollY || document.documentElement.scrollTop;
            const scrollLeft =
              window.scrollX || document.documentElement.scrollLeft;

            dropIndicator.style.display = "block";
            dropIndicator.style.height = `${rect.height}px`;
            dropIndicator.style.width = "4px";
            dropIndicator.style.position = "absolute";
            dropIndicator.style.backgroundColor = "var(--primary-color)";
            dropIndicator.style.borderRadius = "2px";
            dropIndicator.style.zIndex = "10000";
            dropIndicator.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";

            if (position === "before") {
              dropIndicator.style.left = `${rect.left + scrollLeft - 2}px`;
            } else {
              dropIndicator.style.left = `${rect.right + scrollLeft - 2}px`;
            }

            dropIndicator.style.top = `${rect.top + scrollTop}px`;
          }

          function positionIndicatorAtStart() {
            const rect = containerRect;
            const scrollTop =
              window.scrollY || document.documentElement.scrollTop;
            const scrollLeft =
              window.scrollX || document.documentElement.scrollLeft;

            dropIndicator.style.display = "block";
            dropIndicator.style.height = `50px`;
            dropIndicator.style.width = "4px";
            dropIndicator.style.position = "absolute";
            dropIndicator.style.backgroundColor = "var(--primary-color)";
            dropIndicator.style.borderRadius = "2px";
            dropIndicator.style.zIndex = "10000";
            dropIndicator.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";

            dropIndicator.style.left = `${rect.left + scrollLeft + 5}px`;
            dropIndicator.style.top = `${rect.top + scrollTop + 10}px`;

            targetItem = null;
            insertBefore = true;
          }
        });

        container.addEventListener("dragleave", (e) => {
          // Only hide indicator if leaving the container itself
          if (!container.contains(e.relatedTarget)) {
            dropIndicator.style.display = "none";
            targetItem = null;
          }
        });

        container.addEventListener("drop", (e) => {
          e.preventDefault();

          if (!draggedItem) return;

          if (targetItem) {
            // If we have a target and insert position
            if (insertBefore) {
              // Insert before target
              if (
                targetItem !== draggedItem &&
                targetItem.previousSibling !== draggedItem
              ) {
                container.insertBefore(draggedItem, targetItem);
              }
            } else {
              // Insert after target
              if (
                targetItem !== draggedItem &&
                targetItem.nextSibling !== draggedItem
              ) {
                if (targetItem.nextSibling) {
                  container.insertBefore(draggedItem, targetItem.nextSibling);
                } else {
                  container.appendChild(draggedItem);
                }
              }
            }
          } else {
            // Default to appending at the end
            container.appendChild(draggedItem);
          }

          // Clean up
          dropIndicator.style.display = "none";
          targetItem = null;

          // Update order numbers
          updatePatternOrders(container);
        });

        // Clean up when done
        return () => {
          if (document.body.contains(dropIndicator)) {
            document.body.removeChild(dropIndicator);
          }
        };
      }

      // Get element to insert after when dragging
      function getDragAfterElement(container, y) {
        const draggableElements = [
          ...container.querySelectorAll(".set-pattern-item:not(.dragging)"),
        ];

        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      // Update pattern order numbers after drag or remove
      function updatePatternOrders(container) {
        const patternItems = container.querySelectorAll(".set-pattern-item");

        patternItems.forEach((item, index) => {
          const orderElement = item.querySelector(".pattern-order");
          if (orderElement) {
            orderElement.textContent = index + 1;
          }
        });
      }

      // Show modal to add patterns to a set
      function showAddPatternsModal(setId, patternsContainer) {
        const set = appData.sets[setId];
        if (!set) return;

        // Get creator info from existing patterns in the set
        let creatorName = null;
        let creatorTown = null;

        if (set.patterns.length > 0) {
          const firstPattern = appData.patterns[set.patterns[0]];
          if (firstPattern) {
            creatorName = firstPattern.creatorName;
            creatorTown = firstPattern.townName;
          }
        }

        // Create modal for pattern selection
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Add Patterns to "${set.name}"</h2>
            ${
              creatorName
                ? `<div class="creator-filter-info">Only showing patterns by ${creatorName} of ${creatorTown}</div>`
                : ""
            }
            <div class="form-group">
              <input type="text" id="pattern-search-input" placeholder="Search patterns...">
            </div>
            <div class="pattern-selection">
              <!-- Patterns will be loaded here -->
            </div>
            <button class="btn" id="add-selected-patterns">Add Selected Patterns</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
          document.body.removeChild(creatorInfoStyle);
          document.body.removeChild(style);
        });

        // Get all patterns
        let patterns = Object.values(appData.patterns);

        // Filter by creator if set already has patterns
        if (creatorName) {
          patterns = patterns.filter(
            (pattern) =>
              pattern.creatorName.toLowerCase() === creatorName.toLowerCase()
          );
        }

        // Already included pattern IDs
        const existingPatternIds = set.patterns;

        // Render patterns
        const patternSelection = modal.querySelector(".pattern-selection");
        renderSelectablePatterns(
          patterns,
          patternSelection,
          existingPatternIds
        );

        // Search input
        const searchInput = modal.querySelector("#pattern-search-input");
        searchInput.addEventListener(
          "input",
          debounce(() => {
            const searchTerm = searchInput.value.trim().toLowerCase();

            let filteredPatterns = patterns;
            if (searchTerm) {
              filteredPatterns = patterns.filter(
                (pattern) =>
                  pattern.patternName.toLowerCase().includes(searchTerm) ||
                  pattern.creatorName.toLowerCase().includes(searchTerm)
              );
            }

            renderSelectablePatterns(
              filteredPatterns,
              patternSelection,
              existingPatternIds
            );
          }, 300)
        );

        // Add selected patterns button
        const addSelectedBtn = modal.querySelector("#add-selected-patterns");
        addSelectedBtn.addEventListener("click", () => {
          const selectedItems = patternSelection.querySelectorAll(
            ".pattern-select-item.selected"
          );

          if (selectedItems.length === 0) {
            alert("Please select at least one pattern to add.");
            return;
          }

          // Get current patterns in the set
          const currentItems =
            patternsContainer.querySelectorAll(".set-pattern-item");
          const nextOrder = currentItems.length + 1;

          // Add each selected pattern to the set
          selectedItems.forEach((item, index) => {
            const patternId = item.getAttribute("data-id");
            const pattern = appData.patterns[patternId];

            // Skip if already in the container
            if (
              patternsContainer.querySelector(
                `.set-pattern-item[data-id="${patternId}"]`
              )
            ) {
              return;
            }

            // Create pattern element
            const patternElement = document.createElement("div");
            patternElement.className = "set-pattern-item";
            patternElement.setAttribute("data-id", patternId);
            patternElement.setAttribute("draggable", "true");

            patternElement.innerHTML = `
              <img src="${getPatternThumbnailSrc(pattern)}" 
                  class="set-pattern pixel-art-image" 
                  title="${pattern.patternName}">
              <div class="pattern-order">${nextOrder + index}</div>
              <div class="pattern-name">${pattern.patternName}</div>
              <button class="remove-pattern" title="Remove from set">×</button>
            `;

            patternsContainer.appendChild(patternElement);

            // Add event listener for remove button
            patternElement
              .querySelector(".remove-pattern")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                if (confirm("Remove this pattern from the set?")) {
                  patternElement.remove();
                  updatePatternOrders(patternsContainer);
                }
              });
          });

          // Update drag and drop
          setupSetDragAndDrop(patternsContainer);

          // Update pattern orders
          updatePatternOrders(patternsContainer);

          // Close the modal
          document.body.removeChild(modal);
          document.body.removeChild(creatorInfoStyle);
          document.body.removeChild(style);

          showNotification(`Added ${selectedItems.length} patterns to the set`);
        });
      }

      // Render patterns for selection
      function renderSelectablePatterns(
        patterns,
        container,
        existingPatternIds
      ) {
        container.innerHTML = "";

        if (patterns.length === 0) {
          container.innerHTML = "<p>No patterns found.</p>";
          return;
        }

        patterns.forEach((pattern) => {
          const isInSet = existingPatternIds.includes(pattern.id);

          const item = document.createElement("div");
          item.className = `pattern-select-item ${isInSet ? "in-set" : ""}`;
          item.setAttribute("data-id", pattern.id);

          item.innerHTML = `
            <img src="${getPatternThumbnailSrc(pattern)}" 
                class="pixel-art-image">
            <div class="pattern-name">${pattern.patternName}</div>
            <div class="pattern-creator">${pattern.creatorName}</div>
            ${isInSet ? '<div class="pattern-in-set">In Set</div>' : ""}
        `;

          // Click to select/deselect
          item.addEventListener("click", () => {
            if (isInSet) return; // Can't select patterns already in set

            item.classList.toggle("selected");
          });

          container.appendChild(item);
        });
      }

      // Delete set
      function deleteSet(setId) {
        if (
          !confirm(
            `Are you sure you want to delete this set? This will not delete the patterns in the set.`
          )
        ) {
          return;
        }

        // Remove set from patterns
        const set = appData.sets[setId];
        if (set) {
          set.patterns.forEach((patternId) => {
            if (appData.patterns[patternId]) {
              appData.patterns[patternId].setName = "";
              appData.patterns[patternId].setId = "";
            }
          });

          // Delete set
          delete appData.sets[setId];

          // Save data
          saveDataToLocalStorage();

          // Refresh views
          renderSets();
          renderSidebarFilters();

          showNotification("Set deleted successfully");
        }
      }

      // Function to validate that all patterns in a set are from the same creator
      function validateSetCreator(patternIds) {
        if (!patternIds || patternIds.length === 0) return true;

        const creatorNames = new Set();

        patternIds.forEach((id) => {
          const pattern = appData.patterns[id];
          if (pattern) {
            creatorNames.add(pattern.creatorName.toLowerCase());
          }
        });

        // Return true if all patterns have the same creator (only one entry in the Set)
        return creatorNames.size === 1;
      }

      // Function to get creator info for a set
      function getSetCreatorInfo(patternIds) {
        if (!patternIds || patternIds.length === 0)
          return { name: "Unknown", town: "Unknown" };

        const pattern = appData.patterns[patternIds[0]];
        if (!pattern) return { name: "Unknown", town: "Unknown" };

        return {
          name: pattern.creatorName,
          town: pattern.townName,
        };
      }

      // Function to render a set card (for pattern gallery view)
      function createSetCard(set) {
        const card = document.createElement("div");
        card.className = "pattern-card set-card";
        card.setAttribute("data-id", set.id);
        card.setAttribute("data-type", "set");

        // Get patterns in this set
        const patterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern)
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        if (patterns.length === 0) return null;

        // Check if all patterns in the set are selected
        const allSelected =
          patterns.length > 0 &&
          patterns.every((pattern) => appData.selectedPatterns.has(pattern.id));

        // Get creator info
        const creatorInfo = getSetCreatorInfo(set.patterns);

        // Selection checkbox (only visible in selection mode)
        const selectionCheckbox = appData.selectionMode
          ? `<div class="pattern-select">
        <input type="checkbox" id="select-${set.id}" ${
              allSelected ? "checked" : ""
            }>
        <label for="select-${set.id}"></label>
      </div>`
          : "";

        let thumbnailsHTML = "";

        // Check if this is a grid set or a collection set
        if (set.gridSize) {
          const [rows, cols] = set.gridSize
            .split("x")
            .map((num) => parseInt(num, 10));

          // Apply different styles based on grid orientation
          let gridClass = "";
          if (cols > rows) {
            gridClass = "horizontal-grid";
          } else if (rows > cols) {
            gridClass = "vertical-grid";
          } else {
            gridClass = "square-grid";
          }

          // Create grid preview with proper sizing and class
          thumbnailsHTML = `<div class="set-grid-preview ${gridClass}" 
                  style="--rows: ${rows}; --cols: ${cols}; 
                  grid-template-rows: repeat(${rows}, 1fr); 
                  grid-template-columns: repeat(${cols}, 1fr);">`;

          // Add patterns in order
          for (let i = 0; i < Math.min(rows * cols, patterns.length); i++) {
            const pattern = patterns[i];
            thumbnailsHTML += `
        <div class="set-grid-item">
          <img src="${getPatternThumbnailSrc(pattern)}" 
            alt="${pattern.patternName}" class="pixel-art-image">
        </div>
      `;
          }

          // Fill in empty spaces if the grid isn't complete
          for (let i = patterns.length; i < rows * cols; i++) {
            thumbnailsHTML += `
        <div class="set-grid-item empty">
          <div class="empty-grid-item"></div>
        </div>
      `;
          }

          thumbnailsHTML += "</div>";
        } else {
          // Collection set preview (up to 4 thumbnails with "..." if more)
          thumbnailsHTML = '<div class="set-collection-preview">';

          // Show up to 3 thumbnails
          for (let i = 0; i < Math.min(3, patterns.length); i++) {
            const pattern = patterns[i];
            thumbnailsHTML += `
        <div class="set-collection-item">
          <img src="${getPatternThumbnailSrc(pattern)}" 
            alt="${pattern.patternName}" class="pixel-art-image">
        </div>
      `;
          }

          // If there are more than 3 patterns, add the "..." item
          if (patterns.length > 3) {
            thumbnailsHTML += `
        <div class="set-collection-item more">
          <div class="more-patterns">+${patterns.length - 3} more</div>
        </div>
      `;
          }

          thumbnailsHTML += "</div>";
        }

        // Add selected class if all patterns in the set are selected
        if (allSelected) {
          card.classList.add("selected");
        }

        const html = `
    ${selectionCheckbox}
    <div class="set-thumbnail">
      ${thumbnailsHTML}
    </div>
    <div class="pattern-info">
      <div class="pattern-name">${
        set.name
      } <span class="set-badge">Set</span></div>
      <div class="pattern-creator">by ${creatorInfo.name} of ${
          creatorInfo.town
        }</div>
      <div class="set-count">${patterns.length} pattern${
          patterns.length !== 1 ? "s" : ""
        }</div>
      ${
        set.gridSize
          ? `<div class="set-grid-size">${set.gridSize} grid</div>`
          : ""
      }
    </div>
  `;

        card.innerHTML = html;

        // Handle click event
        card.addEventListener("click", (e) => {
          // Check if clicking on checkbox
          if (e.target.type === "checkbox" || e.target.tagName === "LABEL") {
            e.stopPropagation();
            return;
          }

          // For normal clicks when not in selection mode, open set detail
          if (!appData.selectionMode && !e.ctrlKey && !e.metaKey) {
            openSetDetailModal(set.id);
            return;
          }

          // If in selection mode or Ctrl/Cmd clicking, toggle selection of all patterns in set
          if (appData.selectionMode || e.ctrlKey || e.metaKey) {
            togglePatternSelection(set.id);
            e.preventDefault();
          }
        });

        // Add specific handler for the checkbox
        const checkbox = card.querySelector(`#select-${set.id}`);
        if (checkbox) {
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            togglePatternSelection(set.id);
          });
        }

        return card;
      }

      // Function to open set detail modal
      function openSetDetailModal(setId) {
        const set = appData.sets[setId];
        if (!set) return;

        // Get patterns in this set
        const patterns = set.patterns
          .map((id) => appData.patterns[id])
          .filter((pattern) => pattern)
          .sort((a, b) => (a.setOrder || 0) - (b.setOrder || 0));

        if (patterns.length === 0) return;

        // Create modal
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.id = "set-detail-modal";
        modal.style.display = "flex";

        // Get creator info
        const creatorInfo = getSetCreatorInfo(set.patterns);

        // Create grid layout or collection layout based on set type
        let patternsHTML = "";

        if (set.gridSize) {
          const [rows, cols] = set.gridSize
            .split("x")
            .map((num) => parseInt(num, 10));

          patternsHTML = `
            <div class="set-grid-layout" style="grid-template-rows: repeat(${rows}, 1fr); grid-template-columns: repeat(${cols}, 1fr);">
          `;

          // Position patterns in the grid
          for (let i = 0; i < Math.min(rows * cols, patterns.length); i++) {
            const pattern = patterns[i];
            patternsHTML += `
              <div class="set-detail-pattern" data-id="${pattern.id}">
                <img src="${getPatternThumbnailSrc(pattern)}" 
                  alt="${pattern.patternName}" class="pixel-art-image">
                <div class="pattern-name">${pattern.patternName}</div>
              </div>
            `;
          }

          // Fill in empty spaces if the grid isn't complete
          for (let i = patterns.length; i < rows * cols; i++) {
            patternsHTML += `
              <div class="set-detail-pattern empty">
                <div class="empty-grid-item"></div>
                <div class="pattern-name">Empty</div>
              </div>
            `;
          }

          patternsHTML += "</div>";
        } else {
          // Collection view
          patternsHTML = '<div class="set-collection-layout">';

          patterns.forEach((pattern) => {
            patternsHTML += `
              <div class="set-detail-pattern" data-id="${pattern.id}">
                <img src="${getPatternThumbnailSrc(pattern)}" 
                  alt="${pattern.patternName}" class="pixel-art-image">
                <div class="pattern-name">${pattern.patternName}</div>
              </div>
            `;
          });

          patternsHTML += "</div>";
        }

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">${set.name}</h2>
            
            <div class="set-detail-info full-width">
              <div class="creator-info">
                <strong>Creator:</strong> ${creatorInfo.name} of ${
                  creatorInfo.town
                }
              </div>
              <div class="set-detail-meta">
                <div><strong>Patterns:</strong> ${patterns.length}</div>
                ${
                  set.gridSize
                    ? `<div><strong>Grid Size:</strong> ${set.gridSize}</div>`
                    : ""
                }
              </div>
              ${set.notes ? `<div class="set-notes">${set.notes}</div>` : ""}
            </div>
            
            <div class="set-patterns-container full-width">
              ${patternsHTML}
            </div>
            
            <div class="set-actions full-width">
              <button class="btn" id="edit-set-btn" data-id="${setId}">Edit Set</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // Add event listeners
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Edit button
        modal.querySelector("#edit-set-btn").addEventListener("click", () => {
          document.body.removeChild(modal);
          editSet(setId);
        });

        // Pattern click events
        modal
          .querySelectorAll(".set-detail-pattern[data-id]")
          .forEach((patternElement) => {
            patternElement.addEventListener("click", () => {
              const patternId = patternElement.getAttribute("data-id");
              document.body.removeChild(modal);
              openPatternDetail(patternId);
            });
          });
      }

      // Render creators view
      function renderCreators() {
        const creatorList = elements.creatorList;
        creatorList.innerHTML = "";

        // Remove any "no results" message from previous searches
        const noResultsMsg = document.getElementById("no-creator-results");
        if (noResultsMsg) noResultsMsg.remove();

        // Reset search input
        const searchInput = document.getElementById("creator-search");
        if (searchInput) searchInput.value = "";

        const creators = Object.values(appData.creators);

        if (creators.length === 0) {
          creatorList.innerHTML =
            "<p>No creators available. Import patterns to see creators or add one manually using the 'Add Creator' button.</p>";
          return;
        }

        // Apply sorting
        const sort = appData.creatorSort || {
          type: "alphabetical",
          direction: "asc",
        };

        if (sort.type === "alphabetical") {
          creators.sort((a, b) => {
            return sort.direction === "asc"
              ? a.name.localeCompare(b.name)
              : b.name.localeCompare(a.name);
          });
        } else if (sort.type === "pattern-count") {
          creators.sort((a, b) => {
            const countA = a.patterns.length;
            const countB = b.patterns.length;
            return sort.direction === "asc" ? countA - countB : countB - countA;
          });
        }

        creators.forEach((creator) => {
          const creatorCard = document.createElement("div");
          creatorCard.className = "creator-card";

          // Count patterns by this creator
          const patternCount = creator.patterns.length;
          const completionPercentage = calculateCompletionPercentage(creator);

          // Create rank badge
          let rankBadge = "";
          if (creator.rank === "verified") {
            rankBadge =
              '<span class="creator-badges creator-rank verified">Verified 🌟</span>';
          } else if (creator.rank === "plagiarist") {
            rankBadge =
              '<span class="creator-badges creator-rank plagiarist">Plagiarist ⚠️</span>';
          } else {
            rankBadge =
              '<span class="creator-badges creator-rank unknown">Unknown</span>';
          }

          // Create completion badge
          let completionBadge = "";
          if (creator.isComplete) {
            completionBadge =
              '<span class="creator-badges complete">100%</span>';
          } else if (creator.totalPatterns) {
            const percentage = Math.round(completionPercentage);
            completionBadge = `<span class="creator-badges" style="background-color: ${getCompletionColor(
              completionPercentage
            )}">${percentage}%</span>`;
          }

          const html = `
            <div class="creator-header">
              <h3>${creator.name} ${rankBadge} ${completionBadge}</h3>
              <div class="creator-code-container">
                ${
                  creator.creatorCode
                    ? `<span class="creator-code">${creator.creatorCode}</span>`
                    : ""
                }
              </div>
            </div>
            
            <div class="creator-details">
              <div class="creator-detail">
                <div class="detail-label">Town</div>
                <div class="detail-value">${creator.townName}</div>
              </div>
              
              <div class="creator-detail">
                <div class="detail-label">Patterns</div>
                <div class="detail-value">${patternCount} / ${
            creator.totalPatterns || "?"
          }</div>
              </div>
              
              <div class="creator-detail">
                <div class="detail-label">Last Updated</div>
                <div class="detail-value">${getLastUpdatedDate(creator)}</div>
              </div>

              ${
                creator.notes
                  ? `<div class="creator-detail">
                       <div class="detail-value creator-notes">${creator.notes}</div>
                     </div>`
                  : ""
              }
            </div>

            <div class="creator-card-actions">
              <button class="btn btn-secondary" data-action="view" data-id="${
                creator.id
              }">View Patterns</button>
              <button class="btn btn-secondary" data-action="edit" data-id="${
                creator.id
              }">Edit Info</button>
            </div>
          `;

          creatorCard.innerHTML = html;

          // Add event listeners for buttons
          creatorCard
            .querySelector('[data-action="view"]')
            .addEventListener("click", () => {
              viewCreatorPatterns(creator.id);
            });

          creatorCard
            .querySelector('[data-action="edit"]')
            .addEventListener("click", () => {
              editCreator(creator.id);
            });

          creatorList.appendChild(creatorCard);
        });
      }

      // View creator patterns
      function viewCreatorPatterns(creatorId) {
        const creator = appData.creators[creatorId];
        if (!creator) return;

        // Clear all filters first
        appData.activeFilters.tags.clear();
        appData.activeFilters.sets.clear();
        appData.activeFilters.creators.clear();
        appData.activeFilters.search = "";
        document.getElementById("pattern-search").value = "";

        // Add creator filter
        appData.activeFilters.creators.add(creator.name.toLowerCase());

        // Switch to patterns tab
        elements.tabs.forEach((tab) => {
          const tabId = tab.getAttribute("data-tab");
          if (tabId === "patterns") {
            tab.click();
          }
        });

        // Make sure to render the gallery with the new filter
        renderPatternGallery();

        // Update sidebar filters to reflect the active filter
        renderSidebarFilters();
      }

      // Edit creator information
      function editCreator(creatorId) {
        const creator = appData.creators[creatorId];
        if (!creator) return;

        // Create modal for creator editing
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.style.display = "flex";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title">Edit Creator Information</h2>
            <div class="creator-edit-form">
              <div class="form-group creator-form-group">
                <label for="creator-name-input">Creator Name</label>
                <input type="text" id="creator-name-input" value="${
                  creator.name
                }" disabled>
              </div>
              
              <div class="form-group creator-form-group">
                <label for="creator-town-input">Town Name</label>
                <input type="text" id="creator-town-input" value="${
                  creator.townName
                }" disabled>
              </div>
              
              <div class="form-group creator-form-group">
                <label for="creator-code-input">Creator Code</label>
                <input type="text" id="creator-code-input" value="${
                  creator.creatorCode || ""
                }" 
                      placeholder="MA-####-####-####" pattern="MA-\\d{4}-\\d{4}-\\d{4}">
              </div>
              
              <div class="form-group creator-form-group">
                <label for="creator-rank-input">Creator Rank</label>
                <select id="creator-rank-input">
                  <option value="unknown" ${
                    creator.rank !== "verified" && creator.rank !== "plagiarist"
                      ? "selected"
                      : ""
                  }>
                    Unknown (Default)
                  </option>
                  <option value="verified" ${
                    creator.rank === "verified" ? "selected" : ""
                  }>
                    Verified (Original Creator)
                  </option>
                  <option value="plagiarist" ${
                    creator.rank === "plagiarist" ? "selected" : ""
                  }>
                    Plagiarist (Copies Others' Work)
                  </option>
                </select>
              </div>
              
              <div class="form-group creator-form-group">
                <label for="creator-total-input">Total Patterns</label>
                <input type="number" id="creator-total-input" min="0" value="${
                  creator.totalPatterns || 0
                }">
              </div>
              
              <div class="form-group creator-form-group">
                <label for="creator-complete-input">Collection Status</label>
                <select id="creator-complete-input">
                  <option value="false" ${
                    !creator.isComplete ? "selected" : ""
                  }>Incomplete</option>
                  <option value="true" ${
                    creator.isComplete ? "selected" : ""
                  }>Complete</option>
                </select>
              </div>
              
              <div class="form-group full-width">
                <label for="creator-notes-input">Notes</label>
                <textarea id="creator-notes-input" rows="4">${
                  creator.notes || ""
                }</textarea>
              </div>
              
              <div class="form-group creator-stats">
                <h3>Collection Statistics</h3>
                <div class="stats-container">
                  <div class="stat-item">
                    <div class="stat-label">Patterns Backed Up</div>
                    <div class="stat-value">${creator.patterns.length}</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Completion Rate</div>
                    <div class="stat-value completion-rate" style="color: ${getCompletionColor(
                      calculateCompletionPercentage(creator)
                    )}">
                      ${calculateCompletionRate(creator)}
                    </div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Last Updated</div>
                    <div class="stat-value">
                      ${getLastUpdatedDate(creator)}
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="form-actions">
                <button class="btn btn-secondary" id="view-patterns-btn">View Patterns</button>
                <button class="btn" id="save-creator-btn" data-id="${creatorId}">Save Changes</button>
              </div>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // Add Creator Code formatter
        const creatorCodeInput = document.getElementById("creator-code-input");
        creatorCodeInput.addEventListener("input", function (e) {
          let value = this.value.replace(/[^A-Ma-m0-9]/g, "").toUpperCase();

          // Make sure it starts with MA
          if (value.length >= 2 && value.substring(0, 2) !== "MA") {
            value =
              "MA" + value.substring(value.length - Math.min(value.length, 12));
          } else if (value.length < 2) {
            value = value.padStart(2, "M");
          }

          // Format with dashes
          if (value.length > 2) {
            let formatted = value.substring(0, 2) + "-";

            // Add first group of digits
            const firstGroup = value.substring(2, Math.min(6, value.length));
            formatted += firstGroup;

            // Add second group if we have it
            if (value.length > 6) {
              formatted += "-" + value.substring(6, Math.min(10, value.length));

              // Add third group if we have it
              if (value.length > 10) {
                formatted +=
                  "-" + value.substring(10, Math.min(14, value.length));
              }
            }

            value = formatted;
          }

          this.value = value;
        });

        // Close button functionality
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // View patterns button
        document
          .getElementById("view-patterns-btn")
          .addEventListener("click", () => {
            document.body.removeChild(modal);
            viewCreatorPatterns(creatorId);
          });

        // Save button
        document
          .getElementById("save-creator-btn")
          .addEventListener("click", () => {
            // Get values from form
            const creatorCode = document
              .getElementById("creator-code-input")
              .value.trim();
            const rank = document.getElementById("creator-rank-input").value;
            const totalPatterns =
              parseInt(document.getElementById("creator-total-input").value) ||
              0;
            const isComplete =
              document.getElementById("creator-complete-input").value ===
              "true";
            const notes = document
              .getElementById("creator-notes-input")
              .value.trim();

            // Validate creator code format if provided
            if (creatorCode && !creatorCode.match(/^MA-\d{4}-\d{4}-\d{4}$/)) {
              showNotification(
                "Creator Code must be in format MA-####-####-####",
                "error"
              );
              return;
            }

            // Update creator object
            creator.creatorCode = creatorCode;
            creator.rank = rank;
            creator.totalPatterns = totalPatterns;
            creator.isComplete = isComplete;
            creator.notes = notes;

            // Save to localStorage
            saveDataToLocalStorage();

            // Update UI
            renderCreators();

            // Update pattern gallery to refresh creator badges
            renderPatternGallery();

            // Close modal
            document.body.removeChild(modal);

            showNotification("Creator information updated successfully");
          });

        // Update completion rate when total patterns changes
        const totalInput = document.getElementById("creator-total-input");
        const completionRate = modal.querySelector(".completion-rate");

        totalInput.addEventListener("input", () => {
          const total = parseInt(totalInput.value) || 0;
          const tempCreator = { ...creator, totalPatterns: total };
          completionRate.textContent = calculateCompletionRate(tempCreator);
          completionRate.style.color = getCompletionColor(
            calculateCompletionPercentage(tempCreator)
          );
        });

        // Automatically mark as complete if backed up equals total
        totalInput.addEventListener("change", () => {
          const total = parseInt(totalInput.value) || 0;
          const completeSelect = document.getElementById(
            "creator-complete-input"
          );

          if (total > 0 && total <= creator.patterns.length) {
            completeSelect.value = "true";
          }
        });
      }

      // Calculate completion rate display string
      function calculateCompletionRate(creator) {
        const backupCount = creator.patterns.length;
        const totalCount = creator.totalPatterns || 0;

        if (totalCount === 0) {
          return "Unknown";
        }

        const percentage = Math.round((backupCount / totalCount) * 100);
        return `${backupCount}/${totalCount} (${percentage}%)`;
      }

      // Calculate completion percentage
      function calculateCompletionPercentage(creator) {
        const backupCount = creator.patterns.length;
        const totalCount = creator.totalPatterns || 0;

        if (totalCount === 0) {
          return 0;
        }

        return (backupCount / totalCount) * 100;
      }

      // Get color based on completion percentage
      function getCompletionColor(percentage) {
        if (percentage >= 100) {
          return "var(--success-color)";
        } else if (percentage >= 75) {
          return "#2ecc71"; // Green
        } else if (percentage >= 50) {
          return "#f39c12"; // Orange
        } else if (percentage >= 25) {
          return "#e67e22"; // Dark Orange
        } else {
          return "#e74c3c"; // Red
        }
      }

      // Get the last updated date for a creator
      function getLastUpdatedDate(creator) {
        // Find the most recently modified pattern from this creator
        const patterns = creator.patterns
          .map((id) => appData.patterns[id])
          .filter((p) => p); // Remove any undefined patterns

        if (patterns.length === 0) {
          return "Never";
        }

        // Sort by lastModified date
        patterns.sort((a, b) => {
          const dateA = a.lastModified ? new Date(a.lastModified) : new Date(0);
          const dateB = b.lastModified ? new Date(b.lastModified) : new Date(0);
          return dateB - dateA; // Most recent first
        });

        // Get the most recent date
        const mostRecent = patterns[0].lastModified || patterns[0].dateAdded;

        if (!mostRecent) {
          return "Unknown";
        }

        // Format the date
        const date = new Date(mostRecent);
        return date.toLocaleDateString();
      }

      // Load app settings from localStorage
      function loadAppSettings() {
        try {
          const storedSettings = localStorage.getItem("acAppSettings");
          if (storedSettings) {
            Object.assign(appSettings, JSON.parse(storedSettings));
          }
        } catch (error) {
          console.error("Error loading app settings:", error);
        }
      }

      // Save app settings to localStorage
      function saveAppSettings() {
        try {
          localStorage.setItem("acAppSettings", JSON.stringify(appSettings));
        } catch (error) {
          console.error("Error saving app settings:", error);
          showNotification("Error saving app settings", "error");
        }
      }

      // Setup app settings UI
      function setupAppSettings() {
        // Create settings button in header
        const header = document.querySelector("header");
        const settingsBtn = document.createElement("button");
        settingsBtn.id = "settings-btn";
        settingsBtn.className = "btn btn-secondary";
        settingsBtn.textContent = "Settings";
        header.querySelector("div:last-child").prepend(settingsBtn);

        // Create settings modal
        const settingsModal = document.createElement("div");
        settingsModal.className = "modal-backdrop";
        settingsModal.id = "settings-modal";
        settingsModal.innerHTML = `
    <div class="modal">
      <button class="modal-close">&times;</button>
      <h2 class="modal-title">App Settings</h2>
      
      <div class="settings-section">
        <h3>Storage Usage</h3>
        <div class="storage-meter-container">
          <div class="storage-meter">
            <div class="storage-meter-fill" id="storage-meter-fill"></div>
          </div>
          <div class="storage-meter-labels">
            <span class="storage-used" id="storage-used">0 KB</span> / <span id="storage-total">5 MB</span>
          </div>
        </div>
        <div class="storage-breakdown">
          <p>Metadata: <span id="metadata-size">0 KB</span></p>
          <p>Thumbnails: <span id="thumbnails-size">0 KB</span></p>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Thumbnail Storage</h3>
        <div class="form-group full-width" style="display: flex;">
          
            <input type="radio" name="thumbnail-storage" id="store-base64" ${
              appSettings.storeThumbnailsAsBase64 ? "checked" : ""
            } style="width: unset; margin-right: 5px;">
          <label>
            Store thumbnails as base64 (works offline, uses more storage)
          </label>
          
            <input type="radio" name="thumbnail-storage" id="store-paths" ${
              !appSettings.storeThumbnailsAsBase64 ? "checked" : ""
            } style="width: unset; margin-right: 5px;">
            <label>
            Load thumbnails dynamically from files (saves storage, requires file access)
          </label>
        </div>
        <div id="storage-switch-warning" class="warning-message" style="display: none;">
          Switching storage methods may take some time if you have many patterns.
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Data Management</h3>
        <p class="help-text">Import or export pattern metadata including tags, sets, and creator information.</p>
        <div class="form-group full-width" style="display: flex; gap: 10px; margin-top: 15px;">
          <button id="import-metadata-btn-settings" class="btn btn-secondary">Import Metadata</button>
          <button id="export-metadata-btn-settings" class="btn btn-secondary">Export Metadata</button>
        </div>
      </div>
      
      <button class="btn" id="save-settings-btn">Save Settings</button>
    </div>
  `;
        document.body.appendChild(settingsModal);

        // Add event listeners
        settingsBtn.addEventListener("click", () => {
          updateStorageUsage();
          settingsModal.style.display = "flex";
        });

        settingsModal
          .querySelector(".modal-close")
          .addEventListener("click", () => {
            settingsModal.style.display = "none";
          });

        document
          .getElementById("store-base64")
          .addEventListener("change", function () {
            document.getElementById("storage-switch-warning").style.display =
              this.checked && !appSettings.storeThumbnailsAsBase64
                ? "block"
                : "none";
          });

        document
          .getElementById("store-paths")
          .addEventListener("change", function () {
            document.getElementById("storage-switch-warning").style.display =
              this.checked && appSettings.storeThumbnailsAsBase64
                ? "block"
                : "none";
          });

        document
          .getElementById("save-settings-btn")
          .addEventListener("click", async () => {
            const newStoreAsBase64 =
              document.getElementById("store-base64").checked;

            // If storage method is changing, we need to convert thumbnails
            if (newStoreAsBase64 !== appSettings.storeThumbnailsAsBase64) {
              showLoader("Converting thumbnails...");
              try {
                if (newStoreAsBase64) {
                  await convertToBase64Thumbnails();
                } else {
                  await convertToFilePaths();
                }
                appSettings.storeThumbnailsAsBase64 = newStoreAsBase64;
                saveAppSettings();
                saveDataToLocalStorage();
                showNotification("Settings saved and thumbnails converted");
              } catch (error) {
                console.error("Error converting thumbnails:", error);
                showNotification("Error converting thumbnails", "error");
              } finally {
                hideLoader();
              }
            } else {
              // Just save settings if nothing is changing
              appSettings.storeThumbnailsAsBase64 = newStoreAsBase64;
              saveAppSettings();
              showNotification("Settings saved");
            }

            settingsModal.style.display = "none";
            renderPatternGallery();
          });

        // Add event listeners for the import and export metadata buttons
        document
          .getElementById("import-metadata-btn-settings")
          .addEventListener("click", () => {
            // Close settings modal first
            settingsModal.style.display = "none";

            // Then show import metadata modal
            document.getElementById("metadata-file").value = "";
            document.getElementById("metadata-import-status").innerHTML = "";
            document.getElementById("import-metadata-modal").style.display =
              "flex";
          });

        document
          .getElementById("export-metadata-btn-settings")
          .addEventListener("click", () => {
            // Close settings modal first
            settingsModal.style.display = "none";

            // Then export metadata
            exportMetadata();
          });
      }

      // Update storage usage display
      function updateStorageUsage() {
        try {
          // Calculate sizes
          const patternsJson = JSON.stringify(appData.patterns);
          const creatorsJson = JSON.stringify(appData.creators);
          const setsJson = JSON.stringify(appData.sets);
          const processedFilesJson = JSON.stringify([
            ...appData.processedFiles,
          ]);

          // Calculate size of metadata (without thumbnails)
          const patternsWithoutThumbnails = JSON.parse(patternsJson);
          for (const id in patternsWithoutThumbnails) {
            if (appSettings.storeThumbnailsAsBase64) {
              patternsWithoutThumbnails[id].thumbnailPath = null;
            }
          }

          const metadataSize =
            JSON.stringify(patternsWithoutThumbnails).length +
            creatorsJson.length +
            setsJson.length +
            processedFilesJson.length;

          // Calculate thumbnails size
          const thumbnailsSize = appSettings.storeThumbnailsAsBase64
            ? patternsJson.length -
              JSON.stringify(patternsWithoutThumbnails).length
            : 0;

          // Total used size
          const totalUsed = metadataSize + thumbnailsSize;

          // Rough estimate of localStorage capacity (5MB is common)
          const totalCapacity = 5 * 1024 * 1024;

          // Update UI
          document.getElementById("metadata-size").textContent =
            formatBytes(metadataSize);
          document.getElementById("thumbnails-size").textContent =
            formatBytes(thumbnailsSize);
          document.getElementById("storage-used").textContent =
            formatBytes(totalUsed);
          document.getElementById(
            "storage-meter-fill"
          ).style.width = `${Math.min(
            100,
            (totalUsed / totalCapacity) * 100
          )}%`;

          // Change color based on usage
          const fill = document.getElementById("storage-meter-fill");
          if (totalUsed / totalCapacity > 0.9) {
            fill.style.backgroundColor = "var(--error-color)";
          } else if (totalUsed / totalCapacity > 0.7) {
            fill.style.backgroundColor = "#f39c12"; // Orange warning color
          } else {
            fill.style.backgroundColor = "var(--primary-color)";
          }
        } catch (error) {
          console.error("Error calculating storage usage:", error);
        }
      }

      // Format bytes to human-readable format
      function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return "0 Bytes";

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB"];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return (
          parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i]
        );
      }

      // Create loading overlay
      function showLoader(message = "Loading...") {
        let loader = document.getElementById("app-loader");
        if (!loader) {
          loader = document.createElement("div");
          loader.id = "app-loader";
          loader.className = "loader-overlay";
          loader.innerHTML = `
      <div class="loader-content">
        <div class="loading"></div>
        <div class="loader-message">${message}</div>
      </div>
    `;
          document.body.appendChild(loader);
        } else {
          loader.querySelector(".loader-message").textContent = message;
          loader.style.display = "flex";
        }
      }

      function hideLoader() {
        const loader = document.getElementById("app-loader");
        if (loader) {
          loader.style.display = "none";
        }
      }

      // Create a small resized thumbnail from an image file
      function createResizedThumbnail(file) {
        return new Promise((resolve, reject) => {
          if (!file) {
            reject(new Error("No file provided"));
            return;
          }

          const reader = new FileReader();
          reader.onload = function (e) {
            const img = new Image();
            img.onload = function () {
              // Create a small thumbnail
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Set to 32x32 for Animal Crossing patterns
              canvas.width = 32;
              canvas.height = 32;

              // Use pixelated rendering
              ctx.imageSmoothingEnabled = false;

              // Draw the image
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

              // Get as data URL (base64)
              const thumbnailDataUrl = canvas.toDataURL("image/png");
              resolve(thumbnailDataUrl);
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // Convert all thumbnails to base64 (when switching from file paths)
      async function convertToBase64Thumbnails() {
        const patterns = Object.values(appData.patterns);
        const totalPatterns = patterns.length;
        let processedPatterns = 0;

        for (const pattern of patterns) {
          // Skip if already has base64 data
          if (
            pattern.encodedThumbnail &&
            pattern.encodedThumbnail.startsWith("data:")
          ) {
            processedPatterns++;
            continue;
          }

          // Try to load from original file path
          if (pattern.thumbnailPath) {
            try {
              // This approach with fetch might not work with file:/// URLs due to security restrictions
              // Try to use relative paths that might work
              const response = await fetch(pattern.thumbnailPath);
              const blob = await response.blob();

              // Create thumbnail from loaded file
              pattern.encodedThumbnail = await createResizedThumbnail(blob);
            } catch (error) {
              console.error(
                `Could not load image from path: ${pattern.thumbnailPath}`,
                error
              );
              pattern.encodedThumbnail = null; // Reset if we couldn't load
            }
          }

          processedPatterns++;
          if (processedPatterns % 10 === 0) {
            showLoader(
              `Converting thumbnails: ${processedPatterns}/${totalPatterns}`
            );
          }
        }
      }

      // Convert all thumbnails to file paths (when switching from base64)
      async function convertToFilePaths() {
        const patterns = Object.values(appData.patterns);

        for (const pattern of patterns) {
          // If we have base64 data, store the reference to original file and clear base64 data
          if (
            pattern.encodedThumbnail &&
            pattern.encodedThumbnail.startsWith("data:")
          ) {
            // Keep the thumbnailPath but clear the base64 encodedThumbnail
            // We'll use thumbnailPath when loading
            if (!pattern.thumbnailPath) {
              // If somehow we don't have the original path, keep base64
              pattern.thumbnailPath = pattern.encodedThumbnail;
            } else {
              pattern.encodedThumbnail = null;
            }
          }
        }
      }

      // Import patterns
      async function importPatterns() {
        const fileInput = document.getElementById("pattern-folder");
        const files = fileInput.files;

        if (files.length === 0) {
          showNotification(
            "Please select a folder with pattern files",
            "error"
          );
          return;
        }

        const importStatus = document.getElementById("import-status");
        importStatus.innerHTML =
          '<div class="loading"></div> Scanning files...';

        try {
          // Filter files to just .nhd and .png
          const nhdFiles = Array.from(files).filter((file) =>
            file.name.endsWith(".nhd")
          );
          const pngFiles = Array.from(files).filter((file) =>
            file.name.endsWith(".png")
          );

          // Track duplicates
          const duplicatePatterns = [];
          const skippedExistingFiles = [];

          // Map to group pattern files by their pattern and creator name
          const patternGroups = new Map();

          importStatus.innerHTML =
            '<div class="loading"></div> Checking for duplicates...';

          // First, check for duplicates and group patterns
          let processedCount = 0;
          for (const nhdFile of nhdFiles) {
            // Update status every 10 files
            if (++processedCount % 10 === 0) {
              importStatus.innerHTML = `<div class="loading"></div> Checking for duplicates: ${processedCount}/${nhdFiles.length}`;
            }

            // Skip already processed files
            if (appData.processedFiles.has(nhdFile.name)) {
              skippedExistingFiles.push(nhdFile.name);
              continue;
            }

            // Extract metadata
            const metadata = await extractMetadataFromFile(nhdFile);

            // Check if this pattern is an exact duplicate and get its hash
            const duplicateResult = await isExactDuplicate(metadata, nhdFile);

            if (duplicateResult.isDuplicate) {
              duplicatePatterns.push({
                fileName: nhdFile.name,
                patternName: metadata.patternName,
                creatorName: metadata.creatorName,
                townName: metadata.townName,
                existingPatternId: duplicateResult.existingPatternId,
              });
              continue; // Skip this file
            }

            const key = `${metadata.patternName}-${metadata.creatorName}`;

            if (!patternGroups.has(key)) {
              patternGroups.set(key, []);
            }

            // Store the fileHash from duplicateResult
            patternGroups.get(key).push({
              file: nhdFile,
              metadata: metadata,
              fileHash: duplicateResult.fileHash, // Store hash from duplicate check
            });
          }

          // Process each group to assign thumbnails in order
          const importPromises = [];

          importStatus.innerHTML = `<div class="loading"></div> Processing ${patternGroups.size} pattern groups...`;

          for (const [key, patterns] of patternGroups.entries()) {
            // Sort patterns (optional, depending on your preference)
            // This sorts by the numeric prefix if present in the filename
            patterns.sort((a, b) => {
              const numA = parseInt(a.file.name.match(/^(\d+)/)?.[1] || "0");
              const numB = parseInt(b.file.name.match(/^(\d+)/)?.[1] || "0");
              return numA - numB;
            });

            // Used thumbnails tracking
            const usedThumbnails = new Set();

            // For each pattern in the group, find the corresponding thumbnail
            for (let i = 0; i < patterns.length; i++) {
              const pattern = patterns[i];
              const metadata = pattern.metadata;
              const fileHash = pattern.fileHash; // Get the fileHash we stored from duplicateResult

              // Generate the base thumbnail name
              const sanitizedBaseName = sanitizeFilename(
                `${metadata.patternName} - ${metadata.creatorName}`
              );
              const normalizedBaseName =
                normalizeForComparison(sanitizedBaseName);

              // Find matching thumbnails in order
              let targetThumbnail = null;

              // First try the exact match for the first pattern
              if (i === 0) {
                const exactMatch = pngFiles.find((file) => {
                  if (usedThumbnails.has(file.name)) return false;

                  const normalizedFileName = normalizeForComparison(file.name);
                  const baseNameWithoutExt = normalizedBaseName;

                  return (
                    normalizedFileName === `${baseNameWithoutExt}.png` ||
                    normalizedFileName === `${baseNameWithoutExt}_x8.png`
                  );
                });

                if (exactMatch) {
                  targetThumbnail = exactMatch;
                  usedThumbnails.add(exactMatch.name);
                }
              }

              // If no exact match or not the first pattern, try numbered versions
              if (!targetThumbnail) {
                const suffix = i > 0 ? `_${i + 1}` : "";

                // Try x8 version first (higher quality)
                const x8Match = pngFiles.find((file) => {
                  if (usedThumbnails.has(file.name)) return false;

                  const normalizedFileName = normalizeForComparison(file.name);
                  const expectedName = `${normalizedBaseName}${suffix}_x8.png`;

                  return normalizedFileName === expectedName;
                });

                if (x8Match) {
                  targetThumbnail = x8Match;
                  usedThumbnails.add(x8Match.name);
                } else {
                  // Try regular version
                  const regularMatch = pngFiles.find((file) => {
                    if (usedThumbnails.has(file.name)) return false;

                    const normalizedFileName = normalizeForComparison(
                      file.name
                    );
                    const expectedName = `${normalizedBaseName}${suffix}.png`;

                    return normalizedFileName === expectedName;
                  });

                  if (regularMatch) {
                    targetThumbnail = regularMatch;
                    usedThumbnails.add(regularMatch.name);
                  }
                }
              }

              // If still no match, try to find any unused thumbnail with the base name
              if (!targetThumbnail) {
                for (const pngFile of pngFiles) {
                  if (usedThumbnails.has(pngFile.name)) continue;

                  const normalizedFileName = normalizeForComparison(
                    pngFile.name
                  );

                  if (
                    normalizedFileName.startsWith(normalizedBaseName) &&
                    (normalizedFileName.endsWith(".png") ||
                      normalizedFileName.endsWith("_x8.png"))
                  ) {
                    targetThumbnail = pngFile;
                    usedThumbnails.add(pngFile.name);
                    break;
                  }
                }
              }

              // Import the pattern with the found thumbnail
              importPromises.push(
                importPattern(
                  pattern.file,
                  targetThumbnail,
                  pattern.metadata,
                  fileHash // Pass the fileHash we got from duplicateResult
                )
              );
            }
          }

          importStatus.innerHTML = `<div class="loading"></div> Importing ${importPromises.length} patterns...`;

          // Process all imports
          const results = await Promise.allSettled(importPromises);

          // Count successes and failures
          const successes = results.filter(
            (r) => r.status === "fulfilled"
          ).length;
          const failures = results.filter(
            (r) => r.status === "rejected"
          ).length;

          // Create status message with duplicate information
          let statusMessage = `<div class="success-message">Imported ${successes} patterns successfully.`;
          if (failures > 0)
            statusMessage += ` Failed to import ${failures} patterns.`;
          statusMessage += `</div>`;

          // Add information about duplicates
          if (duplicatePatterns.length > 0) {
            statusMessage += `<div class="info-message">Skipped ${duplicatePatterns.length} exact duplicate patterns.</div>`;

            // Create a detailed list of skipped duplicates if there aren't too many
            if (duplicatePatterns.length <= 10) {
              statusMessage += "<ul class='duplicate-list'>";
              duplicatePatterns.forEach((dupe) => {
                statusMessage += `<li>${dupe.patternName} by ${dupe.creatorName} of ${dupe.townName} (${dupe.fileName})</li>`;
              });
              statusMessage += "</ul>";
            }
          }

          // Add information about already processed files
          if (skippedExistingFiles.length > 0) {
            statusMessage += `<div class="info-message">Skipped ${skippedExistingFiles.length} previously processed files.</div>`;
          }

          importStatus.innerHTML = statusMessage;

          // Save data
          saveDataToLocalStorage();

          // Refresh views
          renderPatternGallery();
          renderSidebarFilters();

          showNotification(
            `Imported ${successes} patterns, skipped ${duplicatePatterns.length} duplicates`
          );
        } catch (error) {
          console.error("Error importing patterns:", error);
          importStatus.innerHTML = `<div class="error-message">Error importing patterns: ${error.message}</div>`;
          showNotification("Error importing patterns", "error");
        }
      }

      // Helper function to sanitize filenames exactly like the C# code
      function sanitizeFilename(filename) {
        // First normalize whitespace (collapse multiple spaces to single space)
        filename = filename.replace(/\s+/g, " ");

        // Then perform the Windows character sanitization
        return filename
          .replace(/\?/g, "_")
          .replace(/\//g, "_")
          .replace(/\\/g, "_")
          .replace(/\*/g, "_")
          .replace(/:/g, "_")
          .replace(/</g, "_")
          .replace(/>/g, "_")
          .replace(/\|/g, "_")
          .replace(/"/g, "_");
      }

      // When matching thumbnails, implement a more flexible string comparison
      function normalizeForComparison(str) {
        // Remove all whitespace for comparison purposes
        return str.replace(/\s+/g, "");
      }

      // Helper function to escape special characters in regular expressions
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      // Extract metadata from a file
      async function extractMetadataFromFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = function () {
            try {
              const metadata = extractMetadataFromNHD(reader.result);
              resolve(metadata);
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function (event) {
            reject(new Error("Error reading file: " + event.target.error));
          };

          reader.readAsArrayBuffer(file);
        });
      }

      // Generate a hash of an image using SHA-256
      async function generateThumbnailHash(imageSrc) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          // Set canvas to a standard size (32x32) for consistent hashing
          canvas.width = 32;
          canvas.height = 32;

          img.onload = async function () {
            try {
              // Draw image on canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

              // Get pixel data
              const imageData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Convert pixel data to an ArrayBuffer for hashing
              const buffer = new Uint8Array(imageData).buffer;

              try {
                // Use SubtleCrypto API for SHA-256 hash
                const hashBuffer = await crypto.subtle.digest(
                  "SHA-256",
                  buffer
                );

                // Convert hash to hex string
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");

                resolve(hashHex);
              } catch (cryptoError) {
                console.warn(
                  `SubtleCrypto failed: ${cryptoError}. Using fallback method.`
                );

                // Fallback method if crypto API is not available
                let hash = 0;
                for (let i = 0; i < imageData.length; i++) {
                  hash = (hash << 5) - hash + imageData[i];
                  hash |= 0; // Convert to 32bit integer
                }
                const hashHex = hash.toString(16);
                resolve(hashHex);
              }
            } catch (error) {
              reject(error);
            }
          };

          img.onerror = function () {
            reject(new Error("Error loading image for hashing"));
          };

          // Handle both base64 and file path sources
          if (typeof imageSrc === "string") {
            // If it's a string (either base64 or file path)
            img.src = imageSrc;
          } else if (imageSrc instanceof Blob) {
            // If it's a blob or file object
            img.src = URL.createObjectURL(imageSrc);
          } else {
            reject(new Error("Unsupported image source type"));
          }
        });
      }

      function generateUniquePatternId() {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 1000000); // Use a larger range
        const uniqueId = `pattern-${timestamp}-${random}`;

        // Check if this ID already exists and regenerate if needed
        if (appData.patterns[uniqueId]) {
          return generateUniquePatternId(); // Recursive call to try again
        }

        return uniqueId;
      }

      // Check if a pattern is an exact duplicate of an existing pattern
      async function isExactDuplicate(metadata, nhdFile) {
        console.log(
          `=== CHECKING FOR DUPLICATE: ${metadata.patternName} by ${metadata.creatorName} ===`
        );

        // First check: Find patterns with the same name, creator and town
        const candidatePatterns = Object.values(appData.patterns).filter(
          (pattern) =>
            pattern.patternName === metadata.patternName &&
            pattern.creatorName === metadata.creatorName &&
            pattern.townName === metadata.townName
        );

        console.log(
          `Found ${candidatePatterns.length} potential matches with same metadata`
        );

        // Always calculate the hash, no matter what
        console.log(`Calculating hash for new file: ${nhdFile.name}`);
        const newFileHash = await calculateFileHash(nhdFile);
        console.log(`New file hash calculated: ${newFileHash}`);

        // If no candidates with same metadata, it's not a duplicate
        if (candidatePatterns.length === 0) {
          console.log(
            `No metadata matches, not a duplicate. Returning hash: ${newFileHash}`
          );
          return { isDuplicate: false, fileHash: newFileHash };
        }

        // Log details of potential matches
        candidatePatterns.forEach((pattern, index) => {
          console.log(`Match candidate #${index + 1}:`);
          console.log(`  ID: ${pattern.id}`);
          console.log(`  Filename: ${pattern.fileName}`);
          console.log(`  Stored hash: ${pattern.fileHash || "None"}`);
        });

        // Check for hash matches
        for (const pattern of candidatePatterns) {
          if (pattern.fileHash === newFileHash) {
            console.log(
              `DUPLICATE FOUND: ${nhdFile.name} matches existing pattern ${pattern.id}`
            );
            return {
              isDuplicate: true,
              existingPatternId: pattern.id,
              fileHash: newFileHash,
            };
          }
        }

        console.log(
          `No matching hash found, this is a new pattern. Returning hash: ${newFileHash}`
        );
        return { isDuplicate: false, fileHash: newFileHash };
      }

      // Calculate a hash of the file content for comparison
      async function calculateFileHash(file) {
        console.log(`Starting hash calculation for ${file.name}`);

        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = async function (e) {
            try {
              console.log(
                `File ${file.name} loaded, size: ${e.target.result.byteLength} bytes`
              );

              // Use SubtleCrypto API to create SHA-256 hash of file content
              try {
                console.log(`Using SubtleCrypto for hash calculation`);
                const hashBuffer = await crypto.subtle.digest(
                  "SHA-256",
                  e.target.result
                );

                // Convert hash to hex string
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");

                console.log(
                  `Hash calculated successfully: ${hashHex.substring(0, 20)}...`
                );
                resolve(hashHex);
              } catch (cryptoError) {
                console.warn(
                  `SubtleCrypto failed: ${cryptoError}. Using fallback method.`
                );

                // Fallback method if crypto API is not available
                let hash = 0;
                const data = new Uint8Array(e.target.result);
                for (let i = 0; i < data.length; i++) {
                  hash = (hash << 5) - hash + data[i];
                  hash |= 0; // Convert to 32bit integer
                }
                const hashHex = hash.toString(16);
                console.log(`Fallback hash calculated: ${hashHex}`);
                resolve(hashHex);
              }
            } catch (error) {
              console.error(`Error calculating hash: ${error}`);
              reject(error);
            }
          };

          reader.onerror = function (error) {
            console.error(`Error reading file for hash calculation: ${error}`);
            reject(error);
          };

          try {
            reader.readAsArrayBuffer(file);
          } catch (error) {
            console.error(`Error initiating file read: ${error}`);
            reject(error);
          }
        });
      }

      // Import a single pattern
      async function importPattern(nhdFile, pngFile, metadata, fileHash) {
        return new Promise(async (resolve, reject) => {
          try {
            console.log(
              `Importing pattern: ${nhdFile.name}, size: ${nhdFile.size} bytes`
            );
            console.log(`PNG file available: ${pngFile !== null}`);
            console.log(`FileHash available: ${fileHash ? "YES" : "NO"}`);

            // Generate pattern ID
            const patternId = generateUniquePatternId();

            // Create pattern entry
            const pattern = {
              id: patternId,
              fileName: nhdFile.name,
              // Store the full path to the NHD file
              filePath: nhdFile.webkitRelativePath || nhdFile.path || null,
              encodedThumbnail: null,
              thumbnailPath: null,

              // Metadata from .nhd file
              patternName: metadata.patternName || "Unnamed Pattern",
              creatorName: metadata.creatorName || "Unknown Creator",
              townName: metadata.townName || "Unknown Town",
              townId: metadata.townId || "",

              // User-defined metadata
              tags: [],
              setName: "",
              setId: "",
              setOrder: 0,
              relatedPatterns: [],
              notes: "",

              // System metadata
              dateAdded: new Date().toISOString().split("T")[0],
              lastModified: new Date().toISOString().split("T")[0],

              // Hash for duplicate detection and file content comparison
              thumbnailHash: null,
              fileHash: fileHash, // Store the file hash we received from the duplicate check
            };

            console.log(`Pattern created with fileHash: ${pattern.fileHash}`);
            console.log(`Pattern file path: ${pattern.filePath}`);

            // Handle thumbnail based on storage preference
            if (pngFile) {
              // Store the original file path for reference
              // When using relative URLs, this becomes the primary thumbnail source
              pattern.thumbnailPath =
                pngFile.webkitRelativePath || pngFile.path || pngFile.name;

              // If storing as base64, create resized thumbnail
              if (appSettings.storeThumbnailsAsBase64) {
                try {
                  pattern.encodedThumbnail = await createResizedThumbnail(
                    pngFile
                  );
                } catch (error) {
                  console.error("Error creating thumbnail:", error);
                  pattern.encodedThumbnail = null;
                }
              }

              // Generate hash for the thumbnail if possible
              try {
                if (
                  appSettings.storeThumbnailsAsBase64 &&
                  pattern.encodedThumbnail
                ) {
                  // Use base64 data for hashing
                  pattern.thumbnailHash = await generateThumbnailHash(
                    pattern.encodedThumbnail
                  );
                } else if (pngFile) {
                  // Use the file directly for hashing when not using base64
                  const blobUrl = URL.createObjectURL(pngFile);
                  pattern.thumbnailHash = await generateThumbnailHash(blobUrl);
                  URL.revokeObjectURL(blobUrl);
                }
              } catch (hashError) {
                console.error("Error generating hash:", hashError);
                // Continue even if hash generation fails
              }
            }

            console.log("Created pattern object:", {
              id: pattern.id,
              name: pattern.patternName,
              creator: pattern.creatorName,
              town: pattern.townName,
              filePath: pattern.filePath,
              hash: pattern.thumbnailHash
                ? pattern.thumbnailHash.substring(0, 20) + "..."
                : "None",
              fileHash: pattern.fileHash
                ? pattern.fileHash.substring(0, 20) + "..."
                : "None",
            });

            // Add pattern to data store
            appData.patterns[patternId] = pattern;

            // Create or update creator info
            const creatorId = generateCreatorId(
              pattern.creatorName,
              pattern.townName
            );
            console.log("Creator ID:", creatorId);

            if (!appData.creators[creatorId]) {
              appData.creators[creatorId] = {
                id: creatorId,
                name: pattern.creatorName,
                townName: pattern.townName,
                creatorCode: null,
                rank: "unknown",
                patterns: [],
                totalBackedUp: 0,
                totalPatterns: 0,
                isComplete: false,
                notes: "",
              };
              console.log("Created new creator:", pattern.creatorName);
            } else {
              console.log("Adding to existing creator:", pattern.creatorName);
            }

            // Add pattern to creator
            appData.creators[creatorId].patterns.push(patternId);
            appData.creators[creatorId].totalBackedUp =
              appData.creators[creatorId].patterns.length;

            // Mark file as processed
            appData.processedFiles.add(nhdFile.name);
            console.log(`Pattern import successful: ${pattern.patternName}`);

            resolve(pattern);
          } catch (error) {
            console.error("Error processing pattern:", error);
            reject(error);
          }
        });
      }

      // Extract metadata from .nhd file
      function extractMetadataFromNHD(arrayBuffer) {
        console.log(
          "Extracting metadata from NHD file, size:",
          arrayBuffer.byteLength
        );

        // Create a DataView for easier binary data access
        const view = new DataView(arrayBuffer);

        try {
          // Extract pattern name (40 bytes at offset 0x10)
          let patternName = extractUTF16String(arrayBuffer, 0x10, 40);
          console.log("Extracted pattern name:", patternName);

          // Town ID (4 bytes at offset 0x38)
          const townId = view.getUint32(0x38, true).toString();
          console.log("Extracted town ID:", townId);

          // Extract town name (20 bytes at offset 0x3C)
          let townName = extractUTF16String(arrayBuffer, 0x3c, 20);
          console.log("Extracted town name:", townName);

          // Extract creator name (20 bytes at offset 0x58)
          let creatorName = extractUTF16String(arrayBuffer, 0x58, 20);
          console.log("Extracted creator name:", creatorName);

          return {
            patternName: patternName || "Unnamed Pattern",
            creatorName: creatorName || "Unknown Creator",
            townName: townName || "Unknown Town",
            townId: townId || "",
          };
        } catch (error) {
          console.error("Error extracting metadata:", error);
          return {
            patternName: "Unnamed Pattern",
            creatorName: "Unknown Creator",
            townName: "Unknown Town",
            townId: "",
          };
        }
      }

      // Helper function to extract UTF-16 strings from binary data
      function extractUTF16String(arrayBuffer, offset, maxByteLength) {
        // Create a DataView for reading UTF-16 values
        const dataView = new DataView(arrayBuffer);
        let result = "";

        // UTF-16 uses 2 bytes per character, so read characters until we hit null or maxByteLength
        for (let i = 0; i < maxByteLength; i += 2) {
          if (offset + i + 1 >= arrayBuffer.byteLength) break;

          const charCode = dataView.getUint16(offset + i, true); // true for little-endian

          // Stop at the null terminator
          if (charCode === 0) break;

          result += String.fromCharCode(charCode);
        }

        return result.trim();
      }

      // Add import metadata functionality
      function setupMetadataImport() {
        // Create import metadata modal
        const importMetadataModal = document.createElement("div");
        importMetadataModal.className = "modal-backdrop";
        importMetadataModal.id = "import-metadata-modal";

        importMetadataModal.innerHTML = `
    <div class="modal">
        <button class="modal-close">&times;</button>
        <h2 class="modal-title">Import Pattern Metadata</h2>
        <div class="form-group">
            <label for="metadata-file">Select Metadata JSON File</label>
            <input type="file" id="metadata-file" accept=".json">
        </div>
        <div id="metadata-import-status"></div>
        <div class="import-options">
            <div class="form-group">
                <label>
                    <input type="checkbox" id="merge-metadata" checked>
                    Merge with existing data (recommended)
                </label>
                <p class="help-text">If unchecked, all existing metadata will be replaced with the imported data.</p>
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="update-existing" checked>
                    Update existing patterns
                </label>
                <p class="help-text">If unchecked, only new patterns will be added.</p>
            </div>
        </div>
        <button class="btn" id="start-metadata-import-btn">Import Metadata</button>
    </div>
  `;

        document.body.appendChild(importMetadataModal);

        // Close button event listener
        importMetadataModal
          .querySelector(".modal-close")
          .addEventListener("click", () => {
            importMetadataModal.style.display = "none";
          });

        // Start import button event listener
        document
          .getElementById("start-metadata-import-btn")
          .addEventListener("click", importMetadata);
      }

      // Import metadata from JSON file
      function importMetadata() {
        const fileInput = document.getElementById("metadata-file");
        const mergeMetadata = document.getElementById("merge-metadata").checked;
        const updateExisting =
          document.getElementById("update-existing").checked;
        const statusElement = document.getElementById("metadata-import-status");

        if (!fileInput.files || fileInput.files.length === 0) {
          statusElement.innerHTML =
            '<div class="error-message">Please select a metadata file to import.</div>';
          return;
        }

        const file = fileInput.files[0];

        // Check file type
        if (!file.name.endsWith(".json")) {
          statusElement.innerHTML =
            '<div class="error-message">Please select a valid JSON metadata file.</div>';
          return;
        }

        statusElement.innerHTML =
          '<div class="loading"></div> Reading metadata file...';

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const importData = JSON.parse(e.target.result);

            // Validate the imported data structure
            if (
              !importData.patterns ||
              !importData.creators ||
              !importData.sets
            ) {
              throw new Error(
                "Invalid metadata format. File should contain patterns, creators, and sets."
              );
            }

            // Import app settings if present
            if (importData.appSettings) {
              Object.assign(appSettings, importData.appSettings);
              saveAppSettings();
            }

            // Process patterns to handle different thumbnail storage formats
            for (const id in importData.patterns) {
              const pattern = importData.patterns[id];

              if (pattern.encodedThumbnail) {
                // If path is base64 but we're not storing base64, clear it and keep thumbnailPath
                if (
                  pattern.encodedThumbnail.startsWith("data:") &&
                  !appSettings.storeThumbnailsAsBase64
                ) {
                  pattern.thumbnailPath = pattern.thumbnailPath;
                  pattern.encodedThumbnail = null;
                }
              }
            }

            // Backup current data
            const backupData = {
              patterns: { ...appData.patterns },
              creators: { ...appData.creators },
              sets: { ...appData.sets },
              processedFiles: new Set([...appData.processedFiles]),
            };

            try {
              if (mergeMetadata) {
                // Merge with existing data
                mergeImportedData(importData, updateExisting);
                statusElement.innerHTML =
                  '<div class="success-message">Metadata successfully merged.</div>';
              } else {
                // Replace existing data
                if (
                  confirm(
                    "This will replace all existing metadata. Are you sure you want to continue?"
                  )
                ) {
                  replaceWithImportedData(importData);
                  statusElement.innerHTML =
                    '<div class="success-message">Metadata successfully imported.</div>';
                } else {
                  statusElement.innerHTML = "";
                  return;
                }
              }

              // Save changes
              saveDataToLocalStorage();

              // Refresh views
              renderPatternGallery();
              renderSidebarFilters();

              // Show success message with stats
              const patternCount = Object.keys(importData.patterns).length;
              const creatorCount = Object.keys(importData.creators).length;
              const setCount = Object.keys(importData.sets).length;

              showNotification(
                `Imported ${patternCount} patterns, ${creatorCount} creators, and ${setCount} sets`
              );

              // Close modal after successful import
              setTimeout(() => {
                document.getElementById("import-metadata-modal").style.display =
                  "none";
              }, 2000);
            } catch (processError) {
              console.error("Error processing imported data:", processError);

              // Restore from backup
              appData.patterns = backupData.patterns;
              appData.creators = backupData.creators;
              appData.sets = backupData.sets;
              appData.processedFiles = backupData.processedFiles;

              statusElement.innerHTML = `<div class="error-message">Error processing imported data: ${processError.message}</div>`;
            }
          } catch (parseError) {
            console.error("Error parsing JSON:", parseError);
            statusElement.innerHTML = `<div class="error-message">Error parsing metadata file: ${parseError.message}</div>`;
          }
        };

        reader.onerror = function () {
          statusElement.innerHTML =
            '<div class="error-message">Error reading the file.</div>';
        };

        reader.readAsText(file);
      }

      // Merge imported data with existing data
      function mergeImportedData(importData, updateExisting) {
        // Process patterns
        for (const [id, pattern] of Object.entries(importData.patterns)) {
          if (appData.patterns[id]) {
            // Pattern already exists
            if (updateExisting) {
              // Keep file references from existing pattern
              const existingPattern = appData.patterns[id];
              pattern.fileName = existingPattern.fileName;
              pattern.encodedThumbnail = existingpattern.encodedThumbnail;
              pattern.thumbnailHash = existingPattern.thumbnailHash;

              // Update existing pattern
              appData.patterns[id] = pattern;
            }
            // If not updateExisting, keep the existing pattern unchanged
          } else {
            // New pattern
            appData.patterns[id] = pattern;
          }
        }

        // Process creators
        for (const [id, creator] of Object.entries(importData.creators)) {
          if (appData.creators[id]) {
            // Merge pattern arrays without duplicates
            const existingCreator = appData.creators[id];
            creator.patterns = [
              ...new Set([...existingCreator.patterns, ...creator.patterns]),
            ];

            // Update creator info if updateExisting is true
            if (updateExisting) {
              creator.totalBackedUp = creator.patterns.length;
              appData.creators[id] = creator;
            } else {
              // Just update the patterns list
              existingCreator.patterns = creator.patterns;
              existingCreator.totalBackedUp = creator.patterns.length;
            }
          } else {
            // New creator, just add it
            appData.creators[id] = creator;
          }
        }

        // Process sets
        for (const [id, set] of Object.entries(importData.sets)) {
          if (appData.sets[id]) {
            // Merge pattern arrays without duplicates
            const existingSet = appData.sets[id];
            set.patterns = [
              ...new Set([...existingSet.patterns, ...set.patterns]),
            ];

            // Update set if updateExisting is true
            if (updateExisting) {
              appData.sets[id] = set;
            } else {
              // Just update the patterns list
              existingSet.patterns = set.patterns;
            }
          } else {
            // New set, just add it
            appData.sets[id] = set;
          }
        }

        // Process processed files list
        if (
          importData.processedFiles &&
          Array.isArray(importData.processedFiles)
        ) {
          importData.processedFiles.forEach((file) => {
            appData.processedFiles.add(file);
          });
        }

        // Update all patterns to make sure sets and creators are consistent
        updateRelationships();
      }

      // Replace existing data with imported data
      function replaceWithImportedData(importData) {
        // Replace patterns, but keep thumbnail references where possible
        const newPatterns = {};
        for (const [id, pattern] of Object.entries(importData.patterns)) {
          newPatterns[id] = pattern;

          // If pattern existed before, keep its thumbnail reference
          if (appData.patterns[id]) {
            newPatterns[id].thumbnailPath = appData.patterns[id].thumbnailPath;
            newPatterns[id].thumbnailHash = appData.patterns[id].thumbnailHash;
          } else {
            // Clear invalid thumbnail paths for new patterns
            newPatterns[id].thumbnailPath = null;
            newPatterns[id].thumbnailHash = null;
          }
        }

        // Replace everything with imported data
        appData.patterns = newPatterns;
        appData.creators = importData.creators;
        appData.sets = importData.sets;

        // Process processed files list
        if (
          importData.processedFiles &&
          Array.isArray(importData.processedFiles)
        ) {
          appData.processedFiles = new Set(importData.processedFiles);
        }

        // Update all patterns to make sure sets and creators are consistent
        updateRelationships();
      }

      // Update relationships between patterns, creators, and sets
      function updateRelationships() {
        // Ensure all patterns in sets have correct set references
        for (const [setId, set] of Object.entries(appData.sets)) {
          set.patterns.forEach((patternId, index) => {
            const pattern = appData.patterns[patternId];
            if (pattern) {
              pattern.setId = setId;
              pattern.setName = set.name;
              pattern.setOrder = index + 1;
            }
          });
        }

        // Ensure all patterns listed in creators exist
        for (const [creatorId, creator] of Object.entries(appData.creators)) {
          // Filter out non-existent patterns
          creator.patterns = creator.patterns.filter(
            (patternId) => appData.patterns[patternId]
          );
          creator.totalBackedUp = creator.patterns.length;
        }
      }

      // Export metadata
      function exportMetadata() {
        const exportData = {
          patterns: {},
          creators: appData.creators,
          sets: appData.sets,
          processedFiles: [...appData.processedFiles],
          appSettings: appSettings,
        };

        for (const id in appData.patterns) {
          exportData.patterns[id] = { ...appData.patterns[id] };
        }

        // Create download link
        const dataStr = JSON.stringify(exportData);
        const dataUri =
          "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);

        const exportFileName =
          "ac-pattern-metadata-" +
          new Date().toISOString().split("T")[0] +
          ".json";

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", dataUri);
        linkElement.setAttribute("download", exportFileName);
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);

        showNotification("Metadata exported successfully");
      }

      // Scan for duplicates
      async function scanForDuplicates() {
        const duplicatesContainer = elements.duplicatesContainer;
        duplicatesContainer.innerHTML =
          '<div class="loading"></div> Scanning for duplicates...';

        try {
          // Get all patterns with thumbnails or hashes
          const patterns = Object.values(appData.patterns).filter(
            (p) =>
              p.thumbnailHash ||
              (appSettings.storeThumbnailsAsBase64
                ? p.encodedThumbnail
                : p.thumbnailPath)
          );

          if (patterns.length === 0) {
            duplicatesContainer.innerHTML =
              "<p>No patterns with thumbnails available to scan.</p>";
            return;
          }

          // Generate hashes for patterns that don't have them yet
          const patternsWithoutHash = patterns.filter((p) => !p.thumbnailHash);

          if (patternsWithoutHash.length > 0) {
            duplicatesContainer.innerHTML =
              '<div class="loading"></div> Generating hashes for patterns...';

            for (const pattern of patternsWithoutHash) {
              try {
                // Use the appropriate thumbnail source
                const thumbnailSrc = appSettings.storeThumbnailsAsBase64
                  ? pattern.encodedThumbnail
                  : pattern.thumbnailPath;

                if (thumbnailSrc) {
                  pattern.thumbnailHash = await generateThumbnailHash(
                    thumbnailSrc
                  );
                }
              } catch (error) {
                console.error(
                  `Error generating hash for pattern ${pattern.id}:`,
                  error
                );
              }
            }

            // Save the newly generated hashes
            saveDataToLocalStorage();
          }

          // Group patterns by hash
          const hashedPatterns = {};
          patterns
            .filter((p) => p.thumbnailHash)
            .forEach((pattern) => {
              if (!hashedPatterns[pattern.thumbnailHash]) {
                hashedPatterns[pattern.thumbnailHash] = [];
              }
              hashedPatterns[pattern.thumbnailHash].push(pattern.id);
            });

          // Find duplicate sets (patterns with the same hash)
          let duplicates = Object.values(hashedPatterns).filter(
            (patternIds) => patternIds.length > 1
          );

          // Sort each duplicate set internally by creator name
          duplicates = duplicates.map((patternIds) => {
            return patternIds.sort((a, b) => {
              const patternA = appData.patterns[a];
              const patternB = appData.patterns[b];
              if (!patternA || !patternB) return 0;

              // First sort by creator name
              const creatorCompare = patternA.creatorName.localeCompare(
                patternB.creatorName
              );

              // If creator names are the same, then sort by pattern name
              if (creatorCompare === 0) {
                return patternA.patternName.localeCompare(patternB.patternName);
              }

              return creatorCompare;
            });
          });

          // Sort duplicate sets by the first pattern's creator name
          duplicates.sort((setA, setB) => {
            const firstPatternA = appData.patterns[setA[0]];
            const firstPatternB = appData.patterns[setB[0]];

            if (!firstPatternA || !firstPatternB) return 0;

            return firstPatternA.creatorName.localeCompare(
              firstPatternB.creatorName
            );
          });

          // Render results
          if (duplicates.length === 0) {
            duplicatesContainer.innerHTML =
              "<p>No duplicate patterns found.</p>";
          } else {
            duplicatesContainer.innerHTML = `
                <div class="success-message">Found ${duplicates.length} sets of duplicate patterns.</div>
                <div class="duplicate-sets-container"></div>
            `;

            const container = duplicatesContainer.querySelector(
              ".duplicate-sets-container"
            );

            // Render each duplicate set
            duplicates.forEach((set, index) => {
              const setDiv = document.createElement("div");
              setDiv.className = "duplicate-set";

              // Get patterns in this set
              const setPatterns = set
                .map((id) => appData.patterns[id])
                .filter((p) => p); // Filter out any null/undefined patterns

              setDiv.innerHTML = `
                <div class="duplicate-set-header">
                    <h3>Duplicate Set #${index + 1}</h3>
                    <div class="similarity-info">
                        <span class="similarity-badge high">Exact Match</span>
                    </div>
                </div>
                <div class="duplicate-patterns">
                    ${setPatterns
                      .map(
                        (pattern, index) => `
                        <div class="duplicate-pattern" data-id="${pattern.id}">
                            <div class="pattern-preview">
                                <img src="${getPatternThumbnailSrc(
                                  pattern
                                )}" alt="${
                          pattern.patternName
                        }" class="pixel-art-image">
                                <div class="pattern-select">
                                    <input type="radio" name="primary-${index}" value="${
                          pattern.id
                        }" 
                                        id="primary-${pattern.id}" ${
                          set.indexOf(pattern.id) === 0 ? "checked" : ""
                        }>
                                    <label for="primary-${
                                      pattern.id
                                    }">Primary</label>
                                </div>
                            </div>
                            <div class="pattern-details">
                                <div class="pattern-name">${
                                  pattern.patternName
                                }</div>
                                <div class="pattern-creator">by ${
                                  pattern.creatorName
                                }</div>
                                <div class="pattern-metadata">
                                    <span>File: ${
                                      pattern.fileName || "Unknown"
                                    }</span>
                                    <span>Added: ${
                                      pattern.dateAdded || "Unknown"
                                    }</span>
                                    <span>${
                                      pattern.tags.length > 0
                                        ? `Tags: ${pattern.tags.join(", ")}`
                                        : "No tags"
                                    }</span>
                                    <span>${
                                      pattern.setName
                                        ? `In set: ${pattern.setName}`
                                        : "Not in a set"
                                    }</span>
                                </div>
                            </div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
                <div class="duplicate-actions">
                    <button class="btn" data-action="merge" data-set="${index}">Merge Selected as Primary</button>
                    <button class="btn btn-secondary" data-action="keep-all" data-set="${index}">Keep All as Related</button>
                    <button class="btn btn-secondary" data-action="ignore" data-set="${index}">Ignore</button>
                </div>
            `;

              container.appendChild(setDiv);
            });

            // Add event listeners for action buttons
            container
              .querySelectorAll('[data-action="merge"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  const radioName = `primary-${setIndex}`;
                  const checkedRadio = container.querySelector(
                    `input[name="${radioName}"]:checked`
                  );

                  if (checkedRadio) {
                    const primaryId = checkedRadio.value;
                    const setIds = duplicates[setIndex];
                    mergeDuplicates(setIds, primaryId);
                  } else {
                    showNotification(
                      "Please select a primary pattern",
                      "error"
                    );
                  }
                });
              });

            container
              .querySelectorAll('[data-action="keep-all"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  keepAllDuplicates(duplicates[setIndex]);
                });
              });

            container
              .querySelectorAll('[data-action="ignore"]')
              .forEach((button) => {
                button.addEventListener("click", () => {
                  const setIndex = parseInt(button.getAttribute("data-set"));
                  const setDiv = button.closest(".duplicate-set");
                  setDiv.remove();

                  // Check if there are any sets left
                  if (
                    container.querySelectorAll(".duplicate-set").length === 0
                  ) {
                    duplicatesContainer.innerHTML =
                      "<p>No duplicate patterns found.</p>";
                  }
                });
              });
          }
        } catch (error) {
          console.error("Error scanning for duplicates:", error);
          duplicatesContainer.innerHTML = `<div class="error-message">Error scanning for duplicates: ${error.message}</div>`;
        }
      }

      // Compare two images for similarity
      async function compareImages(src1, src2, canvas, ctx) {
        return new Promise((resolve, reject) => {
          const img1 = new Image();
          const img2 = new Image();

          let img1Loaded = false;
          let img2Loaded = false;

          img1.onload = function () {
            img1Loaded = true;
            if (img2Loaded) compareLoaded();
          };

          img2.onload = function () {
            img2Loaded = true;
            if (img1Loaded) compareLoaded();
          };

          img1.onerror = img2.onerror = function () {
            reject(new Error("Error loading image for comparison"));
          };

          function compareLoaded() {
            try {
              // Draw first image
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img1, 0, 0, canvas.width, canvas.height);
              const data1 = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Draw second image
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img2, 0, 0, canvas.width, canvas.height);
              const data2 = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;

              // Compare pixel data
              let diff = 0;
              let total = data1.length;

              for (let i = 0; i < total; i += 4) {
                // Calculate color difference in RGB channels
                diff += Math.abs(data1[i] - data2[i]); // R
                diff += Math.abs(data1[i + 1] - data2[i + 1]); // G
                diff += Math.abs(data1[i + 2] - data2[i + 2]); // B
              }

              // Calculate average difference per pixel
              const avgDiff = diff / (total / 4);

              // Consider images equal if the difference is below threshold
              // Adjust this threshold based on your needs
              resolve(avgDiff < 10);
            } catch (error) {
              reject(error);
            }
          }

          // Set image sources to start loading
          img1.src = src1;
          img2.src = src2;
        });
      }

      // Merge duplicate patterns
      async function mergeDuplicates(patternIds, primaryId) {
        if (!patternIds || patternIds.length < 2) return;

        // Find primary pattern
        const primary = appData.patterns[primaryId];
        if (!primary) return;

        // Move primary to beginning of array (if not already)
        patternIds = [
          primaryId,
          ...patternIds.filter((id) => id !== primaryId),
        ];

        // Collect tags from all duplicates
        const allTags = new Set(primary.tags);

        // Process each duplicate
        for (let i = 1; i < patternIds.length; i++) {
          const duplicateId = patternIds[i];
          const duplicate = appData.patterns[duplicateId];

          if (!duplicate) continue;

          // Collect tags
          duplicate.tags.forEach((tag) => allTags.add(tag));

          // If the duplicate is in a set but the primary isn't, move primary to that set
          if (duplicate.setId && !primary.setId) {
            primary.setId = duplicate.setId;
            primary.setName = duplicate.setName;
            primary.setOrder = duplicate.setOrder;

            // Update set data
            const set = appData.sets[duplicate.setId];
            if (set) {
              set.patterns = set.patterns.map((id) =>
                id === duplicateId ? primaryId : id
              );
            }
          }

          // Combine notes if any
          if (duplicate.notes && duplicate.notes !== primary.notes) {
            primary.notes = primary.notes
              ? primary.notes + "\n\nFrom merged pattern: " + duplicate.notes
              : "From merged pattern: " + duplicate.notes;
          }

          // Keep thumbnail data if primary doesn't have it
          if (appSettings.storeThumbnailsAsBase64) {
            if (!primary.thumbnailPath && duplicate.thumbnailPath) {
              primary.thumbnailPath = duplicate.thumbnailPath;
            }
          }

          // Keep original file path if primary doesn't have it
          if (!primary.thumbnailPath && duplicate.thumbnailPath) {
            primary.thumbnailPath = duplicate.thumbnailPath;
          }

          // Remove from creator's patterns
          const creatorId = Object.keys(appData.creators).find((cid) =>
            appData.creators[cid].patterns.includes(duplicateId)
          );

          if (creatorId && appData.creators[creatorId]) {
            appData.creators[creatorId].patterns = appData.creators[
              creatorId
            ].patterns.filter((id) => id !== duplicateId);
            appData.creators[creatorId].totalBackedUp =
              appData.creators[creatorId].patterns.length;
          }

          // Delete the duplicate pattern
          delete appData.patterns[duplicateId];
        }

        // Update the primary pattern with all collected tags
        primary.tags = [...allTags];
        primary.lastModified = new Date().toISOString().split("T")[0];

        // Save data
        saveDataToLocalStorage();

        // Refresh views
        scanForDuplicates();
        renderPatternGallery();
        renderSidebarFilters();

        showNotification("Duplicate patterns merged successfully");
      }

      // Keep all duplicate patterns but mark them as related
      function keepAllDuplicates(patternIds) {
        if (!patternIds || patternIds.length < 2) return;

        // Update each pattern to reference others as related
        patternIds.forEach((id) => {
          const pattern = appData.patterns[id];
          if (!pattern) return;

          // Set related patterns (excluding self)
          pattern.relatedPatterns = patternIds.filter((pid) => pid !== id);
          pattern.lastModified = new Date().toISOString().split("T")[0];
        });

        // Save data
        saveDataToLocalStorage();

        // Refresh views
        scanForDuplicates();

        showNotification("Patterns marked as related");
      }

      // Function to add the "Add Creator" button to the creator tab
      function addCreateCreatorButton() {
        const creatorActionBar = document.querySelector(
          "#creators .action-bar"
        );
        const createBtn = document.createElement("button");
        createBtn.id = "create-creator-btn";
        createBtn.className = "btn create-creator-btn";
        createBtn.textContent = "Add Creator";
        createBtn.addEventListener("click", openCreateCreatorModal);

        creatorActionBar.appendChild(createBtn);
      }

      // 4. Create the Creator form modal
      function createCreatorModal() {
        const modal = document.createElement("div");
        modal.className = "modal-backdrop";
        modal.id = "creator-modal";

        modal.innerHTML = `
          <div class="modal">
            <button class="modal-close">&times;</button>
            <h2 class="modal-title" id="creator-modal-title">Add New Creator</h2>
            
            <div class="form-group">
              <label for="creator-name-input">Creator Name*</label>
              <input type="text" id="creator-name-input" required>
            </div>
            
            <div class="form-group">
              <label for="creator-town-input">Town Name*</label>
              <input type="text" id="creator-town-input" required>
            </div>
            
            <div class="form-group">
              <label for="creator-code-input">Creator Code</label>
              <input type="text" id="creator-code-input" placeholder="MA-####-####-####" pattern="MA-\\d{4}-\\d{4}-\\d{4}">
              <p class="help-text">Format: MA-####-####-#### (e.g., MA-1234-5678-9012)</p>
            </div>
            
            <div class="form-group">
              <label for="creator-rank-input">Creator Rank</label>
              <select id="creator-rank-input">
                <option value="unknown">Unknown (Default)</option>
                <option value="verified">Verified (Original Creator)</option>
                <option value="plagiarist">Plagiarist (Copies Others' Work)</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="creator-total-input">Total Patterns</label>
              <input type="number" id="creator-total-input" min="0" value="0">
              <p class="help-text">Set the total number of patterns this creator has made (if known).</p>
            </div>
            
            <div class="form-group">
              <label for="creator-complete-input">Collection Status</label>
              <select id="creator-complete-input">
                <option value="false" selected>Incomplete</option>
                <option value="true">Complete</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="creator-notes-input">Notes</label>
              <textarea id="creator-notes-input" rows="4"></textarea>
            </div>
            
            <button class="btn" id="save-creator-btn">Save Creator</button>
          </div>
        `;

        document.body.appendChild(modal);

        // Set up the close button
        modal.querySelector(".modal-close").addEventListener("click", () => {
          document.body.removeChild(modal);
        });

        // Set up the save button
        modal
          .querySelector("#save-creator-btn")
          .addEventListener("click", saveCreator);

        // Add creator code formatter
        const creatorCodeInput = modal.querySelector("#creator-code-input");
        creatorCodeInput.addEventListener("input", formatCreatorCode);

        return modal;
      }

      // 5. Format creator code as user types (MA-####-####-####)
      function formatCreatorCode(e) {
        const input = e.target;
        let value = input.value.replace(/[^A-Ma-m0-9]/g, "").toUpperCase();

        // Make sure it starts with MA
        if (value.length >= 2 && value.substring(0, 2) !== "MA") {
          value =
            "MA" + value.substring(value.length - Math.min(value.length, 12));
        } else if (value.length < 2) {
          value = value.padStart(2, "M");
        }

        // Format with dashes
        if (value.length > 2) {
          let formatted = value.substring(0, 2) + "-";

          // Add first group of digits
          const firstGroup = value.substring(2, 6);
          formatted += firstGroup;

          // Add second group if we have it
          if (value.length > 6) {
            formatted += "-" + value.substring(6, 10);

            // Add third group if we have it
            if (value.length > 10) {
              formatted += "-" + value.substring(10, 14);
            }
          }

          value = formatted;
        }

        input.value = value;
      }

      // 6. Open Creator Modal for adding a new creator
      function openCreateCreatorModal() {
        const modal = createCreatorModal();
        modal.style.display = "flex";
        document.getElementById("creator-modal-title").textContent =
          "Add New Creator";
        document.getElementById("creator-name-input").focus();
      }

      // 7. Save a new or edited creator
      function saveCreator() {
        const nameInput = document.getElementById("creator-name-input");
        const townInput = document.getElementById("creator-town-input");

        // Validate required fields
        if (!nameInput.value.trim() || !townInput.value.trim()) {
          showNotification(
            "Creator Name and Town Name are required fields",
            "error"
          );
          return;
        }

        const name = nameInput.value.trim();
        const town = townInput.value.trim();
        const code = document.getElementById("creator-code-input").value.trim();
        const rank = document.getElementById("creator-rank-input").value;
        const total =
          parseInt(document.getElementById("creator-total-input").value) || 0;
        const isComplete =
          document.getElementById("creator-complete-input").value === "true";
        const notes = document
          .getElementById("creator-notes-input")
          .value.trim();

        // Generate creator ID
        const creatorId =
          document.getElementById("save-creator-btn").getAttribute("data-id") ||
          generateCreatorId(name, town, true);

        // Check for existing creator with same name+town
        const existingCreator = Object.values(appData.creators).find(
          (c) =>
            c.name.toLowerCase() === name.toLowerCase() &&
            c.townName.toLowerCase() === town.toLowerCase() &&
            c.id !== creatorId
        );

        if (existingCreator) {
          showNotification(
            "A creator with this name and town already exists",
            "error"
          );
          return;
        }

        // Create or update the creator
        appData.creators[creatorId] = {
          id: creatorId,
          name: name,
          townName: town,
          creatorCode: code,
          rank: rank,
          patterns: appData.creators[creatorId]?.patterns || [],
          totalBackedUp: appData.creators[creatorId]?.totalBackedUp || 0,
          totalPatterns: total,
          isComplete: isComplete,
          notes: notes,
        };

        // Save to localStorage
        saveDataToLocalStorage();

        // Close the modal
        const modal = document.getElementById("creator-modal");
        document.body.removeChild(modal);

        // Refresh creators view
        renderCreators();

        // Refresh pattern gallery to update badges
        renderPatternGallery();

        showNotification("Creator saved successfully");
      }

      // Setup collapsible sidebar sections
      function setupCollapsibleSidebar() {
        const sidebarTitles = document.querySelectorAll(".sidebar-title");

        sidebarTitles.forEach((title) => {
          // Add click event
          title.addEventListener("click", () => {
            const section = title.closest(".sidebar-section");
            section.classList.toggle("collapsed");
            title.classList.toggle("collapsed");
          });
        });

        // Initialize Creators section as collapsed
        const creatorsSection = document.querySelector(
          ".sidebar-section:has(#creator-filters)"
        );
        if (creatorsSection) {
          creatorsSection.classList.add("collapsed");
          creatorsSection
            .querySelector(".sidebar-title")
            .classList.add("collapsed");
        }
      }

      // Show notification
      function showNotification(message, type = "success") {
        const notification = elements.notification;
        notification.textContent = message;
        notification.className = "notification show " + type;

        setTimeout(() => {
          notification.classList.remove("show");
        }, 3000);
      }

      // Debounce function for search input
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      // Initialize the app
      document.addEventListener("DOMContentLoaded", initApp);
    </script>
  </body>
</html>
